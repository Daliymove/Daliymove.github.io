---
title: Java虚拟机之初出茅庐
highlight_shrink: false
date: 2020-07-18 08:37:27
updated:
top: 
tags: 
    - java
    - 虚拟机
categories: 技术
keywords:
description: 一些虚拟机方面的读书分享
top_img: https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/007.jpg
comments:
cover: https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/007.jpg
toc_number:
auto_open:
copyright:
mathjax:
katex:
aplayer:
---

# Java虚拟机

---

## 来一些干历史

### 世界上第一款商用Java虚拟机

>是什么呢？ 它就是我们如今虚拟机的始祖，Sun Classic虚拟机
>
>这款虚拟机发布于JDK1.0版本，离我们已经相当遥远了，它只能通过纯解释器方式来执行Java代码，如果此时要使用即时编译器，那么这个虚拟机的解释器就只能进行外挂，而外挂的结果就是编译器完全接管了虚拟机的执行系统，解释器不能进行正常工作；
>
>可见古老的科技还是比较落后的，没有特变强大的适应力；

### 如今的主流虚拟机：Hotspot VM

> 没错，这台虚拟机就是我们如今现在正在使用的Java虚拟机，也是目前使用范围最广的虚拟机，他是Sun/OracleJDK 中的默认虚拟机，它最强大的功能就是像它名字所说的“热”技术，也就是热点代码探测技术，热点探测技术可以通过执行计数器找出最具有编译价值的代码，然后通知及时编译器以方法为单位进行编译；
>
> 那它主要的结构是什么呢？
>
> 它的即时编译系统主要有两部分，第一部分是主要负责编译耗时短，输出代码优化程度比较低的客户端编译器，简称C1，另一部分是编译耗时时间长，但代码优化质量比较高的服务端编译器，简称C2；他们通常会在分层编译的机制下与解释器相互配合来共同构成Hotspot虚拟机的执行子系统（抱歉，不是太了解什么是执行子系统，在这里就不要多提问了！）
>
> 自JDK10起，Hotspot 编译器中又多加了一个新“兄弟”：Graal编译器，它的长远目标是用于替代C2的，尽管如今的C2还能用，但是由于历史长久的原因，它的身材已经过于庞大了，维护起来相当困难，已经连当初创作它的Cliiff Click博士本人都不愿意去维护这个庞大的家伙；所以，Graal 编译器应运而生，目前Graal 编译器的性能已经基本上与C2持平了，个人觉得取代只是迟早的事情；

### 黑科技之Graal VM

> 2018年4月，Oracle Labs公开了一项黑科技，Graal VM，它是在HotSpot 虚拟机的基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台来使用；在此不再过多赘述了，有兴趣的可以了解一下，据称是未来可以替代Hotspot的候选项；

在此总结一下：Java为什么能成为世界第一的计算机编程语言，一方面出于它结构严谨，面向对象的思想，另一方面是多平台的优势，即编译一次，随处运行，而多平台归功于Java虚拟机的强大，虚拟机帮助它实现了热点代码检测以及运行时编译及优化；此外，还有它的开源性以及强大的第三方类库，帮助着用户解决各种各样的难题········

## Java虚拟机运行时数据区域

我们之前学过，虚拟机的运行时内存划分为 栈，堆，方法区、PC寄存器、本地方法栈五大类；在这里我按照虚拟机相关的书籍大概总结了一下，如图：

![](https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200718110626591.png)

我们先来明确一个概念：什么是**线程私有**内存；

> 线程私有内存，通俗来讲就是各线程之间互不影响，独自存储和使用的内存空间，称之为线程私有内存；

### 程序计数器

> 程序计数器（Program Counter Register）也叫PC寄存器，它在虚拟机中的主要作用是记录线程执行的字节码的行号指示器；
>
> 在编译过程中，字节码解释器怎么获取下一行应该执行什么内容呢？它通过改变程序计数器的值，来获取下一行需要执行的字节码指令；可以把它看成是程序控制的一个指示器，循环，跳转，异常处理，线程恢复，都依赖于计数器的指示下进行；
>
> 另外，除了引导程序流，它还是多线程轮流切换的一个flag；A 线程跳转到 B 线程后，怎么回到A 呢，这个时候靠程序计数器的引导下回来；所以，程序计数器是线程私有内存，每一个线程只能拥有一个程序计数器；
>
> 此外，当线程执行的是Java方法时，程序计数器几率的是虚拟机字节码指令的地址，如果执行的是本地方法时，计数器记录的是空；

### 虚拟机栈

> 虚拟机栈，也就是我们平常所说的 “栈”，只不过我们一般只关注它的局部变量部分；虚拟机栈描述的是Java方法执行的线程内存模型，即每个方法被执行的时候，虚拟机都会同步创建一个**栈桢**来存储局部变量表，操作数栈、动态连接、方法出口等信息。当一个方法被调用的，对应着一个栈桢在虚拟机栈中入栈，一个方法执行完，对应从虚拟机中出栈；一个方法对应着一个栈桢；
>
> 虚拟机栈空间也是线程私有的，它与线程的生命周期相同，同生共死；
>
> 局部变量表存储着各种基本数据类型（int/float/char/double.....)以及对象引用（reference，指向对象起始地址的引用指针）和 returnAddress （指向一条字节码指令的地址）；这些数据类型在局部变量表的存储形式以局部变量槽（Slot）的形式体现，其中long、double 类型的数据会占两个变量槽，其余类型的数据占一个，具体如图所示

![](https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200718115902122.png)

### 本地方法栈

> 本地方法栈与虚拟机栈的作用类似，主要区别就是本地方法栈对应的是本地方法(Native Method)，本地方法指其它编程语言的方法，类如（C、C++等），在读取.dll文件内的方法时，Java调用非Java代码的接口，就会开启本地方法栈；在此不多做描述；

### Java堆

> 堆（Heap）大家应该比较熟悉，是整个虚拟机所管理内从中最大的一块，也是被所有线程所共享的一块内存区域；此内存区块存在的唯一目的就是存放对象实例，没错，就是**new 对象**；基本可以认为，所有的实例对象都存放于堆中；同时，Java堆也只能存放实例对象；
>
> Java堆内存是垃圾回收器重点关注区域，所以有一些资料也称其为 GC堆；按照以往的垃圾回收器机制来划分，堆可以划分为“新生代、老年代、永久代、Eden、Survivor·······”；但站在目前的角度来说，应该根据虚拟机所用的堆内存垃圾回收器的具体机制来划分；
>
> 堆中内存的分配方式：这个涉及到 虚拟机的类加载机制，我还没研究透，但总体来说有两种；
>
> 第一种是基于堆内存空间规整的分配方式，这个条件下，堆内存的分配方式为“指针碰撞”；
>
> 第二种是堆内存空间不规整的情况下划分，这种情况没有办法进行简单的指针碰撞，需要通过一个列表来记录，哪些内存是可用的，找到一块足够大，能装的下对象内存的区域后，再划分给对象，这种分配方式叫“空闲列表”；

### 方法区（没想好怎么写）

> 方法区与堆 一样，是各个线程共享的内存区域，用于储存已经被虚拟机加载的类型信息、常量、静态变量、即时编译器后的代码缓存等数据；它有个有意思的别名，叫做 **非堆**。
>
> ![](https://img-blog.csdn.net/20171115215708642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ2JpYW8wMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)



