<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><link rel=manifest href=/manifest.json><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>redis入门 | CodeJenny</title><meta name="description" content="RedisNoSql的特点： 高并发 高可用 易扩展 高效存储 常见的 Nosql 产品：  什么是RedisRedis 全称：REmote DIctionary Server（远程字典服务器）。用C语言编写的，完全开源免费，它遵守BCD协议。是一个高性能的(key&#x2F;value)分布式内存数据库； Redis 的优势： (1) 性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81"><meta name="keywords" content="redis,Nosql"><meta name="author" content="CodeJenny"><meta name="copyright" content="CodeJenny"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://codejenny.top/posts/52715.html"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="redis入门"><meta property="og:url" content="https://codejenny.top/posts/52715.html"><meta property="og:site_name" content="CodeJenny"><meta property="og:description" content="RedisNoSql的特点： 高并发 高可用 易扩展 高效存储 常见的 Nosql 产品：  什么是RedisRedis 全称：REmote DIctionary Server（远程字典服务器）。用C语言编写的，完全开源免费，它遵守BCD协议。是一个高性能的(key&#x2F;value)分布式内存数据库； Redis 的优势： (1) 性能极高 – Redis能读的速度是110000次&#x2F;s,写的速度是81"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/psb (1).png"><meta property="article:published_time" content="2020-09-08T03:20:23.000Z"><meta property="article:modified_time" content="2020-09-18T06:29:11.336Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="prev" title="Spring 入门" href="https://codejenny.top/posts/14131.html"><link rel="next" title="正则表达式" href="https://codejenny.top/posts/46563.html"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }
    
    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }
    
   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}
    
    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}
    
   
    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script><meta name="generator" content="Hexo 4.1.1"><link rel="alternate" href="/atom.xml" title="CodeJenny" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>
 <div id="loading-container">
     <p class="loading-text">玩命加载中 . . . </p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">16</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">22</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">9</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-camera"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis"><span class="toc-text">Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是Redis"><span class="toc-text">什么是Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#安装Redis"><span class="toc-text">安装Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis常用数据结构"><span class="toc-text">Redis常用数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis常用指令"><span class="toc-text">Redis常用指令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串数字的递增递减"><span class="toc-text">字符串数字的递增递减</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash散列"><span class="toc-text">Hash散列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-有序集合"><span class="toc-text">list (有序集合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set集合-（无序不重复）"><span class="toc-text">Set集合 （无序不重复）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Zset-有序集合，可排序"><span class="toc-text">Zset (有序集合，可排序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyoperLogLog"><span class="toc-text">HyoperLogLog</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其它指令"><span class="toc-text">其它指令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-事务"><span class="toc-text">Redis 事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-发布订阅模式"><span class="toc-text">Redis 发布订阅模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-Jedis-连接"><span class="toc-text">Redis Jedis 连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-持久化策略"><span class="toc-text">Redis 持久化策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RDB-策略（默认）"><span class="toc-text">RDB 策略（默认）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOF持久化"><span class="toc-text">AOF持久化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis主从复制"><span class="toc-text">Redis主从复制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis哨兵模式"><span class="toc-text">Redis哨兵模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-集群"><span class="toc-text">Redis 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何建立集群模式"><span class="toc-text">如何建立集群模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis-缓存穿透、缓存雪崩"><span class="toc-text">Redis 缓存穿透、缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是缓存穿透"><span class="toc-text">什么是缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存穿透？"><span class="toc-text">缓存穿透？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缓存雪崩"><span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么是缓存雪崩？"><span class="toc-text">什么是缓存雪崩？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有哪些解决办法？"><span class="toc-text">有哪些解决办法？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何保证缓存和数据库数据的一致性？"><span class="toc-text">如何保证缓存和数据库数据的一致性？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis分布式锁"><span class="toc-text">Redis分布式锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考文章"><span class="toc-text">参考文章</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div id="web_bg" data-type="color"></div><header class="post-bg" id="page-header" style="background-image: url(https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/psb (1).png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">CodeJenny</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/photos/"><i class="fa-fw fa fa-camera"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">redis入门</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-09-08 11:20:23"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-09-08</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-09-18 14:29:11"><i class="fas fa-history fa-fw"></i> 更新于 2020-09-18</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Nosql/">Nosql</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">5.4k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 18 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/posts/52715.html#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/posts/52715.html" itemprop="commentCount"></span></a></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>NoSql的特点： 高并发 高可用 易扩展 高效存储</p>
<p>常见的 Nosql 产品：</p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200905092622573.png" alt="image-20200905092622573"></p>
<h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis 全称：REmote DIctionary Server（远程字典服务器）。用C语言编写的，完全开源免费，它遵守BCD协议。是一个高性能的(key/value)<strong>分布式内存数据库</strong>；</p>
<p>Redis 的优势：</p>
<p>(1) <strong>性能极高</strong> – Redis能读的速度是110000次/s,写的速度是81000次/s 。</p>
<p>(2) <strong>丰富的数据类型</strong> – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p>
<p>(3) <strong>原子</strong> – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p>
<p>(4) <strong>丰富的特性</strong> – Redis还支持 publish/subscribe, 通知, key 过期等等特性</p>
<p>(5) <strong>采用单线程</strong>，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p>
<p>(6) 使用多路I/O复用模型，<strong>非阻塞IO</strong>(NIO) </p>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>Redis下载    <a href="Http://www.redis.cn/">码云下载</a></p>
<p>Redis 配置C++ 环境：yum -y install gcc-c++</p>
<p>创建目录 然后传入文件 redis-5.0.5.tar.gz</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">我创建的目录是 /home/redis</span><br><span class="line"></span><br><span class="line">到 redis 目录， 解压</span><br><span class="line">[root@localhost redis]# tar -zxvf redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line">进入 redis-5.0.5 目录 然后编译,将.c文件编译为.o文件</span><br><span class="line">[root@localhost redis]# cd redis-5.0.5</span><br><span class="line">[root@localhost redis-5.0.5]# make</span><br><span class="line"></span><br><span class="line">安装</span><br><span class="line">[root@localhost redis-5.0.5]make PREFIX=/home/redis install</span><br><span class="line">安装完成后会出现一个 bin 文件夹 进入文件夹ll 会看到如下命令</span><br><span class="line"></span><br><span class="line">redis -benchmark	--性能测试工具</span><br><span class="line">redis-check-aof 	--AOF 文件修复工具</span><br><span class="line">redis-check-rdb		--RDB 文件检查工具 （持久化策略需要）</span><br><span class="line">redis-cli			--命令行客户端</span><br><span class="line">redis-server		--redis 服务器启动</span><br><span class="line"></span><br><span class="line">前端启动 直接在bin文件夹下 ./redis-server</span><br><span class="line"></span><br><span class="line">后端启动需要redis.conf 文件</span><br><span class="line">copy conf文件到redis文件夹下 cp redis.conf /home/redis</span><br><span class="line">修改conf文件</span><br><span class="line">vim redis.conf</span><br><span class="line">到daemonize 下 将no 改为yes 即可通过后端启动</span><br><span class="line">启动命令：[root@localhost redis]# ./bin/redis-server ./redis.conf</span><br><span class="line">用 ps aux | grep redis 查看是否启动成功 </span><br><span class="line"></span><br><span class="line">配置redis 图形化软件</span><br><span class="line">1. 关闭linux 防火墙</span><br><span class="line">2. conf 配置 bind 用户IP 修改成当前lunux 对应的ip  </span><br><span class="line"></span><br><span class="line">进入客户端</span><br><span class="line">[root@localhost redis]# ./bin/redis-cli (需要在服务启动的情况下)</span><br><span class="line">进入后会显示IP + 端口号的形式,如 127.0.0.1:6379&gt;  </span><br><span class="line">如果配置了IP 需要用./bin/redis-cli -h IP号 的形式进入</span><br><span class="line">关闭服务器 在进入端口的前提下 输入shutdown即可关闭对应ip的redis服务器</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200905101058955.png" alt="image-20200905101058955"></p>
<p><strong>连接—关闭—查看</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200905113600571.png" alt="image-20200905113600571"></p>
<h2 id="Redis常用数据结构"><a href="#Redis常用数据结构" class="headerlink" title="Redis常用数据结构"></a>Redis常用数据结构</h2><p>Redis是一种基于内存的数据库，并且提供一定的持久化功能，它是一种键值（key-value）数据库，使用 key 作为索引找到当前缓存的数据，并且返回给程序调用者。</p>
<p>当前的 Redis 支持 6 种数据类型，它们分别是字符串（String）、列表（List）、集合（set）、哈希结构（hash）、有序集合（zset）和基数（HyperLogLog）</p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200905113750983.png" alt="image-20200905113750983"></p>
<h2 id="Redis常用指令"><a href="#Redis常用指令" class="headerlink" title="Redis常用指令"></a>Redis常用指令</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>set 键 值</p>
<p>get 键</p>
<p>mset 键 值 键 值 键 值…</p>
<p>mget 键 键 键…     没有值则返回 nil </p>
<p>DEL key</p>
<h4 id="字符串数字的递增递减"><a href="#字符串数字的递增递减" class="headerlink" title="字符串数字的递增递减"></a>字符串数字的递增递减</h4><p>INCR key （key没有值则从0开始 增加 1）</p>
<p>DECR key （key值减1）</p>
<p>INCRBY key increment （指定key 值增加多少）</p>
<p>DECRBY key increment （指定key 值减少多少）</p>
<h3 id="Hash散列"><a href="#Hash散列" class="headerlink" title="Hash散列"></a>Hash散列</h3><p>类似于 Java中的类属性</p>
<p>hset user1 name haha</p>
<p>hset user1 age 18</p>
<p>hget user1 age (取散列表中的值)</p>
<p>hmset key field value field value… (存多次值)</p>
<p>hmget key field field field…(取多次值)</p>
<p>hdel key field 删除</p>
<h3 id="list-有序集合"><a href="#list-有序集合" class="headerlink" title="list (有序集合)"></a>list (有序集合)</h3><p>lpush key value value value(往list 左边存多个值)</p>
<p>lpop key （取出左边第一个值） </p>
<p>rpush key value value value(往list 左边存多个值)</p>
<p>rpop key （取出左边第一个值） </p>
<p>llen kay    (查看key 中值的总数)</p>
<p>lrange key strat stop ( 查询key 中的多个值 第一个数值的坐标0)</p>
<p>左进右出  或者 右进左出  （队列的形式）</p>
<p>左进左出  或者  右进右出   （栈的形式）</p>
<h3 id="Set集合-（无序不重复）"><a href="#Set集合-（无序不重复）" class="headerlink" title="Set集合 （无序不重复）"></a>Set集合 （无序不重复）</h3><p>sadd key member member添加数据</p>
<p>smenbers key  查看key 的所有数据</p>
<p>srem key member删除信息</p>
<p>sismenber key member是否在set中</p>
<h3 id="Zset-有序集合，可排序"><a href="#Zset-有序集合，可排序" class="headerlink" title="Zset (有序集合，可排序)"></a>Zset (有序集合，可排序)</h3><p>zadd key menber </p>
<p>zrevrange key start stop 逆序排后返回结果</p>
<p>zscore key member </p>
<p>zrem key menber member …</p>
<p>zrevrange key start stop withscores  逆序排后返回结果包含分数</p>
<p>zincrby key increment member 给member 添加score</p>
<h3 id="HyoperLogLog"><a href="#HyoperLogLog" class="headerlink" title="HyoperLogLog"></a>HyoperLogLog</h3><p>HyperLogLog是一种使用随机化的算法，以少量内存提供集合中唯一元素数量的近似值。</p>
<p>PFADD key element [element …]    将指定的元素添加到指定的HyperLogLog 中</p>
<p>PFCOUNT key [key …]    返回给定 HyperLogLog 的基数估算值</p>
<p>PFMERGE destkey sourcekey [sourcekey …]    将多个 HyperLogLog 合并为一个 HyperLogLog</p>
<h3 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h3><p>keys * 查询所有key</p>
<p>keys k* 查询以k 开头的key</p>
<p>exist key 是否存在这个key</p>
<p>del key 删除这个key</p>
<p>rename 对可以重新命名</p>
<p>type key  查看key 的属性</p>
<p>expire key seconds 设置元素生存周期 多少秒后删除. </p>
<p>ttl key 查看剩余时间</p>
<p>presist 清除删除指令</p>
<p>info 查看服务器信息</p>
<p>flushdb 删库</p>
<p>flushall 删除全部数据库</p>
<p>select 0-15 选择数据库</p>
<p>move key 数据库号  移动key</p>
<h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>multi 开启事务</p>
<p>exec 执行事务操作，保存结果</p>
<p>discard 放弃事务操作</p>
<p>假如事务中出现插入错误，语法错误等信息，事务内容不会执行</p>
<h2 id="Redis-发布订阅模式"><a href="#Redis-发布订阅模式" class="headerlink" title="Redis 发布订阅模式"></a>Redis 发布订阅模式</h2><p>subscribe channel 订阅一个频道</p>
<p>publish channel message 发布信息</p>
<h2 id="Redis-Jedis-连接"><a href="#Redis-Jedis-连接" class="headerlink" title="Redis Jedis 连接"></a>Redis Jedis 连接</h2><p>1 创建Maven 项目，导入依赖</p>
<figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure>

<p>2 配置单实例连接</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Jedis jedis = new Jedis("192.168.150.100",6379);</span><br><span class="line">// 然后就可以进行配置了</span><br></pre></td></tr></tbody></table></figure>

<p>3 通过连接池连接</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 1.获取连接池配置对象,设置配置项</span></span><br><span class="line">JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line"><span class="comment">// 1.1最大的连接数</span></span><br><span class="line">config.setMaxTotal(<span class="number">30</span>);</span><br><span class="line"><span class="comment">// 1.2最大的空闲</span></span><br><span class="line">config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 2.获取连接池</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">"192.168.197.129"</span>, <span class="number">6379</span>);</span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">	jedis = jedisPool.getResource();</span><br><span class="line">	<span class="comment">// 3.设置数据</span></span><br><span class="line">	jedis.set(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">	String name = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">	System.out.println(<span class="string">"name="</span> + name);</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">	e.printStackTrace();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line">	<span class="keyword">if</span> (jedis != <span class="keyword">null</span>) {</span><br><span class="line">		jedis.close();</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">// 4.虚拟机关闭的时候，释放资源</span></span><br><span class="line">	<span class="keyword">if</span> (jedisPool != <span class="keyword">null</span>) {</span><br><span class="line">		jedisPool.close();</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h2 id="Redis-持久化策略"><a href="#Redis-持久化策略" class="headerlink" title="Redis 持久化策略"></a>Redis 持久化策略</h2><h3 id="RDB-策略（默认）"><a href="#RDB-策略（默认）" class="headerlink" title="RDB 策略（默认）"></a>RDB 策略（默认）</h3><p>dbfilename dump.rdb 存储文件名</p>
<p>优点：使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</p>
<p>缺点：RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</p>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF 默认关闭，开启方法，修改配置文件 reds.conf：appendonly yes</p>
<p>everysec：每秒同步一次，性能和安全都比较中庸的方式，也是 redis 推荐的方式。如果遇到物理服务器故障，有可能导致最近一秒内 aof 记录丢失(可能为部分丢失)</p>
<p>缺点 ： 文件较大，耗性能，恢复起来比较慢</p>
<h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>持久化保证了即使redis服务重启也不会丢失数据，但是当redis服务器的硬盘损坏了可能会导致数据丢失，通过redis的主从复制机制就可以避免这种单点故障（单台服务器的故障）</p>
<p>主redis中的数据和从上的数据保持实时同步,当主redis写入数据时通过主从复制机制复制到两个从服务上。</p>
<p>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求.</p>
<p>主机master配置:无需配置</p>
<p>操作步骤</p>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.复制出一个从机 bin文件夹 (也可以重新安装一下)</span><br><span class="line">[root@localhost redis-5.0.5]make PREFIX=/home/redis1 install</span><br><span class="line">2.修改从机的redis.conf</span><br><span class="line">/replicaof 192.168.150.100 6379</span><br><span class="line">3.修改从机的port地址为6380</span><br><span class="line">/port 6380</span><br><span class="line">4.启动从机服务器,启动6380客户端</span><br><span class="line">5.启动主机服务器,启动6379客户端</span><br></pre></td></tr></tbody></table></figure>

<p>注意：主机一旦发生增删改操作，那么从机会自动将数据同步到从机中；从机不能执行写操作,只能读</p>
<p><strong>复制的过程原理</strong></p>
<ul>
<li>当从库和主库建立MS(master slaver)关系后，会向主数据库发送SYNC命令；</li>
<li>主库接收到SYNC命令后会开始在后台保存快照（RDB持久化过程），并将期间接收到的写命令缓存起来；</li>
<li>快照完成后,主Redis会将快照文件和所有缓存的写命令发送给从Redis；</li>
<li>从Redis接收到后，会载入快照文件并且执行收到的缓存命令；</li>
<li>主Redis每当接收到写命令时就会将命令发送从Redis，保证数据的一致；【内部完成,所以不支持客户端在从机人为写数据。】</li>
</ul>
<p>复制架构中出现宕机情况?</p>
<p>从Redis宕机:<strong>重启就好</strong></p>
<p>主Redis宕机:从数据库(从机)中执行SLAVEOF NO ONE命令，断开主从关系并且提升为主库继续服务[把一个从做为主机，这个时候新主机[之前的从机]就具备写入的能力]；主服务器修好后，重新启动后，执行SLAVEOF命令，将其设置为从库[老主机设置为从机]。[手动执行，过程复杂，容易出错。]是否有更好的方案</p>
<h2 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h2><p>哨兵模式的实现</p>
<ul>
<li>启动哨兵进程，首先需要创建哨兵配置文件vi sentinel.conf,可从源码配置redis-5.0.5/sentinel.conf中复制内容，也可以直接自定义该文件到bin目录下</li>
<li>在配置中输入:sentinel monitor mastername 内网IP(127.0.0.1) 6379 1</li>
</ul>
<p>各参数的含义：</p>
<p><strong>mastername</strong>    监控主数据的名称，自定义<br><strong>127.0.0.1</strong>    监控主数据库的IP;<br><strong>6379</strong>    端口<br><strong>1</strong>    最低通过票数</p>
<ul>
<li>把日志写入指定的文件 </li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost bin]# ps aux|grep redis 查询所有的redis进程</span><br><span class="line">[root@localhost bin]# ./redis-sentinel ./sentinel.conf &gt;sent.log &amp;</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>哨兵启动方式:</li>
</ul>
<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost bin]# ./redis-server ../redis.conf --sentinel</span><br></pre></td></tr></tbody></table></figure>

<p>总结：<br>主从集群：主机有写入权限。从机没有，只有可读。<br>意外宕机方案:<br>手动恢复：人为重启服务器，主机宕，把从机设置为主机。<br>自动恢复：使用哨兵监控。自动切换主从</p>
<h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><p><strong>集群架构图</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200906114743402.png" alt="image-20200906114743402"></p>
<p>架构图解释</p>
<p>(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</p>
<p>(2)节点的fail是通过集群中超过半数的节点检测有效时整个集群才生效.</p>
<p>(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</p>
<p>(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value</p>
<p>Redis 集群中内置了 16384 个哈希槽，当用户进行了写的操作，其写入的数据会先对 key 用 crc16算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，同时，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点，如下图所示：</p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200906115200136.png" alt="image-20200906115200136"></p>
<p><strong>心跳机制</strong></p>
<ol>
<li>所有的master参与投票，如果半数的master主机与其中一个master主机通信超时，则可认为该主机挂掉</li>
</ol>
<p>集群不可用（fail）状态</p>
<ol>
<li>如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态</li>
<li>如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。</li>
</ol>
<h3 id="如何建立集群模式"><a href="#如何建立集群模式" class="headerlink" title="如何建立集群模式"></a>如何建立集群模式</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">最少集群演示（6台 redis）</span><br><span class="line">1. 创建文件夹 mkdir redis-cluster</span><br><span class="line">2. 从以前创建的主机中复制bin文件及 redis.conf文件 到 7001文件夹(这里直接将端口号命名成文件夹了)</span><br><span class="line">3. 删除 RDB 及 AOF 数据存储文件</span><br><span class="line">4. 修改redis.conf 文件 将Cluster-enable yes(默认是注释，将注释解掉)</span><br><span class="line">5. 复制出7002-7006 多台redis</span><br><span class="line">6. 修改7002-7006机器 redis.conf文件的端口</span><br><span class="line">7. 配置 startall.sh 文件，用与开启所有的redis服务器</span><br><span class="line"></span><br><span class="line">startall.sh 文件内容:</span><br><span class="line">cd 7001</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd 7002</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd 7003</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd 7004</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd 7005</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd 7006</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">8. 修改startall.sh文件的权限: chmod u+x startall.sh (这里u+x 也可以是 a+x...)</span><br><span class="line">9. 运行startall.sh</span><br><span class="line"></span><br><span class="line">10. 创建集群 进入7001 bin 目录下 </span><br><span class="line">./redis-cli --cluster create 192.168.150.100:7001 192.168.150.100:7002 192.168.150.100:7003 192.168.150.100:7004 192.168.150.100:7005 192.168.150.100:7006 --cluster-replicas 1</span><br><span class="line">如下图所示即为创建成功 主机端口为 7001 7002 7003</span><br><span class="line"></span><br><span class="line">11. 连接集群</span><br><span class="line">任意连接一个客户端： </span><br><span class="line">[root@localhost 7001]# ./bin/redis-cli -h 192.168.150.100 -p 7001 -c (-c的意思是集群连接)</span><br><span class="line">任意写入数据，redis集群会根据hash计算结果 自动分配给三个端口</span><br></pre></td></tr></tbody></table></figure>

<p><strong>搭建成功</strong></p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200918.png" alt="image-20200906120744216"></p>
<p><strong>查询集群及节点信息</strong></p>
<p>![image-20200906121956065](<a href="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/xshell" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/xshell</a> 集群节点信息.png)</p>
<p>通过jedis 2.9.0 连接 集群 </p>
<p>见Demo3</p>
<h2 id="Redis-缓存穿透、缓存雪崩"><a href="#Redis-缓存穿透、缓存雪崩" class="headerlink" title="Redis 缓存穿透、缓存雪崩"></a>Redis 缓存穿透、缓存雪崩</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h3 id="缓存穿透？"><a href="#缓存穿透？" class="headerlink" title="缓存穿透？"></a>缓存穿透？</h3><blockquote>
<p> 最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
</blockquote>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>{</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p><strong>2）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="bulongguolvqi"></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md" target="_blank" rel="noopener">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h4><p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>
<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p>
<p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p>
<p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>
<h4 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h4><p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ol>
<h3 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h3><p>细说的话可以扯很多，但是我觉得其实没太大必要（小声BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>
<p>下面单独对  <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li>
</ol>
<h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><p>具体参考课件吧！</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li>Redis 命令总结：<a href="http://Redisdoc.com/string/set.html" target="_blank" rel="noopener">http://Redisdoc.com/string/set.html</a></li>
<li>通俗易懂的 Redis 数据结构基础教程：<a href="https://juejin.im/post/5b53ee7e5188251aaa2d2e16" target="_blank" rel="noopener">https://juejin.im/post/5b53ee7e5188251aaa2d2e16</a></li>
<li>WHY Redis choose single thread (vs multi threads): <a href="https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153" target="_blank" rel="noopener">https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153</a></li>
</ul>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:null">CodeJenny</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://codejenny.top/posts/52715.html">https://codejenny.top/posts/52715.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://codejenny.top" target="_blank">CodeJenny</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a><a class="post-meta__tags" href="/tags/Nosql/">Nosql</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/psb (3).png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/reward/wechat.png" alt="wechat" onclick="window.open('/img/reward/wechat.png')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/reward/alipay.png" alt="alipay" onclick="window.open('/img/reward/alipay.png')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/14131.html"><img class="prev-cover" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/psb (2).jfif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Spring 入门</div></div></a></div><div class="next-post pull-right"><a href="/posts/46563.html"><img class="next-cover" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/psb (1).jfif" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">正则表达式</div></div></a></div></nav><hr><div id="post-comment"><div class="comment_headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var requestSetting = function (from,set) {
  var from = from
  var setting = set.split(',').filter(function(item){
  return from.indexOf(item) > -1
  });
  setting = setting.length == 0 ? from :setting;
  return setting
}

var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
var requiredFields = requestSetting(['nick','mail'],'nick,mail')

window.valine = new Valine({
  el:'#vcomment',
  appId: 'G7uhPAri9zkFqP59cRBjPRr2-gzGzoHsz',
  appKey: 'L6PUwfqsuDE1qmf6fHr4sokx',
  placeholder: 'Please leave your footprints',
  avatar: 'monsterid',
  meta: guestInfo,
  pageSize: '10',
  lang: 'zh-CN',
  recordIP: false,
  serverURLs: '',
  emojiCDN: '',
  emojiMaps: "",
  enableQQ: false,
  requiredFields: requiredFields
});</script></div></article></main><footer id="footer" style="background-image: url(https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/psb (1).png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2020 By CodeJenny</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://codejenny.top/">blog</a>!</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button class="translate_chn_to_cht" id="translateLink" title="简繁转换">繁</button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fas fa-comments"></i></a><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
  pangu.autoSpacingPage()
})</script><script src="/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'neutral',
  })
})
}</script><script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1602226205048')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body></html>