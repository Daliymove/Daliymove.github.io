<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql学习总结</title>
      <link href="/2020/08/05/mysql-zong-jie/"/>
      <url>/2020/08/05/mysql-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库就是按照数据结构来组织，存储和管理数据的仓库</p><p>数据库特点：</p><ul><li>对数据进行持久化保存</li><li>方便数据的存储和查询，速度快，安全，方便</li><li>可以处理并发访问</li><li>更加安全的权限管理访问机制</li></ul><p>常见的数据库：</p><p>Mysql 、oricle 、PostgerSQL 、SQLServer(微软)  关系型数据库<br>redis 非关系型数据库（数据存储在内存中，读取速度快，键值对的形式存储，不是二维表的形式）<br>mongoDB 文档型数据库 也是非关系型数据库   配合上面数据库使用 </p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎： 对具体数据进行操作，读取表中数据，以及将数据存储进物理内存中；</p><p>客户端： 连接 Mysql<br>服务器： 连接管理、查询缓存、语法解析、查询优化等操作<br>存储引擎：真实的存取数据</p><p>Mysql 支持的存储引擎：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200729164116.png" alt=""></p><blockquote><p>我们一般常用的是 InnoDB 与 MyISAM</p></blockquote><h3 id="InnoDB-与-MyISAM-的区别"><a href="#InnoDB-与-MyISAM-的区别" class="headerlink" title="InnoDB 与 MyISAM 的区别"></a>InnoDB 与 MyISAM 的区别</h3><blockquote><p>MyISAM是MySQL的默认数据库引擎（5.5版之前）,其提供了⼤量的特性，包括全⽂索引、压缩、空间函数等，但MyISAM不⽀持事务和行级锁，⽽且最⼤的缺陷就是崩溃后无法安全恢复，所以MySQL 5.5版本后默认的存储引擎修改为InnoDB。</p></blockquote><table><thead><tr><th align="center"></th><th align="center">InnoDB</th><th align="center">MyISAM</th></tr></thead><tbody><tr><td align="center">事务与锁</td><td align="center">支持事务和行级锁</td><td align="center">只支持表级锁</td></tr><tr><td align="center">存储结构</td><td align="center">两个（.frm .ibd ）</td><td align="center">三个（.frm .MYI .MYD）</td></tr><tr><td align="center">表主键</td><td align="center">没有会自动创建6字节主键</td><td align="center">允许没有任何索引和主键</td></tr><tr><td align="center">表行数</td><td align="center">未生成最大行数（count效率低）</td><td align="center">生成最大行数（count效率高）</td></tr><tr><td align="center">外键</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">CURD操作</td><td align="center">trancate table（用于删除大量行）</td><td align="center">适用于大量select 操作</td></tr><tr><td align="center">应用场景</td><td align="center">大型高并发应用</td><td align="center">小型应用</td></tr></tbody></table><ul><li>表级锁： MySQL中锁定<strong>粒度最大</strong>的⼀种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最⼤，触发锁冲突的概率最高，并发度最低， MyISAM和 InnoDB引擎都支持表级锁。 </li><li>行级锁： MySQL中锁定<strong>粒度最小</strong>的⼀种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><h2 id="mysql-事务"><a href="#mysql-事务" class="headerlink" title="mysql 事务"></a>mysql 事务</h2><p>事务：一系列增删改查等操作所组成的一个逻辑执行单元</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200805170325.png" alt=""></p><h3 id="事务的语法"><a href="#事务的语法" class="headerlink" title="事务的语法"></a>事务的语法</h3><p>事务开启： start transaction;/ begin;</p><p>提交：commit; 使得当前的修改确认</p><p>回滚：rollback; 使得当前的修改被放弃</p><h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><ul><li><strong>原子性</strong></li></ul><p>事务是最小的执行单位，事务开启后，操作要么全部成功，要么全部失败；</p><blockquote><p>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执⾏过程中出错， 会回滚到事务开始前的状态，所有的操作就像没有发⽣⼀样。也就是说事务是⼀个不可分割的整体，就像化学中学过的原⼦，是物质构成的基本单位。</p></blockquote><ul><li><strong>一致性</strong></li></ul><p>执行事务前后，数据保持一致，多个事务对同一数据的读取结果相同；（理解成数据的总和相同）A+ 则B-</p><ul><li><strong>隔离性</strong></li></ul><p>并发访问数据库时，⼀个用户的事务不被其他事务所⼲扰，各并发事务 之间数据库是独⽴的；</p><ul><li><strong>持久性</strong></li></ul><p>⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响； （写入磁盘，除非硬盘损坏）</p><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><p><strong>丢失修改：</strong>指一个事务读取一个数据时，另一个事务也对这个数据进行了读取，如果两个事务都对此数据进行了修改，那么前者的数据修改将会丢失；</p><p><strong>脏读：</strong>读到了未提交的数据； 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的 数据是脏数据。</p><p><strong>不可重复读：</strong>同⼀条命令返回不同的结果集；.事务 A 多次读取同⼀数据，事务 B 在事务A 多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同⼀数据时，结果不⼀致；</p><p><strong>幻读：</strong>重复查询的过程中，数据就发⽣了量的变化（insert， delete）</p><ul><li>诡异的更新事件：<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/1-15.jpg" alt=""></li></ul><p><strong>不可重复读和幻读区别：</strong> 不可重复读的重点是修改，比如多次读取⼀条记录发现其中某些列的值被修改，幻读的重点在于新增或删除，⽐如多次读取⼀条记录发现记录增多或减少了；</p><p><strong>顺序读：</strong> 隔离的最高级别，事务依次逐个进行，不允许并发执行；</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200805185614.png" alt=""></p><p>MySQL InnoDB 存储引擎的默认⽀持的隔离级别是 REPEATABLE-READ（可重读）；<br>mysql 5.7 可通过 <code>select @@tx_isolation;</code> 来查看；<br>mysql 8.0 以上可通过<code>select @@transaction_isolation;</code> 来查看；</p><h3 id="不同的隔离级别的锁的情况"><a href="#不同的隔离级别的锁的情况" class="headerlink" title="不同的隔离级别的锁的情况"></a>不同的隔离级别的锁的情况</h3><ol><li>读未提交（RU）: 有行级的锁，没有间隙锁。它与RC的区别是能够查询到未提交的数据。</li><li>读已提交（RC）：有行级的锁，没有间隙锁，读不到没有提交的数据。</li><li>可重复读（RR）：有行级的锁，也有间隙锁，每次读取的数据都是⼀样的，并且没有幻读的情况，存在诡异更新的情况。</li><li>序列化（S）：有行级锁，也有间隙锁，读表的时候，就已经上锁了</li></ol><h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><blockquote><p>事务中输入DDL(Data Define Language) 定义语句时，如(建库,建表,修改表,索引操作,存储过程,视图<strong>等修改表结构的操作</strong>)，都会将修改的结果进行隐式提交；</p></blockquote><h3 id="多版本控制MVCC"><a href="#多版本控制MVCC" class="headerlink" title="多版本控制MVCC"></a>多版本控制MVCC</h3><p>MVCC : 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><a href="https://blog.csdn.net/qq_34337272/article/details/80611486" target="_blank" rel="noopener">Mysql锁机制简单了解</a></p><h2 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h2><p>当MySQL单表记录数过⼤时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下：</p><ul><li>限定数据的范围</li></ul><p>添加限制条件，尽量少使用 * 的查找，除非表数据较少；</p><ul><li>读/写分离</li></ul><p>经典的数据库拆分⽅案，主库负责写，从库负责读；</p><ul><li>垂直分区</li></ul><ul><li>数据库分片</li></ul><p>MySQL大表优化⽅案：<a href="https://segmentfault.com/a/1190000006158186" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006158186</a></p><h2 id="Mysql-必读文章"><a href="#Mysql-必读文章" class="headerlink" title="Mysql 必读文章"></a>Mysql 必读文章</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485097&amp;idx=1&amp;sn=84c89da477b1338bdf3e9fcd65514ac1&amp;chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&amp;token=79317275&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">一条SQL语句在MySQL中如何执行的</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485117&amp;idx=1&amp;sn=92361755b7c3de488b415ec4c5f46d73&amp;chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&amp;token=79317275&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">MySQL高性能优化规范建议</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485185&amp;idx=1&amp;sn=66ef08b4ab6af5757792223a83fc0d45&amp;chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&amp;token=79317275&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">腾讯⾯试：⼀条SQL语句执⾏得很慢的原因有哪些？—不看后悔系列</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486461&amp;idx=1&amp;sn=60a22279196d084cc398936fe3b37772&amp;chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&amp;token=1987003517&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">书写高质量SQL的30条建议</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> SQL语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法的学习之路</title>
      <link href="/2020/07/28/suan-fa-de-xue-xi-zhi-lu/"/>
      <url>/2020/07/28/suan-fa-de-xue-xi-zhi-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="算法学习之路"><a href="#算法学习之路" class="headerlink" title="算法学习之路"></a>算法学习之路</h1><h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><p>一上来就是欧几里得算法，其实也就是求最大公约数，代码如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="number">0</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">int</span> r = p%q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q,r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>三行代码就求出来了， 是不是很优雅的操作，后面来介绍算法的时间复杂度与空间复杂度</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机之初出茅庐</title>
      <link href="/2020/07/18/java-xu-ni-ji-zhi-chu-chu-mao-lu/"/>
      <url>/2020/07/18/java-xu-ni-ji-zhi-chu-chu-mao-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h1><hr><h2 id="来一些干历史"><a href="#来一些干历史" class="headerlink" title="来一些干历史"></a>来一些干历史</h2><h3 id="世界上第一款商用Java虚拟机"><a href="#世界上第一款商用Java虚拟机" class="headerlink" title="世界上第一款商用Java虚拟机"></a>世界上第一款商用Java虚拟机</h3><blockquote><p>是什么呢？ 它就是我们如今虚拟机的始祖，Sun Classic虚拟机</p><p>这款虚拟机发布于JDK1.0版本，离我们已经相当遥远了，它只能通过纯解释器方式来执行Java代码，如果此时要使用即时编译器，那么这个虚拟机的解释器就只能进行外挂，而外挂的结果就是编译器完全接管了虚拟机的执行系统，解释器不能进行正常工作；</p><p>可见古老的科技还是比较落后的，没有特变强大的适应力；</p></blockquote><h3 id="如今的主流虚拟机：Hotspot-VM"><a href="#如今的主流虚拟机：Hotspot-VM" class="headerlink" title="如今的主流虚拟机：Hotspot VM"></a>如今的主流虚拟机：Hotspot VM</h3><blockquote><p>没错，这台虚拟机就是我们如今现在正在使用的Java虚拟机，也是目前使用范围最广的虚拟机，他是Sun/OracleJDK 中的默认虚拟机，它最强大的功能就是像它名字所说的“热”技术，也就是热点代码探测技术，热点探测技术可以通过执行计数器找出最具有编译价值的代码，然后通知及时编译器以方法为单位进行编译；</p><p>那它主要的结构是什么呢？</p><p>它的即时编译系统主要有两部分，第一部分是主要负责编译耗时短，输出代码优化程度比较低的客户端编译器，简称C1，另一部分是编译耗时时间长，但代码优化质量比较高的服务端编译器，简称C2；他们通常会在分层编译的机制下与解释器相互配合来共同构成Hotspot虚拟机的执行子系统（抱歉，不是太了解什么是执行子系统，在这里就不要多提问了！）</p><p>自JDK10起，Hotspot 编译器中又多加了一个新“兄弟”：Graal编译器，它的长远目标是用于替代C2的，尽管如今的C2还能用，但是由于历史长久的原因，它的身材已经过于庞大了，维护起来相当困难，已经连当初创作它的Cliiff Click博士本人都不愿意去维护这个庞大的家伙；所以，Graal 编译器应运而生，目前Graal 编译器的性能已经基本上与C2持平了，个人觉得取代只是迟早的事情；</p></blockquote><h3 id="黑科技之Graal-VM"><a href="#黑科技之Graal-VM" class="headerlink" title="黑科技之Graal VM"></a>黑科技之Graal VM</h3><blockquote><p>2018年4月，Oracle Labs公开了一项黑科技，Graal VM，它是在HotSpot 虚拟机的基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台来使用；在此不再过多赘述了，有兴趣的可以了解一下，据称是未来可以替代Hotspot的候选项；</p></blockquote><p>在此总结一下：Java为什么能成为世界第一的计算机编程语言，一方面出于它结构严谨，面向对象的思想，另一方面是多平台的优势，即编译一次，随处运行，而多平台归功于Java虚拟机的强大，虚拟机帮助它实现了热点代码检测以及运行时编译及优化；此外，还有它的开源性以及强大的第三方类库，帮助着用户解决各种各样的难题········</p><h2 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h2><p>我们之前学过，虚拟机的运行时内存划分为 栈，堆，方法区、PC寄存器、本地方法栈五大类；在这里我按照虚拟机相关的书籍大概总结了一下，如图：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200718110626591.png" alt=""></p><p>我们先来明确一个概念：什么是<strong>线程私有</strong>内存；</p><blockquote><p>线程私有内存，通俗来讲就是各线程之间互不影响，独自存储和使用的内存空间，称之为线程私有内存；</p></blockquote><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote><p>程序计数器（Program Counter Register）也叫PC寄存器，它在虚拟机中的主要作用是记录线程执行的字节码的行号指示器；</p><p>在编译过程中，字节码解释器怎么获取下一行应该执行什么内容呢？它通过改变程序计数器的值，来获取下一行需要执行的字节码指令；可以把它看成是程序控制的一个指示器，循环，跳转，异常处理，线程恢复，都依赖于计数器的指示下进行；</p><p>另外，除了引导程序流，它还是多线程轮流切换的一个flag；A 线程跳转到 B 线程后，怎么回到A 呢，这个时候靠程序计数器的引导下回来；所以，程序计数器是线程私有内存，每一个线程只能拥有一个程序计数器；</p><p>此外，当线程执行的是Java方法时，程序计数器几率的是虚拟机字节码指令的地址，如果执行的是本地方法时，计数器记录的是空；</p></blockquote><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote><p>虚拟机栈，也就是我们平常所说的 “栈”，只不过我们一般只关注它的局部变量部分；虚拟机栈描述的是Java方法执行的线程内存模型，即每个方法被执行的时候，虚拟机都会同步创建一个<strong>栈桢</strong>来存储局部变量表，操作数栈、动态连接、方法出口等信息。当一个方法被调用的，对应着一个栈桢在虚拟机栈中入栈，一个方法执行完，对应从虚拟机中出栈；一个方法对应着一个栈桢；</p><p>虚拟机栈空间也是线程私有的，它与线程的生命周期相同，同生共死；</p><p>局部变量表存储着各种基本数据类型（int/float/char/double…..)以及对象引用（reference，指向对象起始地址的引用指针）和 returnAddress （指向一条字节码指令的地址）；这些数据类型在局部变量表的存储形式以局部变量槽（Slot）的形式体现，其中long、double 类型的数据会占两个变量槽，其余类型的数据占一个，具体如图所示</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200718115902122.png" alt=""></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote><p>本地方法栈与虚拟机栈的作用类似，主要区别就是本地方法栈对应的是本地方法(Native Method)，本地方法指其它编程语言的方法，类如（C、C++等），在读取.dll文件内的方法时，Java调用非Java代码的接口，就会开启本地方法栈；在此不多做描述；</p></blockquote><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><blockquote><p>堆（Heap）大家应该比较熟悉，是整个虚拟机所管理内从中最大的一块，也是被所有线程所共享的一块内存区域；此内存区块存在的唯一目的就是存放对象实例，没错，就是<strong>new 对象</strong>；基本可以认为，所有的实例对象都存放于堆中；同时，Java堆也只能存放实例对象；</p><p>Java堆内存是垃圾回收器重点关注区域，所以有一些资料也称其为 GC堆；按照以往的垃圾回收器机制来划分，堆可以划分为“新生代、老年代、永久代、Eden、Survivor·······”；但站在目前的角度来说，应该根据虚拟机所用的堆内存垃圾回收器的具体机制来划分；</p><p>堆中内存的分配方式：这个涉及到 虚拟机的类加载机制，我还没研究透，但总体来说有两种；</p><p>第一种是基于堆内存空间规整的分配方式，这个条件下，堆内存的分配方式为“指针碰撞”；</p><p>第二种是堆内存空间不规整的情况下划分，这种情况没有办法进行简单的指针碰撞，需要通过一个列表来记录，哪些内存是可用的，找到一块足够大，能装的下对象内存的区域后，再划分给对象，这种分配方式叫“空闲列表”；</p></blockquote><h3 id="方法区（没想好怎么写）"><a href="#方法区（没想好怎么写）" class="headerlink" title="方法区（没想好怎么写）"></a>方法区（没想好怎么写）</h3><blockquote><p>方法区与堆 一样，是各个线程共享的内存区域，用于储存已经被虚拟机加载的类型信息、常量、静态变量、即时编译器后的代码缓存等数据；它有个有意思的别名，叫做 <strong>非堆</strong>。</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20171115215708642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ2JpYW8wMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之九阳神功秘籍</title>
      <link href="/2020/07/11/duo-xian-cheng-zhi-lu/"/>
      <url>/2020/07/11/duo-xian-cheng-zhi-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程之旅"><a href="#多线程之旅" class="headerlink" title="多线程之旅"></a>多线程之旅</h1><hr><h2 id="什么是多线程？"><a href="#什么是多线程？" class="headerlink" title="什么是多线程？"></a>什么是多线程？</h2><p>我们先来看看，什么是线程：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710152151.png" alt="进程与线程"></p><p><strong>问题1：不运行的程序，是什么？</strong></p><blockquote><p>程序可以理解成一个静态的指令集合，当系统运行程序时， 程序中的指令就被激活了，转变成进程开始执行任务。</p></blockquote><p><strong>问题2：进程之间会相互影响吗？</strong></p><blockquote><ol><li>进程是系统中独立存在的实体，每一个进程都拥有自己私有的地址空间。在没有经过进程本身的允许的情况下，一个用户进程是不可以直接访问其他进程的地址空间的；</li><li>多个进程可以在单个处理器上并发执行，并且多进程之间不会互相影响。</li></ol></blockquote><p><strong>问题3：线程之间会互相影响吗？</strong></p><blockquote><p>线程可以理解成进程的执行单元，一个线程必须有一个父进程，当进程被初始化，主线程就创建了，它们共享着父进程的内存资源。线程可以拥有自己的堆栈，自己的程序计数器和自己的局部变量，但不拥有系统资源；他们可以通过调用父线程的资源来相互影响，但是要做到不要相互妨碍；</p></blockquote><blockquote><p>总结起来就是一句话，一个程序的运行，至少依托着一个进程的支持，一个进程的运行，至少需要一个线程；</p></blockquote><p><strong>多线程的优势(相较于多进程)</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. 进程之间不能共享内存，线程之间能轻易实现内存的共享；</span><br><span class="line"></span><br><span class="line">2. 系统创建进程需要为该进程重新分配系统资源，而创建线程的代价相比之下就小得多，因此使用多线程来实现任务并发就比多进程的效率高；</span><br><span class="line"></span><br><span class="line">3. Java语言内置了多线程功能的支持，而不是单纯地作为底层操作系统的调度方式，从而简化了Java的多线程编程。</span><br></pre></td></tr></tbody></table></figure><h2 id="线程的创建与启动"><a href="#线程的创建与启动" class="headerlink" title="线程的创建与启动"></a>线程的创建与启动</h2><blockquote><p>三种方法：1. 继承Thread类创建；2. 实现Runnable接口创建；3. 使用Callable和Future创建</p></blockquote><h3 id="第一种继承创建"><a href="#第一种继承创建" class="headerlink" title="第一种继承创建"></a>第一种继承创建</h3><p>见如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"多线程不好玩"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"多线程真好玩"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>运行结果中能看到交替运行:<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710162128.png" alt="运行结果"></p></blockquote><blockquote><p>当然，这么写有点麻烦，因为Mythread子类只用了一次，可以创建匿名内部类的形式简化上述代码:</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++){</span><br><span class="line">                    System.out.println(<span class="string">"多线程好玩:"</span>+i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++){</span><br><span class="line">            System.out.println(<span class="string">"多线程真好玩:"</span>+i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第二种Runnable接口创建（最常用）"><a href="#第二种Runnable接口创建（最常用）" class="headerlink" title="第二种Runnable接口创建（最常用）"></a>第二种Runnable接口创建（最常用）</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"多线程真好玩"</span>);</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"多线程不好玩"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>由于这个Runnable 接口只有run这一个方法需要实现，所以可以利用<strong>Lambda</strong>表达式来进一步简化：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"多线程真好玩"</span>+i);</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"多线程不好玩"</span>+i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第三种Callalbe创建（带有返回值的接口线程创建）"><a href="#第三种Callalbe创建（带有返回值的接口线程创建）" class="headerlink" title="第三种Callalbe创建（带有返回值的接口线程创建）"></a>第三种Callalbe创建（带有返回值的接口线程创建）</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        Callable&lt;Integer&gt; c = <span class="keyword">new</span> MyCallable&lt;&gt;();</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(c);</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        System.out.println(<span class="string">"子线程的返回值为："</span>+task.get());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">            System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span>&lt;<span class="title">Interger</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：如果子线程与主线程之间存在 task.get() 获取子线程的返回值，主线程会等待返回值得到，也就是子线程执行完，再开始执行主线程；<br>如果想停止子线程的运行，通过task.cancel()来停止</p></blockquote><h3 id="三种创建方法的比较"><a href="#三种创建方法的比较" class="headerlink" title="三种创建方法的比较"></a>三种创建方法的比较</h3><blockquote><p>Thread继承与Runnable创建比较<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710172644.png" alt="比较"><br>Runnable 与 Callable 比较：<br>Runnable不带返回值，代码实现简单，对主线程影响较小;<br>而Callable带返回值，除了实现call方法外，还要用FutureTask 类来实现返回值的调用，并且调取get()方法会引起主线程阻塞；</p></blockquote><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><blockquote><p>按照老师的课程，线程的执行过程中，有一下6种状态：New(新建状态)，Runnable(运行状态)，Blocker(阻塞状态)，Waiting/TimedWaiting(有限等待、无限等待状态)，Teminated(终止状态)</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710174520.png" alt="线程的6种状态"></p><blockquote><p>查阅了相关书籍后，我觉得按照这个图来形容来划分比较合理：</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200711095406.png" alt=""></p><blockquote><p>为什么start()后要划分成就绪跟运行状态？<br>由于线程启动后，不会一直“霸占”着CPU来执行，CPU会在多线程之间来回切换，所以线程也会在运行，就绪之间往复交替；</p></blockquote><h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><blockquote><p><strong>设置守护线程：</strong><br>(线程的引用)t.setDaemon(true)<br>守护线程的概念，守护线程也可以叫后台线程，其特征为：当所有的前台线程死亡后，后台线程自动结束，（）内输入 true 为设置成守护线程，不输入或者输入false,为不设置；<br>JVM 的垃圾回收就是典型的后台线程;</p></blockquote><blockquote><p><strong>让线程按下暂停键</strong><br>Thread.sleep()<br>在代码中插入<code>Thread.sleep()</code>后会使程序暂停一段时间，并进入阻塞状态；相比较而言，yield()方法，这个方法只会让线程重新调度一下，并不会暂停；</p></blockquote><blockquote><p><strong>改变程序的优先级</strong><br>Thread.currenttThread().setPriority(5)<br>赋予线程优先级，优先级高的更容易被执行；<br>括号内的数值范围是（1-10）,分别对应10种优先级，也可以调用三个静态常量MAX_PRIORITY/NORM_PRIORITY/MIN_PRIORITY（10/5/1）；</p></blockquote><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>想象这样一个画面：<br>A , B 同时去银行取钱，然后银行余额都显示1000元，A取500，B取1000，如果 A B两人扣款时间也一样，那银行余额是不是就变成了-500；</p><p>这样就是线程同步而引发出来的线程不安全行为；</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710211748.png" alt=""></p><p>如何去解决线程不安全：</p><blockquote><p><strong>方法1 ：同步代码块</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//代码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>{<span class="comment">//线程安全性解读一</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">        <span class="comment">//总票数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span> ;</span><br><span class="line">        <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">synchronized</span> (o) {<span class="comment">//在执行方法前插入同步代码块sychronized</span></span><br><span class="line">                    <span class="keyword">if</span>(count&gt;<span class="number">0</span>) {</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"准备卖票，总票数为："</span> + count);</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                        count--;</span><br><span class="line">                        System.out.println(<span class="string">"卖票成功，余票为："</span> + count);</span><br><span class="line">                    }<span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>理解如下：</p><p>当Thread-0/Thread-1/Thread-2 到达if 循环前，最先到达的那个线程会被套上 sychronized 给的标记 o，当标记 o 激活时，假定最先到达的是Thread-0，Thread-1/Thread-2 会在原地等待，等待标记消失后再向下执行，而当Thread-0执行完成if中的语句后，标记会被清除，Thread-0会随着循环再一次来到if前，而标记清除后，Thread-1/Thread-2 接收到标记消失命令，再开始往下执行；这个时候谁会执行是不一定的，取决于谁能争抢到时间片；</p></blockquote><blockquote><p><strong>方法2 ：同步方法</strong></p><p>将if后面的代码打包成一个方法，然后用synchronized进行修饰（准确说是进行装饰），代码如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>{<span class="comment">//线程安全性解读</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">        <span class="comment">//总票数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span> ;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">this</span>.sale();</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>{<span class="comment">//用synchronized修饰sale()方法，依然放在if前</span></span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"准备卖票，总票数为："</span> + count);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(<span class="string">"卖票成功，余票为："</span> + count);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p><strong>方法3 ：添加显示锁</strong></p><p>上述的两种方式相当于是隐式锁的概念，从Java 5 开始，Java官方添加了一种更强大的线程同步机制——同步锁，由Lock对象充当；</p><p>同步锁一般比较常用的是Lock对象的实现类ReentrantLock（可重入锁），代码如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>{<span class="comment">//线程安全性解读</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">           Runnable r = <span class="keyword">new</span> Ticket();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">           <span class="comment">//总票数</span></span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span> ;</span><br><span class="line">           <span class="keyword">private</span> Lock l = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">               <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                   l.lock();</span><br><span class="line">                   <span class="keyword">try</span> {</span><br><span class="line">                       <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                           System.out.println(Thread.currentThread().getName() + <span class="string">"准备卖票，总票数为："</span> + count);</span><br><span class="line">                           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                           count--;</span><br><span class="line">                           System.out.println(<span class="string">"卖票成功，余票为："</span> + count);</span><br><span class="line">                       } <span class="keyword">else</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                   }<span class="keyword">catch</span>(InterruptedException e){</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   }<span class="keyword">finally</span>{</span><br><span class="line">                       l.unlock();</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p>ReentrantLock() 括号内可传入boolean 参数，传入true后，锁就变成了公平锁，会让线程排队执行，以上述为例，会依次Thread -0（假设0线程第一个执行）、Thread-1(假设第二个执行)、Thread-2(第三个执行)，会依次 0/1/2、0/1/2的顺序（当然也可以102,201的顺序，取决于谁先抢到时间片，但第一次循环后，顺序就固定下来了）执行，直至线程结束； </p></blockquote><blockquote><p><strong>死锁</strong></p></blockquote><p>在线程同步中，添加同步监视器过多，可能会导致死锁的现象；</p><p>可以这样来理解：在A 运行的代码中加入B的锁，等待B解锁后才能向下执行；又在B运行的代码中加入A 的锁，等待 A 解锁后才向下执行，假如 A 等待 B 的时候，B又在等待 A ，这样死锁就产生了；</p><p>一旦死锁产生，整个程序不会出错，也没有任何提示，整个处于阻塞的状态，无法继续。</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><blockquote><p><strong>生产者和消费者问题：</strong></p></blockquote><p>A 是生产者，负责生产食物和数量，B 是消费者，负责接收食物和数量，想象一个场景，假如 A 生产两种食物，循环递给B，B负责消费，消费完成后 ，通知A 进行生产 ，依次按顺序循环100次，怎样进行如上的代码实现呢；</p><p>方法一：</p><p>Object 类有三个有助于线程通信的方法，wait() 使当前线程等待，notify() 随机唤醒一个线程，notifyAll()，唤醒所有线程；</p><p>利用这三个方法，再加上标签flag = ture /false ，可以很好的实现如上代码需求；具体代码就不展示了，有点占篇幅；</p><p>方法二：</p><p>使用BlockingQueue（阻塞队列）</p><p>put() 把元素放入队列，如果队列已满，则阻塞该线程</p><p>take() 从队列头取走元素，如果队列已空，则阻塞线程；</p><p>这个不是太会；后面再研究</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote><p><strong>为什么需要线程池？</strong></p></blockquote><ol><li>系统创建一个新线程的耗费是很大的，而运行一个线程耗费要小很多，运用线程池的概念，可以很好的提升系统性能；</li><li>线程池可以很好的控制系统中并发线程的数量，即在创建初直接指定并发执行的线程数；</li><li>线程池能提供定时执行、定期执行、单线程、并发数控制等功能</li></ol><blockquote><p><strong>四种线程池的创建</strong></p></blockquote><p>第一种，缓存线程池：</p><p><code>newCachedThreadPool()</code>，创建一个具有缓存功能的线程池，可灵活回收空闲线程；</p><p>第二种，定长线程池：</p><p><code>newFixedThreadPool(初始线程数)</code>，初始线程数一旦被固定，就只能使固定数量的线程并发运行；</p><p>第三种，单线程线程池</p><p><code>newSingleThreadExecutor()</code> ，创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务</p><p>第四种，周期执行线程池</p><p><code>newScheduledThreadPool()</code>，创建一个定长线程池，支持定时及周期性任务执</p><h2 id="多线程面试题"><a href="#多线程面试题" class="headerlink" title="多线程面试题"></a>多线程面试题</h2><p>参考链接：<a href="https://blog.csdn.net/cmyperson/article/details/79610870" target="_blank" rel="noopener">50个多线程面试题汇总</a></p><p><strong>什么是线程？</strong></p><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。</p><p>比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒</p><p><strong>什么是线程安全和线程不安全？</strong></p><p>线程安全: 就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染</p><p>线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p><p><strong>什么是自旋锁？</strong></p><p>当线程A想要获取一把自旋锁而该锁又被其它线程锁持有时，线程A会在一个循环中自旋以检测锁是不是已经可用了</p><p><strong>什么是乐观锁和悲观锁？</strong></p><p>悲观锁</p><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。</p><p>乐观锁</p><p>乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做</p><p>==============================</p><p>还有很多题目，详见参考链接，就不一一赘述了；</p><p>全剧终</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Finally之未解之谜</title>
      <link href="/2020/07/08/finally-guan-jian-zi-zhi-mian-shi-xiang-guan-hui-zong/"/>
      <url>/2020/07/08/finally-guan-jian-zi-zhi-mian-shi-xiang-guan-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="Finally-关键字"><a href="#Finally-关键字" class="headerlink" title="Finally 关键字"></a>Finally 关键字</h1><hr><h2 id="Finally-是什么？"><a href="#Finally-是什么？" class="headerlink" title="Finally 是什么？"></a>Finally 是什么？</h2><p>有一些代码，可能会希望try块中的异常无论是否抛出，都需要执行某一些语句，这个时候，我们就用到了finally;</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">try块语法：</span><br><span class="line">try{</span><br><span class="line"></span><br><span class="line">}catch(异常类 形参){</span><br><span class="line"></span><br><span class="line">}finally{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">try块 catch和finally可任选一个，一般两个都写，不可以两个都不写；</span><br></pre></td></tr></tbody></table></figure><h2 id="Finally常见问题"><a href="#Finally常见问题" class="headerlink" title="Finally常见问题"></a>Finally常见问题</h2><h3 id="1-try语句中有异常，finally-语句块会执行吗？"><a href="#1-try语句中有异常，finally-语句块会执行吗？" class="headerlink" title="1. try语句中有异常，finally 语句块会执行吗？"></a>1. try语句中有异常，finally 语句块会执行吗？</h3><p>这个答案是肯定的。finally语句的优先级等级很高，只要不涉及一些关键字眼，如<strong>JVM异常关闭</strong>,<strong>系统异常崩溃</strong>等，finally中的语句总是会执行的，不管是否有异常抛出。</p><h3 id="2-finally-与-continue-break之间的关系"><a href="#2-finally-与-continue-break之间的关系" class="headerlink" title="2. finally 与 continue,break之间的关系"></a>2. finally 与 continue,break之间的关系</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">continue</span>与<span class="keyword">break</span> 代表着跳出本次循环、结束本次循环，<span class="keyword">finally</span>遇上这两个代码会怎么样呢？</span><br><span class="line"></span><br><span class="line">请看以下代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) {</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//continue也一样</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }<span class="keyword">catch</span>(Exception e) {</span><br><span class="line">        System.out.println(<span class="string">"有异常，请检查"</span>);</span><br><span class="line">    }<span class="keyword">finally</span> {</span><br><span class="line">        System.out.println(<span class="string">"一定会执行"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">一定会执行</span><br><span class="line"></span><br><span class="line">可以看到即使跳出了循环，<span class="keyword">finally</span>语句中的内容依然会执行</span><br></pre></td></tr></tbody></table></figure><h3 id="3-finally与return的关系"><a href="#3-finally与return的关系" class="headerlink" title="3. finally与return的关系"></a>3. finally与return的关系</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>的执行逻辑：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>. 复制一份<span class="keyword">return</span>后的表达式至操作数栈顶，计算表达式的值，将表达式的值保存至操作数栈顶</span><br><span class="line">    <span class="number">2</span>. 检查后续代码有无<span class="keyword">finally</span></span><br><span class="line">    <span class="number">3</span>. 若有，则优先执行<span class="keyword">finally</span>内的代码，再返回操作数栈顶的值</span><br><span class="line">    <span class="number">4</span>. 若没有，则直接返回操作数栈顶的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">观察下面代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"></span><br><span class="line">    System.out.println(say());</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            a = <span class="number">20</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">想一想输出的值是什么？</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2328241580,270776270&amp;fm=26&amp;gp=0.jpg" alt="思考"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">答案为：10</span><br><span class="line"></span><br><span class="line">通过上面的4步，很容易判断，操作数栈顶的保存的值为10，虽然后面通过finally中的语句使a的值变为了20，但return返回的值仍是10；</span><br></pre></td></tr></tbody></table></figure><p>看看网上的一个面试题：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/26/BQDrToY9O5mX8q4.png" alt="mianshi.png"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">想一想答案是什么？</span><br><span class="line"></span><br><span class="line">下面我们通过画图来演示一下</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/26/BXoIRxgl6yrwpKE.png" alt="tupian"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">所以第一行打印Test1()的时候，先打印try语句中的'A',然后将'A'保存至操作数栈，后面打印finally语句中的'B',将Label的值变为'B',Test1()的返回值为'A',Label的值为'B';</span><br><span class="line"></span><br><span class="line">输出的值为： A***;</span><br></pre></td></tr></tbody></table></figure><p><strong>升华一下</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">我们来变一下，倘若在<span class="keyword">finally</span>后面加上<span class="keyword">return</span>语句，结果会不会不一样呢？</span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Label;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">System.out.println(say());</span><br><span class="line">System.out.println(Label);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">System.out.println(<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">return</span> Label = <span class="string">'A'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">finally</span> {</span><br><span class="line">System.out.println(<span class="string">'B'</span>);</span><br><span class="line"><span class="keyword">return</span> Label = <span class="string">'B'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">这下返回的结果会是什么样呢？</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://tse3-mm.cn.bing.net/th/id/OIP.hoS8C8Tvn6ahI_XKFt2NwwHaHV?pid=Api&amp;rs=1" alt="a"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">对没错,输出的就是A***</span><br><span class="line"></span><br><span class="line">解释如下：</span><br><span class="line"></span><br><span class="line">第一个return,是将'A'储存进了操作数栈顶，然后在执行finally语句的时候，又一次的将'B'保存在了操作数栈顶，所以最终返回值跟Label的值都为'B';</span><br></pre></td></tr></tbody></table></figure><p><strong>再升华一下</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">大家是不是对于<span class="keyword">finally</span>与<span class="keyword">return</span>的关系掌握得更具体了呢，再升华一点，如果在<span class="keyword">try</span> 块后面加上<span class="keyword">return</span> <span class="string">'A'</span>;<span class="keyword">try</span> 块内添加<span class="keyword">catch</span>(Expection e)语句，结果会怎么样？</span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Label;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">System.out.println(say());</span><br><span class="line">System.out.println(Label);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">System.out.println(<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">return</span> Label = <span class="string">'A'</span>;</span><br><span class="line">}<span class="keyword">catch</span>(Exception e) {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">finally</span> {</span><br><span class="line">System.out.println(<span class="string">'B'</span>);</span><br><span class="line">Label = <span class="string">'B'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">想一想结果会怎样？</span><br><span class="line"></span><br><span class="line">大脑一片空白··········</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">emmm  问师傅 我也不知道！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此处省略一万字。。。。</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/26/VtdEGlsar4be2WU.jpg" alt="aa.jpeg"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/sinat_22594643/article/details/80509266" target="_blank" rel="noopener">https://blog.csdn.net/sinat_22594643/article/details/80509266</a><br><a href="https://blog.csdn.net/WYpersist/article/details/80710352" target="_blank" rel="noopener">https://blog.csdn.net/WYpersist/article/details/80710352</a><br><a href="https://www.jianshu.com/p/144a4496575a" target="_blank" rel="noopener">https://www.jianshu.com/p/144a4496575a</a></p><p>仅仅代表一些很基础的个人观点，希望大家能积极指出不足，我一定好好修改的，希望我能跟小伙伴们一起进步！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> finally </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap之深入浅出</title>
      <link href="/2020/07/08/hashmap-xiang-jie/"/>
      <url>/2020/07/08/hashmap-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-详解"><a href="#HashMap-详解" class="headerlink" title="HashMap 详解"></a>HashMap 详解</h1><p>大叫好，争取明天能开个头</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown使用</title>
      <link href="/2020/06/30/wo-de-di-yi-pian-bo-ke-bi-ji/"/>
      <url>/2020/06/30/wo-de-di-yi-pian-bo-ke-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown的使用方法（小白篇）"><a href="#Markdown的使用方法（小白篇）" class="headerlink" title="Markdown的使用方法（小白篇）"></a>Markdown的使用方法（小白篇）</h1><p><embed src="//music.163.com/style/swf/widget.swf?sid=458217431&amp;type=2&amp;auto=0&amp;width=320&amp;height=66" width="340" height="86" allownetworking="all"></p><hr><h2 id="标题类"><a href="#标题类" class="headerlink" title="标题类"></a>标题类</h2><p>#+空格+一级标题 = 一级标题</p><p>##+空格+二级标题 = 二级标题</p><p>###+空格+三级标题 = 三级标题</p><p>####+空格+四级标题 = 四级标题</p><p>……</p><p>共六级标题</p><p>类似这个样式</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/18/PKVDBh2cosW3N9g.png" alt="title"></p><h2 id="区块与引用"><a href="#区块与引用" class="headerlink" title="区块与引用"></a>区块与引用</h2><p><strong>无序区块</strong></p><p>文字前加上 - 或 * 即可变为无序区块，例：</p><ul><li>1</li><li>2</li><li>3</li></ul><p><strong>有序区块</strong></p><p>文字前加上 1.即可变为有序列表，例：</p><ol><li>1</li><li>2</li><li>3</li></ol><p><strong>引用</strong></p><p>在文本前加上 &gt; 即可实现引用功能</p><blockquote><p>例如：Rome was’t built in a day</p></blockquote><p><strong>多层引用</strong></p><p>一个 &gt; 是最外层，两个 &gt;&gt; 是次外层，三个 &gt;&gt;&gt; 是次次外层</p><blockquote><p>最外层</p><blockquote><p>次外层</p><blockquote><p>次次外层</p></blockquote></blockquote></blockquote><p><strong>在区块内引用</strong></p><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p><p>举个例子：</p><ul><li><p>第一项</p><blockquote><p>菜鸟教程</p></blockquote><ol><li><p>如何从菜鸟成功变成一个老鸟…..</p><blockquote><p>学的不仅是技术更是梦想</p></blockquote></li></ol></li><li><p>第二项</p></li></ul><h2 id="插入超链接与代码块"><a href="#插入超链接与代码块" class="headerlink" title="插入超链接与代码块"></a>插入超链接与代码块</h2><p><strong>图片格式</strong></p><p>!”[]”(“图片链接”)”</p><p>例如：</p><p><img src= "/img/loading.gif" data-src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2493015871,2263103202&amp;fm=26&amp;gp=0.jpg" alt="你的名字"></p><p>安利一个网址，可以自动将本地照片输出成各种格式：</p><p><a href="https://sm.ms/" target="_blank" rel="noopener">本地png图片转超链接点我</a></p><p><strong>链接格式</strong></p><p>“[输入网站介绍]”(“超链接”)”</p><p>备注：！ 与 （）都要是英文格式的哦!</p><p><strong>插入代码块</strong></p><ol><li>代码函数插入：利用``将其选中即可<br>举例<code>System.out.println()</code></li><li>代码区块用三个<code>```</code>包裹即可<br>举例:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int a =10;</span><br><span class="line">int b =20;</span><br><span class="line">System.out.println(a+b);//30</span><br></pre></td></tr></tbody></table></figure><h2 id="强调字体与表格"><a href="#强调字体与表格" class="headerlink" title="强调字体与表格"></a>强调字体与表格</h2></li></ol><p><strong>强调字体</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">强调字体可以有如下形式：</span><br><span class="line"></span><br><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">~~删除线~~</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></tbody></table></figure><p><strong>表格</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">语法如下:</span><br><span class="line"></span><br><span class="line">|  表头  | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></tbody></table></figure><p>输出样式：</p><p><img src= "/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg" alt=""></p><p><strong>表格对齐方式</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">语法如下:</span><br><span class="line"></span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></tbody></table></figure><p>输出样式：</p><p><img src= "/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg" alt=""></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/weilf/p/4567334.html" target="_blank" rel="noopener">https://www.cnblogs.com/weilf/p/4567334.html</a><br><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/markdown/md-tutorial.html</a></p><hr><p>如果可以的话。建议使用Typora这款软件进行.md文件的编写，比较方便，附下载链接：<br><a href="https://www.typora.io/#windows" target="_blank" rel="noopener">Typora下载</a></p><p>如果想体验操作的快感还是使用Markdown编辑器编辑吧！</p><p>不喜勿喷。记得三连</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
