<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于啥呢</title>
      <link href="/posts/55578.html"/>
      <url>/posts/55578.html</url>
      
        <content type="html"><![CDATA[<h1 id="回归第一篇推荐什么好呢？"><a href="#回归第一篇推荐什么好呢？" class="headerlink" title="回归第一篇推荐什么好呢？"></a>回归第一篇推荐什么好呢？</h1><p>  话说天下大事，合久必分，分久必合</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
            <tag> 个人 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot相关总结</title>
      <link href="/posts/37805.html"/>
      <url>/posts/37805.html</url>
      
        <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p>Spring Boot 是spring快速开发脚手架，通过约定大于配置的方式，快速构建和启动spring项目</p><p><strong>约定大于配置</strong>：SpringBoot 会自动配置好约定好的内容</p><h3 id="为什么要学SpringBoot"><a href="#为什么要学SpringBoot" class="headerlink" title="为什么要学SpringBoot"></a>为什么要学SpringBoot</h3><ul><li><p>Spring 中需要配置各种文件，会占用开发的宝贵时间</p></li><li><p>混乱的依赖管理</p></li></ul><p>项目的依赖管理非常的繁琐。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有<strong>冲突</strong>，这是一个棘手的问题。并且，一旦选错了依赖的版本，随之而来的就是各种的不兼容的bug。</p><p>spring boot 可以很好地解决上面2个问题</p><h2 id="Spring-特点"><a href="#Spring-特点" class="headerlink" title="Spring 特点"></a>Spring 特点</h2><p>Spring Boot 特点：</p><ul><li>快速开发spring应用的框架</li><li>内嵌tomcat和jetty容器，不需要单独安装容器，jar包直接发布一个web应用</li><li>简化maven配置，parent这种方式，一站式引入需要的各种依赖</li><li>基于注解的零配置思想</li><li>和各种流行框架，spring web mvc，mybatis，spring cloud无缝整合</li></ul><h2 id="SpringBoot入门"><a href="#SpringBoot入门" class="headerlink" title="SpringBoot入门"></a>SpringBoot入门</h2><p>需求：在SpringBoot中打印 hello SpringBoot</p><h3 id="1-配置pom-文件"><a href="#1-配置pom-文件" class="headerlink" title="1. 配置pom 文件"></a>1. 配置pom 文件</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--添加父工程坐标--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置web启动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>配置父工程坐标后即确定了SpringBoot 的版本号，后面所有的依赖包都不需要配置版本号，由SpringBoot自动配置</p><h3 id="2-创建启动入口"><a href="#2-创建启动入口" class="headerlink" title="2.创建启动入口"></a>2.创建启动入口</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 注解是固定的，类名可自定义，一般使用Application,调用SpringApplication的run方法即可启动Springboot项目</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        SpringApplication.run(Application<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="3-写一个Controller"><a href="#3-写一个Controller" class="headerlink" title="3.写一个Controller"></a>3.写一个Controller</h3><p>注意这个类要在SpringBoot启动入口所在的包内</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HelloController {</span><br><span class="line"></span><br><span class="line">    @GetMapping("/hello")</span><br><span class="line">    public String hello(){</span><br><span class="line">        return "hello SpringBoot";</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="4-启动入口"><a href="#4-启动入口" class="headerlink" title="4.启动入口"></a>4.启动入口</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200919191218468.png" alt="image-20200919191218468"></p><p>注意点：要将application 入口设置在com.kaikeba 的包下，不能是com.kaikeba.application下，设置为后者只能对应application文件夹内的映射；</p><h2 id="全注解配置及属性注入"><a href="#全注解配置及属性注入" class="headerlink" title="全注解配置及属性注入"></a>全注解配置及属性注入</h2><p>没学习SpringBoot 之前配置db.properties 文件是这么配置的</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${jdbc.url}"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${jdbc.username}"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${jdbc.password}"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>学习了SpringBoot后我们可以各种花式配置，具体后面会全部展开说明：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>{</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"${jdbc.url}"</span>)</span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"${jdbc.driverClassName}"</span>)</span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"${jdbc.username}"</span>)</span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"${jdbc.password}"</span>)</span><br><span class="line">    String password;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>{</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="Spring注解使用发展史"><a href="#Spring注解使用发展史" class="headerlink" title="Spring注解使用发展史"></a>Spring注解使用发展史</h3><ul><li><p>Spring1.0时代</p><p>基本使用xml 文件配置，所有的Bean，Service，Controller，以及配置文件，啥啥都往里面塞</p></li><li><p>Spring2.0时代</p><p>出现了注解配置，完善度不是很高，一半一半吧</p></li><li><p>Spring3.0及以后<br>3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，但是在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅</p></li></ul><h3 id="spring全注解配置"><a href="#spring全注解配置" class="headerlink" title="spring全注解配置"></a>spring全注解配置</h3><p>spring全注解配置主要靠java类和一些注解，比较常用的注解有：</p><ul><li>@Configuration ：声明一个类作为配置类，代替xml文件</li><li>@Bean ：声明在方法上，将方法的返回值加入Bean容器，代替 <code>&lt;bean&gt;</code> 标签</li><li>@value ：属性注入</li><li>@PropertySource ：指定外部属性文件</li></ul><p>来实现以下：</p><ol><li>导入Druid连接池依赖</li></ol><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ol start="2"><li>创建一个jdbc.properties文件（后面会改名字）</li></ol><figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">960315</span></span><br><span class="line"><span class="meta">jdbc.driverClassName</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br></pre></td></tr></tbody></table></figure><ol start="3"><li>注解形式书写Java代码</li></ol><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>{</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"${jdbc.url}"</span>)</span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"${jdbc.driverClassName}"</span>)</span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"${jdbc.username}"</span>)</span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"${jdbc.password}"</span>)</span><br><span class="line">    String password;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>{</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="SpringBoot-注解配置"><a href="#SpringBoot-注解配置" class="headerlink" title="SpringBoot 注解配置"></a>SpringBoot 注解配置</h3><h4 id="1-新建一个类"><a href="#1-新建一个类" class="headerlink" title="1. 新建一个类"></a>1. 新建一个类</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcProperties</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="comment">// getters 和 setters</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>在类上通过@ConfigurationProperties注解声明当前类为属性读取类</li><li>prefix=”jdbc” 读取属性文件中，前缀为jdbc的值。</li><li>在类上定义各个属性，名称必须与属性文件中 jdbc. 后面部分一致</li><li>需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名：</li></ul><h4 id="2-属性注入"><a href="#2-属性注入" class="headerlink" title="2. 属性注入"></a>2. 属性注入</h4><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(JdbcProperties<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">JdbcConfig</span> </span>{</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(JdbcProperties jdbc)</span> </span>{</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(jdbc.getUrl());</span><br><span class="line">        dataSource.setDriverClassName(jdbc.getDriverClassName());</span><br><span class="line">        dataSource.setUsername(jdbc.getUsername());</span><br><span class="line">        dataSource.setPassword(jdbc.getPassword());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>通过 @EnableConfigurationProperties(JdbcProperties.class) 来声明要使用 JdbcProperties 这个类的对象</p></li><li><p>也可以使用@Autowired注入</p><ul><li><pre><code>@Autowiredprivate JdbcProperties jdbc;<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 构造函数注入</span><br><span class="line"></span><br><span class="line">  * ```java</span><br><span class="line">    private JdbcProperties prop;</span><br><span class="line">    public JdbcConfig(Jdbcproperties prop){</span><br><span class="line">        this.prop = prop;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></code></pre></li></ul></li></ul><p>相对于上面第一种@Value直接对文件进行属性注入的方式相比，创建一个类是不是有点麻烦？其实官方更推荐这个方式，因为可以解决更多的问题，比如：</p><ul><li>Relaxed binding：松散绑定<ul><li>不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。</li><li>meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。</li></ul></li></ul><h3 id="更优雅的注入"><a href="#更优雅的注入" class="headerlink" title="更优雅的注入"></a>更优雅的注入</h3><p>事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>{</span><br><span class="line">    DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们直接把 @ConfigurationProperties(prefix = “jdbc”) 声明在需要使用的 @Bean 的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：<strong>该类必须有对应属性的set方法！</strong></p><h2 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h2><p>来看一看 SprIng Boot是如何自动配置的，这些都是从springboot启动器开始的：</p><h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><p>看一下@SpringBootApplication 的源码</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200921131140320.png" alt="image-20200921131140320"></p><p>这里重点的注解有3个：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200921131247651.png" alt="image-20200921131247651"></p><p>我们可以看到有一个@Configuration 注解。这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了 @Configuration 的类，并且读取其中的配置信息</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200921133346710.png" alt="image-20200921133346710"></p><p>定义了扫描包的范围，如果没有定义，则默认扫描启动器所在的包和子包；</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>官网有一段说明翻译如下：</p><p>The second class-level annotation is @EnableAutoConfiguration . This annotation tells Spring Boot to“guess” how you want to configure Spring, based on the jar dependencies that you have added. Sincespring-boot-starter-web added Tomcat and Spring MVC, the auto-configuration assumes that you aredeveloping a web application and sets up Spring accordingly.</p><p>第二级的注解 @EnableAutoConfiguration ，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了 spring-boot-starter-web ，而这个启动器中帮我们添加了 tomcat 、 SpringMVC 的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！</p><p>即，该注解的作用是根据你配置的pom信息，自动进行默认配置</p><h3 id="自动默认配置原理"><a href="#自动默认配置原理" class="headerlink" title="自动默认配置原理"></a>自动默认配置原理</h3><p>@EnableAutoConfiguration是根据这个依赖<code>spring-boot-autoconfigure</code>来进行自动配置的；</p><p>该依赖几乎包含了市面上所有主流的开源框架；拿web来举例</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200921134240445.png" alt="image-20200921134240445"></p><p>WebMvcAutoConfiguration 这个类会自动判断采取默认配置还是手动配置；</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200921135945918.png" alt="image-20200921135945918"></p><p>如果采用默认配置，在该类下面有个静态内部类WebMvcAutoConfigurationAdapter 会自动生成相应的映射器、适配器、视图解析器等等…..InternalResourceViewResolver，BeanNameViewResolver、SimpleUrlHandlerMapping</p><p>如果有定义@ConditionalOnMissingBean 这个注解则会使用自定义配置；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM 小练习</title>
      <link href="/posts/61188.html"/>
      <url>/posts/61188.html</url>
      
        <content type="html"><![CDATA[<h1 id="SSM之练习项目1"><a href="#SSM之练习项目1" class="headerlink" title="SSM之练习项目1"></a>SSM之练习项目1</h1><h2 id="1-建表"><a href="#1-建表" class="headerlink" title="1. 建表"></a>1. 建表</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">创建两个表</span><br><span class="line">create table bills(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">title varchar(50) not null,</span><br><span class="line">bill_time date not null,</span><br><span class="line">type_id int not null,</span><br><span class="line">price double not null,</span><br><span class="line">`explain` varchar(50)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create table billtype(</span><br><span class="line">id int primary key auto_increment,</span><br><span class="line">`name` varchar(50) not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">插入一些字段 这里略过 ....</span><br></pre></td></tr></tbody></table></figure><h2 id="2-配置各种配置文件"><a href="#2-配置各种配置文件" class="headerlink" title="2.配置各种配置文件"></a>2.配置各种配置文件</h2><h3 id="配置pom-文件"><a href="#配置pom-文件" class="headerlink" title="配置pom 文件"></a>配置pom 文件</h3><p>备注一下， <strong>按需配置</strong> ，不要什么什么依赖全往里面加，Maven 依赖管理是很智能的</p><p>有些没有使用的就没有配置了  比如分页，文件上传，后面要用自行补充</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 打包类型 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 测试相关 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- springmvc --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- servlet --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--文件上传--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--lombok--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- fastjson --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.73<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--Resource注解--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.annotation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.annotation-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- mybatis依赖 相关 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 提供了对JDBC操作的完整封装 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 织入 相关 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- spring，mybatis整合包 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 集成德鲁伊使用 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置日志文件--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--jstl 标签--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--导入分页插件，版本号要小于5.0，不知道为啥，别问我--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--配置Mybatis 反向生成--&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--反向生成插件--&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">               <span class="comment">&lt;!--指定generator配置文件路径--&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">configurationFile</span>&gt;</span>src/main/resources/generatorConfig.xml<span class="tag">&lt;/<span class="name">configurationFile</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line">                   <span class="tag">&lt;<span class="name">overwrite</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overwrite</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置web-xml-文件"><a href="#配置web-xml-文件" class="headerlink" title="配置web.xml 文件"></a>配置web.xml 文件</h3><p>这里说明一下，由于使用的强大的德鲁伊，可以添加一个德鲁伊监控平台 登录地址：localhost/druid/login.html （我的端口是80）</p><p>当然，前提是配置好 Druid 连接池的属性值</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>codeFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>codeFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Druid连接池 启用 Web 监控统计功能 start--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>DruidWebStatFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>com.alibaba.druid.support.http.WebStatFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>exclusions<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>DruidWebStatFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView <span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.alibaba.druid.support.http.StatViewServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 用户名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginUsername<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginPassword<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>960315<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/druid/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置logback-xml-日志文件"><a href="#配置logback-xml-日志文件" class="headerlink" title="配置logback.xml 日志文件"></a>配置logback.xml 日志文件</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">"true"</span> <span class="attr">scanPeriod</span>=<span class="string">"60 seconds"</span> <span class="attr">debug</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义参数常量 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志级别 TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- logger.trace("msg") logger.debug... --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.level"</span> <span class="attr">value</span>=<span class="string">"debug"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.maxHistory"</span> <span class="attr">value</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.filePath"</span> <span class="attr">value</span>=<span class="string">"D:/log"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"log.pattern"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">value</span>=<span class="string">"%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} -%msg%n"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 控制台输出设置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"consoleAppender"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- DEBUG级别文件记录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"debugAppender"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>${log.filePath}/debug.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 滚动日志文件类型，就是每天都会有一个日志文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 文件名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>${log.filePath}/debug/debug.%d{yyyy-MM-dd}.log.gz</span><br><span class="line">            <span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 文件最大保存历史数量 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>${log.maxHistory}<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>DEBUG<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- INFO --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"infoAppender"</span></span></span><br><span class="line"><span class="tag">              <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 文件路径 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>${log.filePath}/info.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 文件名称 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>${log.filePath}/info/info.%d{yyyy-MM-dd}.log.gz</span><br><span class="line">            <span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 文件最大保存历史数量 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>${log.maxHistory}<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>${log.pattern}<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- com.kaikeba开头的日志对应形式 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"com.kaikeba"</span> <span class="attr">level</span>=<span class="string">"${log.level}"</span> <span class="attr">additivity</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"debugAppender"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"infoAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;root&gt; 是必选节点，用来指定最基础的日志输出级别，只有一个level属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"info"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"consoleAppender"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 捕捉sql开头的日志 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"MyBatis"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.RollingFileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>${log.filePath}/sql_log/mybatis-sql.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.rolling.TimeBasedRollingPolicy"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">FileNamePattern</span>&gt;</span>${log.filePath}/sql_log/mybatis-sql.log.%d{yyyy-MM-dd}</span><br><span class="line">            <span class="tag">&lt;/<span class="name">FileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>30<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%thread|%d{yyyy-MM-dd HH:mm:ss.SSS}|%level|%logger{36}|%m%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"sql"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"MyBatis"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置-db-properties-文件"><a href="#配置-db-properties-文件" class="headerlink" title="配置 db.properties 文件"></a>配置 db.properties 文件</h3><figure class="highlight properties"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">960315</span></span><br><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line"></span><br><span class="line"><span class="attr">filters</span>=<span class="string">wall,stat</span></span><br><span class="line"><span class="attr">maxActive</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">maxWait</span>=<span class="string">5000</span></span><br><span class="line"><span class="attr">minIdle</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">maxIdle</span>=<span class="string">15</span></span><br><span class="line"><span class="attr">timeBetweenEvictionRunsMillis</span>=<span class="string">60000</span></span><br><span class="line"><span class="attr">minEvictableIdleTimeMillis</span>=<span class="string">300000</span></span><br><span class="line"><span class="attr">validationQuery</span>=<span class="string">SELECT 'x'</span></span><br><span class="line"><span class="attr">testWhileIdle</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">testOnBorrow</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">testOnReturn</span>=<span class="string">false</span></span><br><span class="line"><span class="attr">maxOpenPreparedStatements</span>=<span class="string">20</span></span><br><span class="line"><span class="attr">removeAbandoned</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">removeAbandonedTimeout</span>=<span class="string">1800</span></span><br><span class="line"><span class="attr">logAbandoned</span>=<span class="string">true</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置-Mybatis-Config文件"><a href="#配置-Mybatis-Config文件" class="headerlink" title="配置 Mybatis-Config文件"></a>配置 Mybatis-Config文件</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.kaikeba.bean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"com.github.pagehelper.PageHelper"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dialect"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置spring-xml-文件"><a href="#配置spring-xml-文件" class="headerlink" title="配置spring.xml 文件"></a>配置spring.xml 文件</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--1. 创建数据源--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--导入 db文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"database"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"${jdbc.driver}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${jdbc.url}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${jdbc.username}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${jdbc.password}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"filters"</span> <span class="attr">value</span> = <span class="string">"${filters}"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最大并发连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"maxActive"</span> <span class="attr">value</span> = <span class="string">"${maxActive}"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 初始化连接数量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"initialSize"</span> <span class="attr">value</span> = <span class="string">"${initialSize}"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"maxWait"</span> <span class="attr">value</span> = <span class="string">"${maxWait}"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 最小空闲连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"minIdle"</span> <span class="attr">value</span> = <span class="string">"${minIdle}"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"${timeBetweenEvictionRunsMillis}"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"${minEvictableIdleTimeMillis}"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- &lt;property name = "validationQuery" value = "${validationQuery}" /&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"testWhileIdle"</span> <span class="attr">value</span> = <span class="string">"${testWhileIdle}"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"testOnBorrow"</span> <span class="attr">value</span> = <span class="string">"${testOnBorrow}"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"testOnReturn"</span> <span class="attr">value</span> = <span class="string">"${testOnReturn}"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"maxOpenPreparedStatements"</span> <span class="attr">value</span> =<span class="string">"${maxOpenPreparedStatements}"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打开 removeAbandoned 功能 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"removeAbandoned"</span> <span class="attr">value</span> = <span class="string">"${removeAbandoned}"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1800 秒，也就是 30 分钟 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"removeAbandonedTimeout"</span> <span class="attr">value</span> =<span class="string">"${removeAbandonedTimeout}"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 关闭 abandon 连接时输出错误日志 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"logAbandoned"</span> <span class="attr">value</span> = <span class="string">"${logAbandoned}"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--2.创建 sqlSessionFactory--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"database"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--关联Mybatis--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath:mappers/*"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--3.创建Mapper扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactoryBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionFactory"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.kaikeba.dao"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--4.配置事务--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"database"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--5.启用springmvc注解 以及开启扫包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.kaikeba"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--6.配置视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--7.配置静态资源访问--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="配置-generatorConfig-xml-文件"><a href="#配置-generatorConfig-xml-文件" class="headerlink" title="配置 generatorConfig.xml 文件"></a>配置 generatorConfig.xml 文件</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">generatorConfiguration</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置生成器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库驱动jar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">classPathEntry</span></span></span><br><span class="line"><span class="tag">            <span class="attr">location</span>=<span class="string">"C:\Users\www92\lib\mysql-connector-java-8.0.11.jar"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"MyBatis"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--去除注释 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数据库连接 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/test?useSSL=false<span class="symbol">&amp;amp;</span>serverTimezone=UTC"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"960315"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--生成实体类 指定包名 以及生成的地址 （可以自定义地址，但是路径不存在不会自动创建</span></span><br><span class="line"><span class="comment">        使用Maven生成在target目录下，会自动创建） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"com.kaikeba.bean"</span></span></span><br><span class="line"><span class="tag">                            <span class="attr">targetProject</span>=<span class="string">"D:\MyProject\ssm-demo1\src\main\java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--生成SQLmapper文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mappers"</span></span></span><br><span class="line"><span class="tag">                         <span class="attr">targetProject</span>=<span class="string">"D:\MyProject\ssm-demo1\src\main\resources"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--生成Dao文件,生成接口 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetPackage</span>=<span class="string">"com.kaikeba.dao"</span></span></span><br><span class="line"><span class="tag">                             <span class="attr">targetProject</span>=<span class="string">"D:\MyProject\ssm-demo1\src\main\java"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"bills"</span> <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span> <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"billtype"</span> <span class="attr">enableCountByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableUpdateByExample</span>=<span class="string">"false"</span> <span class="attr">enableDeleteByExample</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">enableSelectByExample</span>=<span class="string">"false"</span> <span class="attr">selectByExampleQueryId</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>打开终端命令行输入 ： mvn mybatis-generator:generate -e  </p><p>看到build success 表示 mybatis 反向生成成功！</p><p>使用命令行比老师的方法方便太多了！！！！误点再次生成的话会重复添加mapper中的sql 语句</p><p>这里就关注一下generator的版本即可</p><p>接下来步入正轨！</p><h2 id="3-按需求配置各层的结构"><a href="#3-按需求配置各层的结构" class="headerlink" title="3. 按需求配置各层的结构"></a>3. 按需求配置各层的结构</h2><h3 id="dao-层"><a href="#dao-层" class="headerlink" title="dao 层"></a>dao 层</h3><p>dao 层是根据sql 语句一一对应编写的，没啥可说的</p><h3 id="Service-层"><a href="#Service-层" class="headerlink" title="Service 层"></a>Service 层</h3><p>直接调用 dao 层方法，也没啥可说的，这里注意下分页功能是在该层实现的，代码见采坑日志</p><h3 id="Contorller-层"><a href="#Contorller-层" class="headerlink" title="Contorller 层"></a>Contorller 层</h3><p>主要的处理层，负责接收数据，数据转换调用以及返回；</p><p>注意实现类 都必须要调用spring 注解来生成bean 否则无法自动注入及使用，代码还有很多待优化的点，比如 RestFul 风格，拦截器登录拦截等等</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.kaikeba.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.github.pagehelper.PageInfo;</span><br><span class="line"><span class="keyword">import</span> com.kaikeba.bean.Bills;</span><br><span class="line"><span class="keyword">import</span> com.kaikeba.bean.Billtype;</span><br><span class="line"><span class="keyword">import</span> com.kaikeba.service.BillService;</span><br><span class="line"><span class="keyword">import</span> com.kaikeba.service.BillTypeService;</span><br><span class="line"><span class="keyword">import</span> com.kaikeba.util.PageUtil;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.transaction.annotation.Transactional;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.ModelMap;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 黄杰</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020-09-17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BillsController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BillService billService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> BillTypeService typeService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getAllTypes"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAllTypes</span><span class="params">(ModelMap map)</span> </span>{</span><br><span class="line">        <span class="comment">// 查询所有账单类型</span></span><br><span class="line">        List&lt;Billtype&gt; types = typeService.getTypes();</span><br><span class="line">        map.addAttribute(<span class="string">"types"</span>, types);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"add"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/addBill"</span>)</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBill</span><span class="params">(Bills bills)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = billService.insert(bills);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:/getTypes"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/getAllTypes"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getBillById"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findBillById</span><span class="params">(Integer id, ModelMap map)</span> </span>{</span><br><span class="line">        Bills bill = billService.selectByPrimaryKey(id);</span><br><span class="line">        List&lt;Billtype&gt; types = typeService.getTypes();</span><br><span class="line">        map.addAttribute(<span class="string">"bill"</span>, bill);</span><br><span class="line">        map.addAttribute(<span class="string">"types"</span>, types);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"update"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/updateBill"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateBill</span><span class="params">(Bills bills)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = billService.updateByPrimaryKeySelective(bills);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:/getTypes"</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/getBillById?id="</span> + bills.getId();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/deleteById"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Integer id, HttpServletResponse response)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> i = billService.deleteByPrimaryKey(id);</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            PrintWriter writer = response.getWriter();</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) {</span><br><span class="line">                writer.print(<span class="string">"&lt;script&gt;alert(删除成功);location.href='/getTypes'&lt;/script&gt;"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            }</span><br><span class="line">            writer.print(<span class="string">"&lt;script&gt;alert(删除失败);location.href='/getTypes'&lt;/script&gt;"</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getTypes"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTypes</span><span class="params">(ModelMap map)</span> </span>{</span><br><span class="line">        <span class="comment">// 查询所有的类型</span></span><br><span class="line">        List&lt;Billtype&gt; types = typeService.getTypes();</span><br><span class="line">        <span class="comment">// 查询所有的账单</span></span><br><span class="line">        PageInfo&lt;Bills&gt; info = billService.getBills(-<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">1</span>, PageUtil.PAGE_NUM);</span><br><span class="line">        <span class="comment">// 保存数据</span></span><br><span class="line">        map.addAttribute(<span class="string">"types"</span>, types);</span><br><span class="line">        map.addAttribute(<span class="string">"info"</span>, info);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"show"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getAllBills"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAllBills</span><span class="params">(@RequestParam(defaultValue = <span class="string">"1"</span>)</span> <span class="keyword">int</span> index,</span></span><br><span class="line"><span class="function">         @<span class="title">RequestParam</span><span class="params">(defaultValue = <span class="string">"-1"</span>)</span> <span class="keyword">int</span> typeId, String begin, String end, ModelMap map) </span>{</span><br><span class="line">        <span class="comment">// 查询所有账单信息</span></span><br><span class="line">        PageInfo&lt;Bills&gt; info = billService.getBills(typeId, begin, end, index, PageUtil.PAGE_NUM);</span><br><span class="line">        map.addAttribute(<span class="string">"info"</span>, info);</span><br><span class="line">        <span class="comment">// 查询所有的类型</span></span><br><span class="line">        List&lt;Billtype&gt; types = typeService.getTypes();</span><br><span class="line">        <span class="comment">// 数据回显</span></span><br><span class="line">        map.addAttribute(<span class="string">"types"</span>, types);</span><br><span class="line">        map.addAttribute(<span class="string">"typeId"</span>, typeId);</span><br><span class="line">        map.addAttribute(<span class="string">"begin"</span>, begin);</span><br><span class="line">        map.addAttribute(<span class="string">"end"</span>, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"show"</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="踩坑日记："><a href="#踩坑日记：" class="headerlink" title="踩坑日记："></a>踩坑日记：</h2><h3 id="使用-分页插件的时候切记-版本的问题！！！"><a href="#使用-分页插件的时候切记-版本的问题！！！" class="headerlink" title="使用 分页插件的时候切记 版本的问题！！！"></a>使用 分页插件的时候切记 版本的问题！！！</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!--导入分页插件依赖--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.1.6&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">mapper 文件配置以下插件</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">        &lt;plugin interceptor=<span class="string">"com.github.pagehelper.PageHelper"</span>&gt;</span><br><span class="line">            &lt;property name=<span class="string">"dialect"</span> value=<span class="string">"mysql"</span>/&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">    </span><br><span class="line">使用方式：</span><br><span class="line">在service层使用：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 指定分页数据</span></span><br><span class="line">PageHelper.startPage(index,size);</span><br><span class="line"><span class="comment">// 2. 查询数据</span></span><br><span class="line">List&lt;Bills&gt; bills = billsMapper.getBills(map);</span><br><span class="line"><span class="comment">// 3. 创建分页工具类</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> PageInfo&lt;&gt;(bills);</span><br><span class="line"></span><br><span class="line">其实是自动用 limit count 等函数帮你查询，你只需要调用其包装好的方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">注意点：返回值是info ,要调用info.list 才能获得其对象，比如这里是bills</span><br><span class="line"></span><br><span class="line">${info.list.size()!=<span class="number">0</span>}  <span class="comment">// 判断集合是否为空</span></span><br><span class="line"></span><br><span class="line">设置首页，上一页，下一页</span><br><span class="line">&lt;a href="/getAllBills?typeId=${typeId}&amp;begin=${begin}&amp;end=${end}"&gt;首页&lt;/a&gt;</span><br><span class="line">&lt;a href="/getAllBills?index=${info.prePage}&amp;typeId=${typeId}&amp;begin=${begin}&amp;end=${end}"&gt;上一页&lt;/a&gt;</span><br><span class="line">&lt;a href="/getAllBills?index=${info.nextPage}&amp;typeId=${typeId}&amp;begin=${begin}&amp;end=${end}"&gt;下一页&lt;/a&gt;</span><br><span class="line">&lt;a href="/getAllBills?index=${info.pages}&amp;typeId=${typeId}&amp;begin=${begin}&amp;end=${end}"&gt;尾页&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">另外就是这些参数有的要附初始值，比如typeId,不然前面假如有比较的话会报空指针</span><br><span class="line">这里备注下方法的传参信息：</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAllBills</span><span class="params">(@RequestParam(defaultValue = <span class="string">"1"</span>)</span><span class="keyword">int</span> index, <span class="comment">// 附一个默认值</span></span></span><br><span class="line"><span class="function">               @<span class="title">RequestParam</span><span class="params">(defaultValue = <span class="string">"-1"</span>)</span><span class="keyword">int</span> typeId, String begin, String end, ModelMap map)</span>{</span><br></pre></td></tr></tbody></table></figure><h3 id="sql-表名列属性采坑"><a href="#sql-表名列属性采坑" class="headerlink" title="sql 表名列属性采坑"></a>sql 表名列属性采坑</h3><p>假如你的表创建的时候，列属性与mysql其内置的关键字冲突，比如name/explain 等等 </p><p>需要在sql 语句 中用 ``  来包裹列属性，就是ESC下面的那个按键  ！！ 切记！！切记！！ 不然就是500 400 啥的</p><p>总结一下，日志是真的好用，比如用了啥啥sql 语句，传了哪些参数，参数的属性是啥一目了然。 纠错超好用</p><h3 id="JSTL-标签库的常用标签"><a href="#JSTL-标签库的常用标签" class="headerlink" title="JSTL 标签库的常用标签"></a>JSTL 标签库的常用标签</h3><p>c 标签：</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">&lt;c:if test="${info.list.size()&gt;0}"&gt; 内容省略 &lt;/c:if&gt;  &lt;%-- 类似于Java中的if--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach items="${types}" var="type"&gt;  内容省略 &lt;/c:forEach&gt;&lt;%-- 类似于Java中的for,types是集合--%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:choose&gt;&lt;%-- 类似于Java中的<span class="keyword">switch</span>--%&gt;</span><br><span class="line">  &lt;c:when test=<span class="string">"${bill.billtype.name=='支出'|| bill.billtype.name=='借出'||bill.billtype.name=='还出'}"</span>&gt;</span><br><span class="line">      -${bill.price}</span><br><span class="line">  &lt;/c:when&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></tbody></table></figure><p>fmt 标签 （将Data 类型转换成 format 类型的数据）</p><p>这里注意一下 MVC 框架默认使用的接收参数的日期格式 （2020/09/18）</p><p>在bean 属性上添加mvc注解：@DateTimeFormat(pattern = “yyyy-MM-dd)  即 只接受（2020-09-18）的日期数据格式</p><figure class="highlight jsp"><table><tbody><tr><td class="code"><pre><span class="line">&lt;%-- 使用format 将日期数据格式化，同样能格式化 number 等数据格式--%&gt;</span><br><span class="line">&lt;fmt:formatDate value=<span class="string">"${bill.billTime}"</span> pattern=<span class="string">"yyyy-MM-dd"</span>/&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="复习一下前端的知识点"><a href="#复习一下前端的知识点" class="headerlink" title="复习一下前端的知识点"></a>复习一下前端的知识点</h2><p>input 标签 常用类型及使用方法</p><p>type 是输入框的类型，value 是给后端的数据，name是传给后端的参数名称</p><figure class="highlight html"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">value</span>=<span class="string">"aa"</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">checked</span> <span class="attr">value</span>=<span class="string">"aa"</span>&gt;</span>type.name</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">value</span>=<span class="string">"aa"</span>&gt;</span>type.name</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">--</span> 不要使用这种隐形文本框传参，可能会有安全隐患，通过源代码可以查到<span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">value</span>=<span class="string">"${bill.id}"</span> <span class="attr">name</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">value</span>=<span class="string">"重置"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"保存"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"返回"</span> <span class="attr">onclick</span>=<span class="string">"location.href='/getAllBills'"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>假如是select ，对应的被选择上是 selected ，有顺序，选择最后面的带有 selected 属性的选择框</p><p>form 表单提交给后台的方式会默认将input 所有的 value 及 name 属性传递给后台 MVC 框架可以自动封装给对应的Bean 类，前提条件是Bean 属性名与 传参的 name 一致，这是约定的，不要随便修改，注意<strong>约定大于配置</strong>！！！！</p><p>其余待补充</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 练习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM框架 </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis 入门</title>
      <link href="/posts/3276.html"/>
      <url>/posts/3276.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h1><h2 id="一、什么是Mybayis"><a href="#一、什么是Mybayis" class="headerlink" title="一、什么是Mybayis"></a>一、什么是Mybayis</h2><p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了googlecode，并且改名为MyBatis，2013年11月迁移到Github。</p><p>iBATIS一词来源于”internet”和”abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQLMaps和Data Access Objects(DAOs)。</p><p><strong>它的特点是什么？</strong></p><ul><li>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。</li><li>MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。</li><li>MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary JavaObject,普通的 Java对象)映射成数据库中的记录。</li></ul><p>说明：持久化就是将数据从瞬时态转化为持久态，长久保存；</p><h2 id="二、搭一个基础的Mybatis"><a href="#二、搭一个基础的Mybatis" class="headerlink" title="二、搭一个基础的Mybatis"></a>二、搭一个基础的Mybatis</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">配置以下可能用到的IDEA 插件 Free-Mybatis LomBok;</span><br><span class="line"></span><br><span class="line">新建Maven项目并添加依赖</span><br><span class="line">&lt;!--Mybatis 核心--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.5&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--数据库连接--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--日志输出--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2.12&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--测试--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">写一个Mybatis 配置文件</span><br><span class="line">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span><br><span class="line">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">&lt;--数据库文件--&gt;</span><br><span class="line">    &lt;properties resource="db.properties"&gt;</span><br><span class="line"></span><br><span class="line">&lt;--配置数据库连接--&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line">    &lt;environments default="development"&gt;</span><br><span class="line">        &lt;environment id="development"&gt;</span><br><span class="line">            &lt;transactionManager type="JDBC"/&gt;</span><br><span class="line">            &lt;dataSource type="POOLED"&gt;</span><br><span class="line">                &lt;property name="driver" value="${driverClassName}"/&gt;</span><br><span class="line">                &lt;property name="url" value="${url}"/&gt;</span><br><span class="line">                &lt;property name="username" value="${username}"/&gt;</span><br><span class="line">                &lt;property name="password" value="${password}"/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">&lt;-- 映射器相关 --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource="sqlmap/userMapper.xml"/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br><span class="line">写一个映射类 userMapper.xml</span><br><span class="line">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span><br><span class="line">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span><br><span class="line">&lt;-- 映射器 --&gt;        </span><br><span class="line">&lt;mapper namespace="com.kaikeba.mybatis.dao.UserDao"&gt;</span><br><span class="line">    &lt;select id="findUserById" parameterType="int" resultType="com.kaikeba.mybatis.po.User"&gt;</span><br><span class="line">        SELECT * FROM USER WHERE ID=#{ID}</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    &lt;insert id="insertUser" parameterType="com.kaikeba.mybatis.po.User"</span><br><span class="line">    useGeneratedKeys="true" keyProperty="id"&gt;</span><br><span class="line">        insert into user value(null,#{username},#{password},#{gender},#{email},#{province},#{city},</span><br><span class="line">        #{birthday,jdbcType=DATE})</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">    &lt;update id="updateUser" parameterType="com.kaikeba.mybatis.po.User"&gt;</span><br><span class="line">        update user set username=#{username},password=#{password},gender=#{gender}</span><br><span class="line">        where id = #id</span><br><span class="line">    &lt;/update&gt;</span><br><span class="line">    &lt;delete id="deleteUser" parameterType="int"&gt;</span><br><span class="line">        DELETE FROM USER WHERE ID = #{ID}</span><br><span class="line">    &lt;/delete&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br><span class="line"></span><br><span class="line">创建一下User bean对象及相应的数据库表格 这里就省略了</span><br><span class="line">配置一下UserDao</span><br><span class="line">public interface UserDao {</span><br><span class="line"></span><br><span class="line">    User findUserById(int id);</span><br><span class="line">    </span><br><span class="line">    void insertUser(User user);</span><br><span class="line"></span><br><span class="line">    void updateUser(User user);</span><br><span class="line">    </span><br><span class="line">    void deleteUser(int id);</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">测试里面测试一下</span><br><span class="line">public class MybatisTest {</span><br><span class="line"></span><br><span class="line">    public DataConnection dataConn = new DataConnection();</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void findUserById() throws IOException {</span><br><span class="line">        SqlSession sqlSession = dataConn.getSqlSession();</span><br><span class="line">        UserDao dao = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        User user = dao.findUserById(2);</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><p>大致过程就完成了，这里有几个注意点：</p><ol><li>对于增删改操作，框架里是加了事务的，所以在执行完成后需要调用<code>sqlSession.commit</code>方法进行事务提交，否则不会保存；</li><li>处理多个参数的情况可以使用Map来进行添加，处理结果数据时也可以使用Map；</li><li>insert 属性中 useGeneratedKeys=”true” keyProperty=”id”是调用添加后id值的，在insert操作完成后，会自动对User对象的id进行值的添加；</li></ol><h2 id="三、Mybatis-复杂查询"><a href="#三、Mybatis-复杂查询" class="headerlink" title="三、Mybatis 复杂查询"></a>三、Mybatis 复杂查询</h2><h3 id="各类标签的使用"><a href="#各类标签的使用" class="headerlink" title="各类标签的使用"></a>各类标签的使用</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;foreach&gt; 标签与 in查询</span><br><span class="line">三种实现方式，list,array,map</span><br><span class="line">对应的collection传值分别为 list,array,map中的key值，map传入泛型是的是String 和 list</span><br><span class="line">以map举例</span><br><span class="line">mapper文件 sql:</span><br><span class="line">&lt;select id="findUserIn" resultType="user"&gt;</span><br><span class="line">        select * from user where id in </span><br><span class="line">        &lt;foreach collection="aa" item="id" separator="," open="(" close=")"&gt;</span><br><span class="line">            #{id}</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">dao 层方法：</span><br><span class="line">List&lt;User&gt; findUserIn(Map map);</span><br><span class="line">测试：</span><br><span class="line">@Test</span><br><span class="line">    public void findUserIn() throws IOException {</span><br><span class="line">        SqlSession sqlSession = dataConn.getSqlSession();</span><br><span class="line">        UserDao dao = sqlSession.getMapper(UserDao.class);</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(1);</span><br><span class="line">        list.add(2);</span><br><span class="line">        Map&lt;String,List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        // key值对应collection的值</span><br><span class="line">        map.put("aa",list);</span><br><span class="line">        List&lt;User&gt; users = dao.findUserIn(map);</span><br><span class="line">        for (User user : users) {</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        }</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">动态sql if标签</span><br><span class="line">&lt;select id="findUserByLike" resultType="user"&gt;</span><br><span class="line">        select * from user</span><br><span class="line">        &lt;where&gt;</span><br><span class="line">            &lt;if test="id!=null and id!=''"&gt;</span><br><span class="line">                and id = #{id}</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test="username!=null and username!=''"&gt;</span><br><span class="line">                and username = #{username}</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">            &lt;if test="password!=null and password!=''"&gt;</span><br><span class="line">                and password = #{password}</span><br><span class="line">            &lt;/if&gt;</span><br><span class="line">        &lt;/where&gt;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">传入一个user对象，可以根据user的属性值是否为空自动进行选择;</span><br></pre></td></tr></tbody></table></figure><h3 id="resultMap的使用"><a href="#resultMap的使用" class="headerlink" title="resultMap的使用"></a>resultMap的使用</h3><p>注意一个细节：一对多中，多方有一方对象，一方有多方集合</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">一对多查询关键字：collection</span><br><span class="line">&lt;resultMap type="" id="自定义名称"&gt;</span><br><span class="line">&lt;id property="id" column="dept_id" /&gt;&lt;!--主键列--&gt;</span><br><span class="line">&lt;result property="java 属性名" column="列名" /&gt;</span><br><span class="line">&lt;collection property="属性名" ofType="java 类型"&gt;</span><br><span class="line">&lt;id property="属性名" column="列名" /&gt;</span><br><span class="line">&lt;result property="属性名" column="列名" /&gt;</span><br><span class="line">&lt;/collection&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">多对一查询关键字：association</span><br><span class="line">&lt;resultMap type="" id=""&gt;</span><br><span class="line">&lt;id property="" column="" /&gt;</span><br><span class="line">&lt;result property="" column="" /&gt;</span><br><span class="line">&lt;association property="" javaType=""&gt;</span><br><span class="line">&lt;id property="" column="" /&gt;</span><br><span class="line">&lt;result property="" column="" /&gt;</span><br><span class="line">&lt;/association&gt;</span><br><span class="line">&lt;/resultMap&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="四、Mybatis-核心文件解读"><a href="#四、Mybatis-核心文件解读" class="headerlink" title="四、Mybatis 核心文件解读"></a>四、Mybatis 核心文件解读</h2><h3 id="核心配置文件"><a href="#核心配置文件" class="headerlink" title="核心配置文件"></a>核心配置文件</h3><ul><li>mybatis-config.xml 系统核心配置文件</li><li>核心配置文件主要配置mybatis一些基础组件和加载资源，核心配置文件中的元素常常能影响mybatis的整个运行过程。</li><li>能配置的内容如下，顺序不能乱，乱了会报错！！！：</li></ul><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.properties是一个配置属性的元素</span><br><span class="line">2.settings设置，mybatis最为复杂的配置也是最重要的，会改变mybatis运行时候的行为</span><br><span class="line">3.typeAliases别名（在TypeAliasRegistry中可以看到mybatis提供了许多的系统别名）</span><br><span class="line">4.typeHandlers 类型处理器（比如在预处理语句中设置一个参数或者从结果集中获取一个参数时候，都会用到类型处理器，在TypeHandlerRegistry中定义了很多的类型处理器）</span><br><span class="line">5.objectFactory 对象工厂（myabtis在构建一个结果返回的时候，会使用一个ObjectFactory去构建pojo)</span><br><span class="line">6.plugins 插件</span><br><span class="line">7.environments 环境变量</span><br><span class="line">    environment 环境变量</span><br><span class="line">    transactionManager 事务管理器</span><br><span class="line">    dataSource 数据源</span><br><span class="line">    databaseIdProvider 数据库厂商标识</span><br><span class="line">8.mappers 映射器</span><br></pre></td></tr></tbody></table></figure><p>来说一说其中比较重要的元素</p><h4 id="（1）environments元素"><a href="#（1）environments元素" class="headerlink" title="（1）environments元素"></a>（1）environments元素</h4><p>environments可以为mybatis配置多环境运行，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定），如果想切换环境修改default的值即可。</p><p>最常见的就是，生产环境和开发环境，两个环境切换必将导致数据库的切换；</p><p>environments 中可以配置多个数据源，default 数据源选择的哪个，就用的哪个</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"${driver}"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${url}"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${username}"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${password}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"..."</span> <span class="attr">value</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"${driver}"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"${url}"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"${username}"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${password}"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</li><li>数据源是必须配置的。</li><li>有三种内建的数据源类型（UNPOOLED|POOLED|JNDI）</li></ul><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">type="[UNPOOLED|POOLED|JNDI]"）</span><br><span class="line">- unpooled：这个数据源的实现只是每次被请求时打开和关闭连接。</span><br><span class="line">- pooled：这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来 , 这是一种使得并发 Web 应用快速响应请求的流行处理方式。</span><br><span class="line">- jndi：这个数据源的实现是为了能在如 Spring 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的引用。</span><br></pre></td></tr></tbody></table></figure><ul><li>数据源也有很多第三方的实现，比如druid，hikari，dbcp，c3p0等等….</li><li>这两种事务管理器类型都不需要设置任何属性。</li><li>具体的一套环境，通过设置id进行区别，id保证唯一！</li><li>子元素节点：transactionManager — 事务管理器，常用的（ JDBC | MANAGED）</li></ul><h4 id="（2）mappers元素"><a href="#（2）mappers元素" class="headerlink" title="（2）mappers元素"></a>（2）mappers元素</h4><p>引入 对应的Mappee 文件中的 sql 语句，形成映射器，这里说一下mapper 文件中的属性</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">    <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.xinzhi.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这里的namespace 的意思是命名空间，通常写的是dao 中接口的对应路径，这样调用接口的方法，就自动找了mapper中的sql 语句调用，还要注意的一点是需要 后面ssm 集成的时候需要配置 Mapper 扫描，这样连 dao.impl层都不用写啦！！</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!--创建Mapper扫描--&gt;</span><br><span class="line">   &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;</span><br><span class="line">       &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt;</span><br><span class="line">       &lt;property name="basePackage" value="com.kaikeba.dao"/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="（3）Properties元素"><a href="#（3）Properties元素" class="headerlink" title="（3）Properties元素"></a>（3）Properties元素</h4><p>没什么好说的，引入外部资源文件，这里通常是导入 db.properties 德鲁伊的连接池文件内容</p><h4 id="（4）typeAliases-元素"><a href="#（4）typeAliases-元素" class="headerlink" title="（4）typeAliases 元素"></a>（4）typeAliases 元素</h4><p>配置别名，就是mapper文件可以直接用类名，对应包的路径不用写了，个人感觉比较鸡肋</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;typeAliases&gt;</span><br><span class="line">       &lt;package name="com.kaikeba.bean"/&gt;</span><br><span class="line">   &lt;/typeAliases&gt;</span><br></pre></td></tr></tbody></table></figure><h4 id="（5）Setting-属性"><a href="#（5）Setting-属性" class="headerlink" title="（5）Setting 属性"></a>（5）Setting 属性</h4><p>按需配置，要的时候过来查即可</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;settings&gt;</span><br><span class="line">    &lt;!----&gt;</span><br><span class="line">    &lt;setting name="cacheEnabled" value="true"/&gt;</span><br><span class="line">    &lt;!----&gt;</span><br><span class="line">    &lt;setting name="lazyLoadingEnabled" value="true"/&gt;</span><br><span class="line">    &lt;!----&gt;</span><br><span class="line">    &lt;setting name="multipleResultSetsEnabled" value="true"/&gt;</span><br><span class="line">    &lt;setting name="useColumnLabel" value="true"/&gt;</span><br><span class="line">    &lt;setting name="useGeneratedKeys" value="false"/&gt;</span><br><span class="line">    &lt;setting name="autoMappingBehavior" value="PARTIAL"/&gt;</span><br><span class="line">    &lt;setting name="autoMappingUnknownColumnBehavior" value="WARNING"/&gt;</span><br><span class="line">    &lt;setting name="defaultExecutorType" value="SIMPLE"/&gt;</span><br><span class="line">    &lt;setting name="defaultStatementTimeout" value="25"/&gt;</span><br><span class="line">    &lt;setting name="defaultFetchSize" value="100"/&gt;</span><br><span class="line">    &lt;setting name="safeRowBoundsEnabled" value="false"/&gt;</span><br><span class="line">    &lt;setting name="mapUnderscoreToCamelCase" value="false"/&gt;</span><br><span class="line">    &lt;setting name="localCacheScope" value="SESSION"/&gt;</span><br><span class="line">    &lt;setting name="jdbcTypeForNull" value="OTHER"/&gt;</span><br><span class="line">    &lt;setting name="lazyLoadTriggerMethods" value="equals,clone,hashCode,toString"/&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></tbody></table></figure><p>属性的具体介绍参考如下：</p><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html#settings" target="_blank" rel="noopener">Mybatis官方配置文档</a></p><h2 id="五、Mybatis缓存"><a href="#五、Mybatis缓存" class="headerlink" title="五、Mybatis缓存"></a>五、Mybatis缓存</h2><h3 id="1、为什么要用缓存？"><a href="#1、为什么要用缓存？" class="headerlink" title="1、为什么要用缓存？"></a>1、为什么要用缓存？</h3><ul><li>如果缓存中有数据，就不用从数据库获取，大大提高系统性能</li><li>mybatis提供一级缓存和二级缓存</li></ul><h3 id="2、一级缓存"><a href="#2、一级缓存" class="headerlink" title="2、一级缓存"></a>2、一级缓存</h3><ul><li><p>一级缓存是sqlsession级别的缓存</p></li><li><p>在操作数据库时，需要构造sqlsession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据</p></li><li><p>不同的sqlsession之间的缓存区域是互相不影响的</p></li></ul><h4 id="一级缓存工作原理"><a href="#一级缓存工作原理" class="headerlink" title="一级缓存工作原理"></a>一级缓存工作原理</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200918115835928.png" alt="image-20200918115835928"></p><ul><li>第一次发起查询sql查询用户id为1的用户，先去找缓存中是否有id为1的用户，如果没有，再去数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。</li><li>如果sqlsession执行了commit操作（插入，更新，删除），会清空sqlsession中的一级缓存，避免脏读</li><li>第二次发起查询id为1的用户，缓存中如果找到了，直接从缓存中获取用户信息</li><li>mybatis默认支持并开启一级缓存</li></ul><h4 id="一级缓存失效原因"><a href="#一级缓存失效原因" class="headerlink" title="一级缓存失效原因"></a>一级缓存失效原因</h4><ol><li>sqlSession不同</li><li>当sqlSession对象相同的时候，查询的条件不同，原因是第一次查询时候一级缓存中没有第二次查询所需要的数据</li><li>当sqlSession对象相同，两次查询之间进行了插入的操作</li><li>当sqlSession对象相同，手动清除了一级缓存中的数据</li></ol><h3 id="3、二级缓存"><a href="#3、二级缓存" class="headerlink" title="3、二级缓存"></a>3、二级缓存</h3><ul><li>二级缓存是mapper级别的缓存</li><li>多个sqlsession去操作同一个mapper的sql语句，多个sqlsession可以共用二级缓存，所得到的数据会存在二级缓存区域</li><li>二级缓存是跨sqlsession的</li><li>二级缓存相比一级缓存的范围更大（按namespace来划分），多个sqlsession可以共享一个二级缓存</li></ul><p>大体见下图</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200918120802077.png" alt="image-20200918120802077"></p><h4 id="二级缓存实现原理"><a href="#二级缓存实现原理" class="headerlink" title="二级缓存实现原理"></a>二级缓存实现原理</h4><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200918120901387.png" alt="image-20200918120901387"></p><ul><li>首先要手动开启mybatis二级缓存：<br>在config.xml设置二级缓存开关 ， 还要在具体的mapper.xml开启二级缓存</li></ul><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需要将映射的javabean类实现序列化 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mybatis-config文件中配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启二级缓存--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- mybatis-config文件中配置--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下面语句意思是创建了一个 LRU 缓存，每隔 100 秒刷新，最多可以存储 512 个对象，返回的对象是只读的。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"LRU"</span> <span class="attr">flushInterval</span>=<span class="string">"10000"</span> <span class="attr">size</span>=<span class="string">"1024"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>cache属性的简介</strong></p><blockquote><p><strong>eviction</strong>回收策略（缓存满了的淘汰机制），目前MyBatis提供以下策略。</p><ol><li>LRU（Least Recently Used）,最近最少使用的，最长时间不用的对象</li><li>FIFO（First In First Out）,先进先出，按对象进入缓存的顺序来移除他们</li><li>SOFT,软引用，移除基于垃圾回收器状态和软引用规则的对象</li><li>WEAK,弱引用，更积极的移除基于垃圾收集器状态和弱引用规则的对象。这里采用的是LRU， 移除最长时间<br>不用的对形象</li></ol><p><strong>flushInterval</strong>:刷新间隔时间，单位为毫秒</p><p>这里配置的是100秒刷新，如果你不配置它，那么当SQL被执行的时候才会去刷新缓存</p><p><strong>size</strong>:引用数目</p><p>一个正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。这里配置的是1024个对象</p><p><strong>readOnly</strong>:只读</p><p>意味着缓存数据只能读取而不能修改，这样设置的好处是我们可以快速读取缓存，缺点是我们没有办法修改缓存，他的默认值是false，不允许我们修改</p></blockquote><h4 id="配置二级缓存"><a href="#配置二级缓存" class="headerlink" title="配置二级缓存"></a>配置二级缓存</h4><p>先不进行配置</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void testFindUserCache() throws Exception {</span><br><span class="line">    //使用不同的mapper</span><br><span class="line">    UserMapper mapper1 = session.getMapper(UserMapper.class);</span><br><span class="line">    User user1 = mapper1.findUserById(1);</span><br><span class="line">    System.out.println(user1);</span><br><span class="line">    //提交了就会刷到二级缓存，要不还在一级缓存，一定要注意</span><br><span class="line">    session.commit();</span><br><span class="line">    UserMapper mapper2 = session.getMapper(UserMapper.class);</span><br><span class="line">    User user2 = mapper2.findUserById(1);</span><br><span class="line">    System.out.println(user2);</span><br><span class="line">    System.out.println(user1 == user2);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>结果可以看见两次同样的sql，却都进库进行了查询。说明二级缓存没开</p><p>进行配置</p><p>1、开启全局配置</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;setting name="cacheEnabled" value="true"/&gt;</span><br></pre></td></tr></tbody></table></figure><p>2、配置mapper 文件</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;!--创建了一个 LRU 缓存，每隔 100 秒刷新，最多可以存储 512 个对象，返回的对象是只读的。--&gt;</span><br><span class="line">&lt;cache eviction="LRU" flushInterval="10000" size="1024" readOnly="true"&gt;&lt;/cache&gt;</span><br></pre></td></tr></tbody></table></figure><p>3、测试执行</p><p>两个对象一样了，日记记录里面就发了一个sql，说明缓存起了作用</p><h3 id="4、第三方缓存—EhCache充当三级缓存"><a href="#4、第三方缓存—EhCache充当三级缓存" class="headerlink" title="4、第三方缓存—EhCache充当三级缓存"></a>4、第三方缓存—EhCache充当三级缓存</h3><blockquote><p>三级缓存很多，最常用的比如ehcache，Memcached、redis等，我们以比较简单的ehcache为例</p></blockquote><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line">1. 引入依赖</span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.caches<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-ehcache<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">2. 修改mapper.xml中使用对应的缓存</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span> = <span class="string">“com.xinzhi.entity.User”</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span>=<span class="string">"org.mybatis.caches.ehcache.EhcacheCache"</span> <span class="attr">eviction</span>=<span class="string">"LRU"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">flushInterval</span>=<span class="string">"10000"</span> <span class="attr">size</span>=<span class="string">"1024"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3. 添加ehcache.xml文件，ehcache配置文件，具体配置自行百度</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ehcache</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:noNamespaceSchemaLocation</span>=<span class="string">"http://ehcache.org/ehcache.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">updateCheck</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：</span></span><br><span class="line"><span class="comment">user.home – 用户主目录</span></span><br><span class="line"><span class="comment">user.dir – 用户当前工作目录</span></span><br><span class="line"><span class="comment">java.io.tmpdir – 默认临时文件路径</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">diskStore</span> <span class="attr">path</span>=<span class="string">"./tmpdir/Tmp_EhCache"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">defaultCache</span></span></span><br><span class="line"><span class="tag">        <span class="attr">eternal</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">maxElementsInMemory</span>=<span class="string">"10000"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">overflowToDisk</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">diskPersistent</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToIdleSeconds</span>=<span class="string">"1800"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">timeToLiveSeconds</span>=<span class="string">"259200"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">memoryStoreEvictionPolicy</span>=<span class="string">"LRU"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ehcache</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 核心框架篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> SSM框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC 入门</title>
      <link href="/posts/59145.html"/>
      <url>/posts/59145.html</url>
      
        <content type="html"><![CDATA[<h1 id="初学Spring-MVC"><a href="#初学Spring-MVC" class="headerlink" title="初学Spring MVC"></a>初学Spring MVC</h1><p>简单介绍一下什么是MVC，M 即 modle(模型)，指的是dao层从数据库中查找到的数据，V View(视图) 用于展示模型中的数据，C Controller(控制器) 控制器的作用就是将不同的数据，展示到不同的页面上，实际也就是Servlet； </p><h2 id="Spring-MVC-常用组件"><a href="#Spring-MVC-常用组件" class="headerlink" title="Spring MVC 常用组件"></a>Spring MVC 常用组件</h2><p><strong>DispatcherServlet</strong>：作为前端控制器，整个流程控制的中心，控制其它组件执行，统一调度，降低组件之间的耦合性，提高每个组件的扩展性。</p><p><strong>HandlerMapping</strong>：通过扩展处理器映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><p><strong>HandlAdapter</strong>：通过扩展处理器适配器，支持更多类型的处理器,调用处理器传递参数等工作</p><p><strong>ViewResolver</strong>：通过扩展视图解析器，支持更多类型的视图解析，例如：jsp、freemarker、pdf、excel等。</p><h3 id="Dispatcher介绍"><a href="#Dispatcher介绍" class="headerlink" title="Dispatcher介绍"></a>Dispatcher介绍</h3><p>主要功能</p><ol><li>文件上传解析，如果请求类型是multipart将通过MultipartResolver进行文件上传解析；</li><li>通过HandlerMapping，将请求映射到处理器（返回一个HandlerExecutionChain，它包括一个处理器、多个<br>HandlerInterceptor拦截器）；</li><li>通过HandlerAdapter支持多种类型的处理器(HandlerExecutionChain中的处理器)；</li><li>通过ViewResolver解析逻辑视图名到具体视图实现；</li><li>本地化解析；</li><li>渲染具体的视图等；</li><li>如果执行过程中遇到异常将交给HandlerExceptionResolver来解析。</li></ol><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200910122726440.png" alt="image-20200910122726440"></p><h3 id="Dispatcher辅助类"><a href="#Dispatcher辅助类" class="headerlink" title="Dispatcher辅助类"></a>Dispatcher辅助类</h3><table><thead><tr><th align="center">bean类型</th><th>说明</th></tr></thead><tbody><tr><td align="center">Controller</td><td>处理器/页面控制器，做的是MVC中的C的事情，但控制逻辑转移到前端控制器了，用于对请求进行处理</td></tr><tr><td align="center">HandlerMapping</td><td>请求到处理器的映射，如果映射成功返回一个HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象；如BeanNameUrlHandlerMapping将URL与Bean名字映射，映射成功的Bean就是此处的处理器</td></tr><tr><td align="center">HandlerAdapter</td><td>HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；如SimpleControllerHandlerAdapter将对实现了Controller接口的Bean进行适配，并且掉处理器的handleRequest方法进行功能处理</td></tr><tr><td align="center">HandlerExceptionResolver处理器异常解析器</td><td>处理器异常解析，可以将异常映射到相应的统一错误界面，从而显示用户友好的界面（而不是给用户看到具体的错误信息</td></tr><tr><td align="center">ViewResolver视图解析器</td><td>ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；如InternalResourceViewResolver将逻辑视图名映射为jsp视图</td></tr><tr><td align="center">LocaleResolver &amp;LocaleContextResolver地区解析器和地区Context解析器</td><td>解析客户端中使用的地区和时区，用来提供不同的国际化的view视图</td></tr><tr><td align="center">ThemeResolver</td><td>主题解析器,解析web应用中能够使用的主题，比如提供个性化的网页布局</td></tr><tr><td align="center">MultipartResolver</td><td>多部件解析器,主要处理multi-part(多部件)request请求，例如：在HTML表格中处理文件上传</td></tr><tr><td align="center">FlashMapManager</td><td>FlashMap管理器储存并检索在”input”和”output”的FlashMap中可以在request请求间(通常是通过重定向)传递属性的FlashMap</td></tr></tbody></table><h2 id="MVC-搭建"><a href="#MVC-搭建" class="headerlink" title="MVC 搭建"></a>MVC 搭建</h2><h3 id="基本版"><a href="#基本版" class="headerlink" title="基本版"></a>基本版</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. 导入依赖  注意packaging 应该是war 因为是web项目了</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;jstl&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.2.6.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;4.0.0&lt;/version&gt;</span><br><span class="line">            &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">2.配置web.xml 文件 所有的.action 都会走DispatcherServlet</span><br><span class="line">&lt;servlet&gt;</span><br><span class="line">        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</span><br><span class="line">        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">    &lt;/servlet&gt;</span><br><span class="line">    &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/servlet-mapping&gt;</span><br><span class="line">    &lt;filter&gt;</span><br><span class="line">        &lt;filter-name&gt;code&lt;/filter-name&gt;</span><br><span class="line">        &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">        &lt;init-param&gt;</span><br><span class="line">            &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">            &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">        &lt;/init-param&gt;</span><br><span class="line">    &lt;/filter&gt;</span><br><span class="line">    &lt;filter-mapping&gt;</span><br><span class="line">        &lt;filter-name&gt;code&lt;/filter-name&gt;</span><br><span class="line">        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">    &lt;/filter-mapping&gt;</span><br><span class="line">    </span><br><span class="line">3.写一个spring.xml &lt;这里把所有的命名空间基本上都加上了，可以自行省略&gt;</span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xmlns:mvc="http://www.springframework.org/schema/mvc"</span><br><span class="line">       xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">       xmlns:aop="http://www.springframework.org/schema/aop"</span><br><span class="line">       xmlns:tx="http://www.springframework.org/schema/tx"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/mvc</span><br><span class="line">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        http://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        http://www.springframework.org/schema/aop/spring-aop.xsd</span><br><span class="line">        http://www.springframework.org/schema/tx</span><br><span class="line">        http://www.springframework.org/schema/tx/spring-tx.xsd"&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置映射器--&gt;</span><br><span class="line">    &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt;</span><br><span class="line">    &lt;!--配置适配器--&gt;</span><br><span class="line">    &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/&gt;</span><br><span class="line">    &lt;!--配置视图解析器--&gt;</span><br><span class="line">    &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt;</span><br><span class="line">    &lt;!--前缀--&gt;</span><br><span class="line">        &lt;property name="prefix" value="/WEB-INF/pages/"/&gt;</span><br><span class="line">        &lt;!--后缀--&gt;</span><br><span class="line">        &lt;property name="suffix" value=".jsp"/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean name="/queryFruits.action" class="com.kaikeba.controller.FruitsControllerTest"/&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">4.来一个实现类 直接继承 org.springframework.web.servlet.mvc.Controller 这个接口就返回ModleAndView即可</span><br><span class="line"></span><br><span class="line">public class FruitsControllerTest implements Controller {</span><br><span class="line"></span><br><span class="line">    private FruitsService fruitsService = new FruitsService();</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {</span><br><span class="line">        // 模拟Service 获取水果商品列表</span><br><span class="line">        List&lt;Fruits&gt; fruits = fruitsService.queryFruitsList();</span><br><span class="line">        // 返回ModelAndBView</span><br><span class="line">        ModelAndView modelAndView = new ModelAndView();</span><br><span class="line">        modelAndView.addObject("fruitsList",fruits);</span><br><span class="line">        modelAndView.setViewName("fruitsList");</span><br><span class="line">        return modelAndView;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">// 内部类实现Service数据</span><br><span class="line">class FruitsService{</span><br><span class="line">    public List&lt;Fruits&gt; queryFruitsList(){</span><br><span class="line">        List&lt;Fruits&gt; fruits = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        Fruits apple = new Fruits();</span><br><span class="line">        apple.setName("红富士");</span><br><span class="line">        apple.setPrice(10.3);</span><br><span class="line">        apple.setProducing_area("芭莎黑");</span><br><span class="line"></span><br><span class="line">        Fruits banana = new Fruits();</span><br><span class="line">        banana.setName("香蕉");</span><br><span class="line">        banana.setPrice(2.2);</span><br><span class="line">        banana.setProducing_area("海南");</span><br><span class="line"></span><br><span class="line">        fruits.add(apple);</span><br><span class="line">        fruits.add(banana);</span><br><span class="line">        return fruits;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>解释一下，为什么页面要写在WEB-INF/pages下，因为这个页面没有办法直接通过链接直接进行访问，需要通过Controller 来进行访问！</p><h3 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">在上述 spring.xml文件中添加扫包操作</span><br><span class="line">&lt;!--开启扫包功能--&gt;</span><br><span class="line">    &lt;context:component-scan base-package="com.kaikeba"/&gt;</span><br><span class="line">    &lt;!--开启mvc自带注解--&gt;</span><br><span class="line">    &lt;mvc:annotation-driven/&gt;</span><br><span class="line"></span><br><span class="line">配置类的注解信息：</span><br><span class="line">@Controller</span><br><span class="line">@RequestMapping("/fruit")</span><br><span class="line">public class FruitsControllerTest{</span><br><span class="line"></span><br><span class="line">    private FruitsService fruitsService = new FruitsService();</span><br><span class="line"></span><br><span class="line">    @RequestMapping("/a")</span><br><span class="line">    public String aRequest(Model model,HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {</span><br><span class="line">        // 模拟Service 获取水果商品列表</span><br><span class="line">        List&lt;Fruits&gt; fruits = fruitsService.queryFruitsList();</span><br><span class="line">        // 返回ModelAndBView</span><br><span class="line">        model.addAttribute("fruitsList",fruits);</span><br><span class="line">        return "fruitsList";</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">即 url = http://localhost/fruit/a 实现访问</span><br></pre></td></tr></tbody></table></figure><p>使用注解可以任意配置方法名称，任意配置访问的url，同时还能任意配置接收的参数，想要什么就配置什么，是不是超级方便！！</p><p>@Controller    标注该类为Controller层的类</p><p>@<strong>RequestMapping</strong>(“请求地址”)    设置请求地址</p><p>RequestMapping注解有六个属性</p><p>1、 value ， method </p><p>value： 指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；</p><p>method： 指定请求的method类型， GET、POST、PUT、DELETE等；</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">url 为/a Get请求才会访问</span><br><span class="line">@RequestMapping(value = "/a",method = RequestMethod.GET)</span><br></pre></td></tr></tbody></table></figure><p>2、 consumes ， produces </p><p>consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;</p><p>produces: 指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回,可以处理乱码</p><p>3、 params ， headers </p><p>params： 指定request中必须包含某些参数值是，才让该方法处理</p><p>headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@RequestMapping(value = "/b",params = "name",consumes = {"text/html"})</span><br></pre></td></tr></tbody></table></figure><p>注意<strong>约定大于配置</strong>的设计范式：</p><p>@RequestParam    使用场景：当接收的参数名与传入的参数名不一致时，可通过此注解来进行参数名称配置</p><p>@RequestParam(value = “name”）设置接收请求的参数 username 用name来接收  </p><h3 id="讲一下DispacherServlet的实现过程"><a href="#讲一下DispacherServlet的实现过程" class="headerlink" title="讲一下DispacherServlet的实现过程"></a>讲一下DispacherServlet的实现过程</h3><p>其实一张图就可以搞定</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200916112841677.png" alt="image-20200916112841677"></p><h3 id="用JSON-来接收返回数据"><a href="#用JSON-来接收返回数据" class="headerlink" title="用JSON 来接收返回数据"></a>用JSON 来接收返回数据</h3><p>@ResponseBody    不会找视图，直接返回数据，可以直接返回 String，User 都可以</p><p>等于就是访问/ url 地址，返回给你的就是只有数据</p><p>怎么把 对应的User 类型的数据自动转成JSON 格式的数据？ 配置一个消息转化器，可以将返回消息自动转化成JSON 格式</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;mvc:annotation-driven&gt;</span><br><span class="line">        &lt;!--配置消息转化器--&gt;</span><br><span class="line">        &lt;mvc:message-converters&gt;</span><br><span class="line">            &lt;bean id="fastjson"</span><br><span class="line">                  class="com.alibaba.fastjson.support.spring.FastJsonHttpMessageConverter"&gt;</span><br><span class="line">                &lt;property name="supportedMediaTypes"&gt;</span><br><span class="line">                    &lt;list&gt;</span><br><span class="line">                        &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt;</span><br><span class="line">                        &lt;value&gt;application/json;charset=UTF-8&lt;/value&gt;</span><br><span class="line">                    &lt;/list&gt;</span><br><span class="line">                &lt;/property&gt;</span><br><span class="line">            &lt;/bean&gt;</span><br><span class="line">        &lt;/mvc:message-converters&gt;</span><br><span class="line">    &lt;/mvc:annotation-driven&gt;</span><br><span class="line">    </span><br><span class="line">handle信息：</span><br><span class="line">@RequestMapping(value = "/c")</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public Fruits cRequest(){</span><br><span class="line">        return new Fruits("蓝苹果",15,"广西");</span><br><span class="line">    }</span><br><span class="line">注意的是，这里会自动将类名属性，属性值，封装成一个Json 格式的数据类型，集合类型也能转</span><br></pre></td></tr></tbody></table></figure><h3 id="获取请求头信息"><a href="#获取请求头信息" class="headerlink" title="获取请求头信息"></a>获取请求头信息</h3><p>获取请求体内的 JSON 数据（这里要用到PostMan 来发送请求用 raw，然后设置 传送格式）</p><p>参数前面加上@RequestBody 即可接受到请求体内的信息</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/c"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">cRequest</span><span class="params">(@RequestBody String str,HttpServletRequest request)</span></span>{</span><br><span class="line">        System.out.println(request.getContentType());</span><br><span class="line">        System.out.println(str);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    }</span><br><span class="line">得到了request传过来的String</span><br><span class="line"></span><br><span class="line">升级一下：</span><br><span class="line">配置 传入JSON 格式的类，然后也输出成JSON 格式的类（这里没有进行处理）</span><br><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/c"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Fruits <span class="title">cRequest</span><span class="params">(@RequestBody Fruits fruits,HttpServletRequest request)</span></span>{</span><br><span class="line">        System.out.println(request.getContentType());</span><br><span class="line">        System.out.println(fruits);</span><br><span class="line">        fruits.setName(<span class="string">"青苹果"</span>);</span><br><span class="line">        <span class="keyword">return</span> fruits;</span><br><span class="line">    }</span><br><span class="line">这里传入的JSON 数据为{<span class="string">"name"</span>:<span class="string">"红苹果"</span>,<span class="string">"price"</span>:<span class="number">18.0</span>,<span class="string">"producing_area"</span>:<span class="string">"湖南"</span>}</span><br><span class="line">起作用的 ContentType类型有text/html、application/json</span><br><span class="line">会自动输出成{<span class="string">"name"</span>:<span class="string">"青苹果"</span>,<span class="string">"price"</span>:<span class="number">18.0</span>,<span class="string">"producing_area"</span>:<span class="string">"湖南"</span>} 格式的数据</span><br></pre></td></tr></tbody></table></figure><h3 id="参数转化"><a href="#参数转化" class="headerlink" title="参数转化"></a>参数转化</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">@AllArgsConstructor</span><br><span class="line">@NoArgsConstructor</span><br><span class="line">public class User {</span><br><span class="line">private String name;</span><br><span class="line">@DateTimeFormat(pattern = "yyyy-MM-dd")</span><br><span class="line">private Date birthday;</span><br><span class="line">@NumberFormat(pattern = "#,###,###.#")</span><br><span class="line">private Double salary;</span><br><span class="line">}</span><br><span class="line">实现handle为：</span><br><span class="line">@RequestMapping("/add")</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public User addUser(User user, HttpServletRequest request){</span><br><span class="line">        System.out.println(request.getContentType());</span><br><span class="line">        System.out.println(user);</span><br><span class="line">        return user;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">发送数据为 contentType = application/x-www-form-urlencoded</span><br><span class="line">url为：http://localhost/user/add?id=10&amp;name=haha&amp;birthday=2020-01-01&amp;salary=1,101,101.22</span><br><span class="line"></span><br><span class="line">可得到如下的输出结果：</span><br><span class="line">{"birthday":1577808000000,"id":10,"name":"haha","salary":1101101.22}</span><br></pre></td></tr></tbody></table></figure><h3 id="数据校验（Validation）"><a href="#数据校验（Validation）" class="headerlink" title="数据校验（Validation）"></a>数据校验（Validation）</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.导入依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.hibernate&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;6.0.9.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">2.spring.xml文件里面配置</span><br><span class="line">&lt;bean id="beacon1024Validator"</span><br><span class="line">class="org.springframework.validation.beanvalidation.LocalValidatorFactoryBean"&gt;</span><br><span class="line">&lt;property name="providerClass" value="org.hibernate.validator.HibernateValidator"/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;!--注册注解驱动--&gt;</span><br><span class="line">&lt;mvc:annotation-driven validator="beacon1024Validator"/&gt;</span><br><span class="line"></span><br><span class="line">3.实体类加上注解</span><br><span class="line">public class User {</span><br><span class="line"></span><br><span class="line">@NotEmpty(message = "姓名不能为空")</span><br><span class="line">@Size(min = 4,max = 20,message = "姓名长度必须在{min}-{max}之间")</span><br><span class="line">private String name;</span><br><span class="line">@Min(value = 0, message = "年龄不能小于{value}")</span><br><span class="line">@Max(value = 120,message = "年龄不能大于{value}")</span><br><span class="line">private int age;</span><br><span class="line">@Pattern(regexp = "^1([358][0-9]|4[579]|66|7[0135678]|9[89])[0-9]{8}$", message ="手机号码不正确")</span><br><span class="line">private String phone;</span><br><span class="line">}</span><br><span class="line">4.方法名称及参数上加上注解</span><br><span class="line"></span><br><span class="line">//Validated 注解后面要紧跟着BindingResult，这两个参数都是成对出现的，否则请求无法进来</span><br><span class="line">@PostMapping("/user")</span><br><span class="line">public void testAnnotation(@Validated User user, BindingResult br){</span><br><span class="line">// 打印所有错误</span><br><span class="line">List&lt;ObjectError&gt; allErrors = br.getAllErrors();</span><br><span class="line">for (ObjectError error : allErrors) {</span><br><span class="line">System.out.println(error.getDefaultMessage());</span><br><span class="line">System.out.println(error.getCode());</span><br><span class="line">}</span><br><span class="line">//验证有错误直接返回</span><br><span class="line">if(allErrors.size() &gt; 0){</span><br><span class="line">return;</span><br><span class="line">}</span><br><span class="line">System.out.print(user);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="转发和重定向"><a href="#转发和重定向" class="headerlink" title="转发和重定向"></a>转发和重定向</h3><p>参考：<a href="https://blog.csdn.net/qq_28165595/article/details/76896354" target="_blank" rel="noopener">https://blog.csdn.net/qq_28165595/article/details/76896354</a></p><p>直接retuen String 默认走的转发</p><p>需要重定向在String 前面加上 redirect:/ (引号里面，/ 是根目录)</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>@Controller    spring自带的设置Controller层的注解</p><p>@<strong>RequestMapping</strong>    mvc中用于设置请求路径的注解</p><p>@RequestParam    解决传参名与接收参数名称不一致的问题</p><p>@ResponseBody    </p><p>@DateTimeFormat(pattern = “yyyy-MM-dd”)Date date    实例对象前面加注解设置日期格式     </p><p>需要配置文件:<code>&lt;mvc:annotation-driven/&gt;</code></p><p>@sessionAttributes(“key值”)    写的是ModelMap中定义的key值</p><p>@ControllerAdvice(Exception.class)    处理全局异常</p><p>@CookieValue(“JSESSIONID”)String cookie    获取cookie 值</p><p>@RequestHeader    获取请求头信息</p><p>@PathVariable(value = “id”)    restful 获取路径下变量</p><h2 id="RestFul-风格"><a href="#RestFul-风格" class="headerlink" title="RestFul 风格"></a>RestFul 风格</h2><p>表现层状态转化，</p><p>GET  获取资源</p><p>POST     创建新资源</p><p>PUT     更新资源</p><p>DELETE    删除资源</p><p>废话不多说，上代码</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">配置一个遵循restFul风格的CURD</span><br><span class="line">    </span><br><span class="line"><span class="keyword">package</span> com.kaikeba.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.kaikeba.bean.User;</span><br><span class="line"><span class="keyword">import</span> com.kaikeba.util.R;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;    </span><br><span class="line">    </span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">(User user)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"========调用Dao层保存用户========="</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(value = <span class="string">"{id}"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">deleteUser</span><span class="params">(@PathVariable <span class="keyword">int</span> id)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"========调用Dao层删除用户========="</span>+id);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span>(value = <span class="string">"{id}"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">updateUser</span><span class="params">(@PathVariable <span class="keyword">int</span> id,User user)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"========调用Dao层更新用户========="</span>+id);</span><br><span class="line">        <span class="keyword">return</span> R.success();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(value = <span class="string">"{id}"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable <span class="keyword">int</span> id)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"========调用Dao层查找用户========="</span>+id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(id,<span class="string">"haha"</span>,<span class="keyword">new</span> Date(),<span class="number">1001.2</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">设置专门用于返回信息的类 R</span><br><span class="line"><span class="keyword">package</span> com.kaikeba.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">R</span><span class="params">(<span class="keyword">int</span> code, String msg, Map&lt;String, Object&gt; data)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功的返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> R <span class="title">success</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> R(<span class="number">200</span>, <span class="string">"操作成功"</span>, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//失败的返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> R <span class="title">fail</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> R(<span class="number">500</span>, <span class="string">"操作失败"</span>, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//其他类型的返回</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> R <span class="title">build</span><span class="params">(<span class="keyword">int</span> code, String msg)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> R(<span class="number">500</span>, msg, <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">put</span><span class="params">(String key, Object msg)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.getData() == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">this</span>.setData(<span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>));</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.getData().put(key, msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="整一个小插件"><a href="#整一个小插件" class="headerlink" title="整一个小插件"></a>整一个小插件</h3><p>用于发送restful 请求</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">创建文件 user.http</span><br><span class="line">POST http://localhost/user</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">id=18&amp;name=张三</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line">GET http://localhost/user/2</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line">DELETE http://localhost/user/2</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">###</span><br><span class="line"></span><br><span class="line">PUT http://localhost/user/1</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">{</span><br><span class="line">  "id": "10",</span><br><span class="line">  "name": "得理不饶人",</span><br><span class="line">  "birthday": "2010-10-11",</span><br><span class="line">  "salary": "101,100.22"</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="ajax-与-Restful-联合"><a href="#ajax-与-Restful-联合" class="headerlink" title="ajax 与 Restful 联合"></a>ajax 与 Restful 联合</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">$.ajax( {</span><br><span class="line">type : "GET",</span><br><span class="line">url : "http://localhost:8080/springmvc/user/rest/1",</span><br><span class="line">dataType : "json",</span><br><span class="line">success : function(data) {</span><br><span class="line">console.log("get请求！---------------------")</span><br><span class="line">console.log(data)</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">$.ajax( {</span><br><span class="line">type : "DELETE",</span><br><span class="line">url : "http://localhost:8080/springmvc/user/rest/1",</span><br><span class="line">dataType : "json",</span><br><span class="line">success : function(data) {</span><br><span class="line">console.log("delete请求！---------------------")</span><br><span class="line">console.log(data)</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">$.ajax( {</span><br><span class="line">type : "put",</span><br><span class="line">url : "http://localhost:8080/springmvc/user/rest/1",</span><br><span class="line">dataType : "json",</span><br><span class="line">data: {id:12,username:"楠哥",password:"123"},</span><br><span class="line">success : function(data) {</span><br><span class="line">console.log("get请求！---------------------")</span><br><span class="line">console.log(data)</span><br><span class="line">}</span><br><span class="line">});</span><br><span class="line">$.ajax( {</span><br><span class="line">    type : "post",</span><br><span class="line">    url : "http://localhost:8080/springmvc/user/rest",</span><br><span class="line">    dataType : "json",</span><br><span class="line">    data: {id:12,username:"楠哥",password:"123"},</span><br><span class="line">    success : function(data) {</span><br><span class="line">    console.log("get请求！---------------------")</span><br><span class="line">    console.log(data)</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>拦截器的拦截流程（多个拦截器情况）</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/0918-lanjie.jpg" alt="image-20200917092928906"></p><p>preHandle 方法有放行功能，其余两个拦截器只要perHandle 放行就会执行；</p><h3 id="写一个登录拦截器"><a href="#写一个登录拦截器" class="headerlink" title="写一个登录拦截器"></a>写一个登录拦截器</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">创建拦截器类，实现 HandlerInterceptor 接口</span><br><span class="line">public class LoginInterceptor implements HandlerInterceptor {</span><br><span class="line">    /**</span><br><span class="line">    在执行Controller方法前拦截，判断用户是否已经登录，</span><br><span class="line">    登录了就放行，还没登录就重定向到登录页面</span><br><span class="line">    */</span><br><span class="line">    @Override</span><br><span class="line">    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler) {</span><br><span class="line">        HttpSession session = request.getSession();</span><br><span class="line">        User user = session.getAttribute("user");</span><br><span class="line">        if (user == null){</span><br><span class="line">        //还没登录，重定向到登录页面</span><br><span class="line">        response.sendRedirect("/toLogin");</span><br><span class="line">        }else {</span><br><span class="line">        //已经登录，放行</span><br><span class="line">        return true;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    @Override</span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response,Object handler, ModelAndView modelAndView) {}</span><br><span class="line">    @Override</span><br><span class="line">    public void afterCompletion(HttpServletRequest request, HttpServletResponseresponse, Object handler, Exception ex) {}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">配置spring.xml文件</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;!--mvc:mapping：拦截的路径</span><br><span class="line">        /**：是指所有文件夹及其子孙文件夹</span><br><span class="line">        /*：是指所有文件夹，但不包含子孙文件夹</span><br><span class="line">        /：Web项目的根目录--&gt;</span><br><span class="line">    &lt;mvc:mapping path="/**"/&gt;</span><br><span class="line">        &lt;!--mvc:exclude-mapping：不拦截的路径,不拦截登录路径</span><br><span class="line">        /toLogin：跳转到登录页面</span><br><span class="line">        /login：登录操作  --&gt;</span><br><span class="line">        &lt;mvc:exclude-mapping path="/toLogin"/&gt;</span><br><span class="line">        &lt;mvc:exclude-mapping path="/login"/&gt;</span><br><span class="line">        &lt;!--class属性就是我们自定义的拦截器--&gt;</span><br><span class="line">        &lt;bean id="loginInterceptor"</span><br><span class="line">        class="com.kaikeba.interceptor.LoginInterceptor"/&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></tbody></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="设置访问静态资源"><a href="#设置访问静态资源" class="headerlink" title="设置访问静态资源"></a>设置访问静态资源</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">方法一：修改映射地址</span><br><span class="line">&lt;mvc:resources mapping="/img/**" location="/images/" &gt;&lt;/mvc:resources&gt;</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">&lt;mvc:default-servlet-handler&gt;&lt;/mvc:default-servlet-handler&gt;</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 核心框架篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM框架 </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring 入门</title>
      <link href="/posts/14131.html"/>
      <url>/posts/14131.html</url>
      
        <content type="html"><![CDATA[<h1 id="初学Spring"><a href="#初学Spring" class="headerlink" title="初学Spring"></a>初学Spring</h1><p>spring 目的： 实现代码业务逻辑层与其它层的松耦合；</p><h2 id="Spring-特点"><a href="#Spring-特点" class="headerlink" title="Spring 特点"></a>Spring 特点</h2><ol><li><strong>方便解耦，简化开发</strong></li></ol><p>Spring 提供了IOC 容器 （Inverse of Control 控制反转） ，IoC是一种设计思想， <strong>指的是将原本在程序中手动创建对象的控制权，交由Spring框架来管理</strong>，IOC容器就是Spring 用来实现IOC的载体。有了IOC容器，<strong>我们可以将对象之间的依赖关系交由Spring进行控制，避免硬编码所造成的过度程序耦合</strong>。有了Spring，用户不必再为单实例模式类、属性文件解析等这些很底层的需求编写代<br>码，可以更专注于上层的应用。</p><ol start="2"><li><strong>AOP 编程的支持</strong> ，面向切面编程有助于简化传统OOP实现的功能</li><li><strong>声明式事务的支持</strong>，Spring 将事务剥离出来，方便对于事务的管理</li><li><strong>方便程序的测试</strong> ，自身带有测试功能，同时也有Junit4</li><li><strong>方便集成各种优秀框架</strong>，Spring可以降低各种框架的使用难度，Spring提供了对各种优秀框架(如Struts,Hibernate、Hessian、Quartz)等的直接支持。</li><li><strong>降低Java EE API的使用难度</strong>：对一些EE 的API 进行了封装，更方便用户使用</li></ol><h2 id="Spring-组成"><a href="#Spring-组成" class="headerlink" title="Spring 组成"></a>Spring 组成</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200907163644319.png" alt="image-20200907163644319"></p><ul><li><strong>Spring Core：</strong> 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。</li><li><strong>Spring  Aspects</strong> ： 该模块为与AspectJ的集成提供支持。</li><li><strong>Spring AOP</strong> ：提供了面向切面的编程实现。</li><li><strong>Spring JDBC</strong> : Java数据库连接。</li><li><strong>Spring JMS</strong> ：Java消息服务。</li><li><strong>Spring ORM</strong> : 用于支持Hibernate等ORM工具。</li><li><strong>Spring Web</strong> : 为创建Web应用程序提供支持。</li><li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li></ul><h2 id="Spring-IOC-解读"><a href="#Spring-IOC-解读" class="headerlink" title="Spring IOC 解读"></a>Spring IOC 解读</h2><p>IOC是 Inverse of Control 的简写，意思是控制反转。是降低对象之间的耦合关系的设计思想。</p><p>DI是Dependency Injection的缩写，意思是依赖注入，说的是创建对象实例时，同时为这个对象注入它所依赖的属性</p><h3 id="代码演示："><a href="#代码演示：" class="headerlink" title="代码演示："></a>代码演示：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. 创建 bean dao service 层的相关数据</span><br><span class="line"></span><br><span class="line">2. 加载spring依赖包</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">        &lt;!-- Spring的核心工具包--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-core&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--在基础IOC功能上提供扩展服务，还提供许多企业级服务的支持，有邮件服务、</span><br><span class="line">        任务调度、远程访问、缓存以及多种视图层框架的支持--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- Spring IOC的基础实现，包含访问配置文件、创建和管理bean等 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- Spring context的扩展支持，用于MVC方面 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!-- Spring表达式语言 --&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    </span><br><span class="line">3. 在 java 下的 resource 文件夹下创建 application.xml 配置文件，添加头信息</span><br><span class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="line">&lt;beans xmlns="http://www.springframework.org/schema/beans"</span><br><span class="line">       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"</span><br><span class="line">       xsi:schemaLocation="http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br><span class="line"></span><br><span class="line">4. 配置文件中 添加需要的bean信息</span><br><span class="line">&lt;bean id="udao" class="com.kaikeba.dao.impl.UserDaoImpl"&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id="uservice" class="com.kaikeba.service.UserService"&gt;</span><br><span class="line">    &lt;!-- 注意，添加属性需要创建set方法 --&gt;</span><br><span class="line">        &lt;property name="userDao" ref="udao"&gt;&lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">说明：添加信息后可以通过spring 方法进行对象获取，不需要 new 实例；</span><br><span class="line"></span><br><span class="line">5. 获取对象</span><br><span class="line">// 从配置文件中得到对象</span><br><span class="line">        // 1. 加载配置文件</span><br><span class="line">        ApplicationContext app = new ClassPathXmlApplicationContext("application.xml");</span><br><span class="line">        // 2. 用 getBean方法通过添加的id 值来获取对应对象</span><br><span class="line">        UserService uservice = (UserService)app.getBean("uservice");</span><br><span class="line">        uservice.insert();</span><br></pre></td></tr></tbody></table></figure><h3 id="bean-标签"><a href="#bean-标签" class="headerlink" title="bean 标签"></a>bean 标签</h3><table><thead><tr><th align="center">属性</th><th>说明</th></tr></thead><tbody><tr><td align="center">id</td><td>id是bean对象的唯一标识,不能添加特别字符</td></tr><tr><td align="center">name</td><td>name是bean对应对象的一个标识（可以重复）</td></tr><tr><td align="center">class</td><td>指定bean对应类的全路径 （com.kaikeba…）</td></tr><tr><td align="center">scope</td><td>scope=”singleton”和scope=”prototype” 对应 单例创建和非单例创建（地址信息不同）</td></tr><tr><td align="center">lazy-init</td><td>false 不延时加载，加载配置文件时就加载对象，true 延时加载，调用对象时再加载</td></tr><tr><td align="center">init-method</td><td>对象创建时调取的方法</td></tr><tr><td align="center">destroy-method</td><td>对象销毁时调取的方法</td></tr></tbody></table><h3 id="有参构造与无参构造"><a href="#有参构造与无参构造" class="headerlink" title="有参构造与无参构造"></a>有参构造与无参构造</h3><p>注：参数是对象，用ref 赋值，参数是非对象，用value 赋值；</p><p>构造器会根据constructor-arg 传入的参数自动选择构造函数，没有对应的构造方法会报错</p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name , Car car)</span></span>{</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">System.out.println(<span class="string">"Person的有参构造方法:"</span>+name+car);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">&lt;bean name=<span class="string">"person"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xzk.spring.bean.Person"</span>&gt;</span><br><span class="line">&lt;constructor-arg name=<span class="string">"name"</span> value=<span class="string">"rose"</span>/&gt;</span><br><span class="line">&lt;constructor-arg name=<span class="string">"car"</span> ref=<span class="string">"car"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>调取静态方法</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 通过User 的静态方法创建 Student 对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Student <span class="title">createStudent</span><span class="params">()</span></span>{</span><br><span class="line">System.out.println(<span class="string">"静态工厂创建Student"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Student();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">&lt;bean name=<span class="string">"u3"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kaikeba.bean.User"</span> factory-method=<span class="string">"createStudent"</span> /&gt;</span><br></pre></td></tr></tbody></table></figure><p><strong>调取非静态方法</strong></p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//  通过Student 的非静态方法创建 User 对象</span></span><br><span class="line">&lt;bean name="s1" class="com.kaikeba.bean.Student" &gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean name="su" factory-bean="s1" factory-method="getUser"&gt;&lt;/bean&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200907214307727.png" alt="image"></p><p>Bean 生命周期的整个执行过程描述如下：</p><p>1）根据配置情况调用 Bean 构造方法或工厂方法实例化 Bean。</p><p>2）利用依赖注入完成 Bean 中所有属性值的配置注入。</p><p>3）如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前Bean 的 id 值。</p><p>4）如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。</p><p>5）如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。</p><p>6）如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。</p><p>7）如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。初始化bean的时候执行，可以针对某个具体的bean进行配置。afterPropertiesSet 必须实现 InitializingBean接口。实现 InitializingBean接口必须实现afterPropertiesSet方法。</p><p>8）如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。</p><p>9）如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。</p><p>10）如果在 中指定了该 Bean 的作用范围为 scope=”singleton”，则将该 Bean 放入 Spring IoC 的缓存池中，将触发 Spring 对该 Bean 的生命周期管理；如果在 中指定了该 Bean 的作用范围为scope=”prototype”，则将该 Bean 交给调用者，调用者管理该 Bean 的生命周期，Spring 不再管理该Bean。</p><p>11）如果 Bean 实现了 DisposableBean 接口，则 Spring 会调用 destory() 方法将 Spring 中的 Bean销毁；如果在配置文件中通过 destory-method 属性指定了 Bean 的销毁方法，则 Spring 将调用该方法对 Bean 进行销毁。</p><p>看一个博客：<a href="https://www.cnblogs.com/zrtqsk/p/3735273.html" target="_blank" rel="noopener">https://www.cnblogs.com/zrtqsk/p/3735273.html</a></p><h3 id="DI-属性注入"><a href="#DI-属性注入" class="headerlink" title="DI 属性注入"></a>DI 属性注入</h3><p>分类:一种是调取属性的set方法赋值，第二种使用构造方法赋值</p><ol><li>调取 set 方法注入 ，也就是<code>&lt;property name="addressInfo" value="南二环"/&gt;</code> 添加属性值用的就是set 注入</li><li>构造方法注入</li><li>#{stu.sname} 得到值 ，得到stu 这个bean 的 sname 属性值</li><li>p 标签 赋值，p: name= p: age=  ,也就相当于 <code>&lt;property name="name" value="??"</code></li><li>复杂类型值的注入</li></ol><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">创建 User类 </span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">//爱好</span></span><br><span class="line">    <span class="keyword">private</span> String[] hobbies;</span><br><span class="line">    <span class="comment">//职务</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; duties;</span><br><span class="line">    <span class="comment">//家庭关系</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; familyTies;</span><br><span class="line">    <span class="comment">//购物车商品</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; carts;</span><br><span class="line">    <span class="comment">//工作经历</span></span><br><span class="line">    <span class="keyword">private</span> Properties workExperience;</span><br><span class="line">    <span class="comment">//女儿</span></span><br><span class="line">    <span class="keyword">private</span> String daughter;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">XML赋值</span><br><span class="line">    &lt;bean id=<span class="string">"address"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kaikeba.bean.Address"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"addressInfo"</span> value=<span class="string">"南二环"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"user"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.kaikeba.bean.User"</span> autowire=<span class="string">"byName"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"name"</span>&gt;</span><br><span class="line">            &lt;value&gt;张三&lt;/value&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;!-- 这里通过自动装配 autowire可以自动赋值--&gt;</span><br><span class="line">        &lt;!--&lt;property name=<span class="string">"address"</span>&gt;</span><br><span class="line">            &lt;ref bean=<span class="string">"address"</span>/&gt;</span><br><span class="line">        &lt;/property&gt;--&gt;</span><br><span class="line">        &lt;property name=<span class="string">"hobbies"</span>&gt;</span><br><span class="line">            &lt;array&gt;</span><br><span class="line">                &lt;value&gt;打乒乓球&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;打篮球&lt;/value&gt;</span><br><span class="line">            &lt;/array&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"duties"</span>&gt;</span><br><span class="line">            &lt;list&gt;</span><br><span class="line">                &lt;value&gt;工程师&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;大队长&lt;/value&gt;</span><br><span class="line">            &lt;/list&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"familyTies"</span>&gt;</span><br><span class="line">            &lt;map&gt;</span><br><span class="line">                &lt;entry key=<span class="string">"妻子"</span> value=<span class="string">"GF"</span>/&gt;</span><br><span class="line">                &lt;entry key=<span class="string">"爸爸"</span> value=<span class="string">"HYF"</span>/&gt;</span><br><span class="line">                &lt;entry key=<span class="string">"妈妈"</span> value=<span class="string">"WSM"</span>/&gt;</span><br><span class="line">            &lt;/map&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"carts"</span>&gt;</span><br><span class="line">            &lt;set&gt;</span><br><span class="line">                &lt;value&gt;外星人电脑&lt;/value&gt;</span><br><span class="line">                &lt;value&gt;雅诗兰黛补水套装&lt;/value&gt;</span><br><span class="line">            &lt;/set&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"workExperience"</span>&gt;</span><br><span class="line">            &lt;props&gt;</span><br><span class="line">                &lt;prop key="2018-2020"&gt; 机械工程师&lt;/prop&gt;</span><br><span class="line">                &lt;prop key="2020至今"&gt; 开发工程师&lt;/prop&gt;</span><br><span class="line">            &lt;/props&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">        &lt;property name=<span class="string">"daughter"</span>&gt;</span><br><span class="line">            &lt;<span class="keyword">null</span>/&gt;</span><br><span class="line">        &lt;/property&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h3><ol><li>根据 id  名称对应的 bean 自动注入：autowire = “byName” </li><li>根据  bean 的type自动注入：autowire = “byType”  ，注意这种方式假如有多个相同type会导致自动注入失败</li></ol><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">&lt;bean id="address" class="com.kaikeba.bean.Address"&gt;</span><br><span class="line">       &lt;property name="addressInfo" value="南二环"/&gt;</span><br><span class="line">   &lt;/bean&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;bean id="user" class="com.kaikeba.bean.User" autowire="byName"&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="注解注入"><a href="#注解注入" class="headerlink" title="注解注入"></a>注解注入</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">头信息中加入</span><br><span class="line">xmlns:context="http://www.springframework.org/schema/context"</span><br><span class="line">http://www.springframework.org/schema/context</span><br><span class="line">https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line"></span><br><span class="line">添加扫描信息：</span><br><span class="line">&lt;context:component-scan base-package="com.kaikeba"/&gt;</span><br><span class="line"></span><br><span class="line">有这个扫描后 会自动扫描类中的注解 类前加上如下注解即可通过 getBean("引用名称") 来调取对象</span><br><span class="line">@Component("引用名称") 不写或默认为类名（引用名称的头字母会变成小写 ，小驼峰的命名形式 比如 UserDao -&gt; userDao）</span><br><span class="line">@Service("引用名称") // service层</span><br><span class="line">@Controller("引用名称") // controller层</span><br><span class="line">@Repository("引用名称") // dao层</span><br><span class="line"></span><br><span class="line">类属性注解：</span><br><span class="line">@Value("属性值")</span><br><span class="line">private String name;</span><br><span class="line"></span><br><span class="line">@Autowired // 自动注入</span><br><span class="line">@Qualifier("bean name") // 用于有多个 Bean对象</span><br><span class="line">private Car car;</span><br><span class="line"></span><br><span class="line">@Resource(name = "bean name") // 等价于上面的两行代码  javax.annocation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Scope(scopeName="singleton") //单例对象(默认)</span><br><span class="line">@Scope(scopeName="prototype") //多例对象</span><br><span class="line"></span><br><span class="line">init / destory 方法</span><br><span class="line">@PostConstruct //等价于init-method属性</span><br><span class="line">public void init(){</span><br><span class="line">System.out.println("初始化方法");</span><br><span class="line">}</span><br><span class="line">@PreDestroy //等价于destroy-method属性</span><br><span class="line">public void destroy(){</span><br><span class="line">System.out.println("销毁方法");</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">通过配置文件加入Bean</span><br><span class="line">@Configuration // 如下的Bean 可以实例化，用于引出一些Jar包内的类</span><br><span class="line">public class AnimalConfig {</span><br><span class="line">@Bean</span><br><span class="line">public Mouse mouse(){</span><br><span class="line">Mouse mouse = new Mouse();</span><br><span class="line">mouse.setAge(12);</span><br><span class="line">mouse.setName("jerry");</span><br><span class="line">return mouse;</span><br><span class="line">}</span><br><span class="line">//参数是你要注入的其他的bean</span><br><span class="line">@Bean</span><br><span class="line">public Cat cat(Mouse mouse){</span><br><span class="line">Cat cat = new Cat();</span><br><span class="line">cat.setAge(5);</span><br><span class="line">cat.setName("Tom");</span><br><span class="line">cat.setFood(mouse);</span><br><span class="line">return cat;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="AOP-实现机制"><a href="#AOP-实现机制" class="headerlink" title="AOP 实现机制"></a>AOP 实现机制</h2><ul><li>AOP（Aspect Oriented Programming）称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如<strong>日志，事务，权限</strong>等；</li><li>主要功能：在不改变原有的逻辑的基础上，增加一些额外的功能。类似于代理</li></ul><p>动态代理</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200908220753450.png" alt="image-20200908220753450"></p><h3 id="说一说静态代理与动态代理"><a href="#说一说静态代理与动态代理" class="headerlink" title="说一说静态代理与动态代理"></a>说一说静态代理与动态代理</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">静态代理</span><br><span class="line"></span><br><span class="line">静态代理就是在不修改源代码的情况下，将原有的方法进行手动扩展，将原有方法进行增强</span><br><span class="line">实际上就是继承实现类的接口，代理(<span class="keyword">new</span>)一个实现类，通过重写原接口的方法来增强实现类的方法</span><br><span class="line"></span><br><span class="line">动态代理(两种实现 JDK / Cglib)</span><br><span class="line"></span><br><span class="line">JDK 实现</span><br><span class="line">实现InvocationHandler 接口，重写invoke 方法，invoke 方法得到的是原类的所有方法及参数，在 method.invoke 前后添加需要添加的信息，基本实现代码如下</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只要是继承自接口的实现类，都可以通过此代理进行方法 target 是目标类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AgentAll</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span></span>{</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        System.out.println(<span class="string">"------------代理开始日志---------"</span>);</span><br><span class="line">        Object invoke = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"------------代理结束日志---------"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>{ <span class="comment">// 这里的到的是代理的返回，需要强转成需要的实体类对象</span></span><br><span class="line">        Object o = Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                                          target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">Cglib 实现</span><br><span class="line">    </span><br><span class="line">    说明：这里直接用匿名内部类实现了，接口类应该是MethodInterceptor，但传不进去方法</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 主要是创建Enhancer 这个增强类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        enhancer.setSuperclass(MaleActor<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 调用回调函数增强</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> InvocationHandler() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object o, Method method, Object[] objects)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">                System.out.println(<span class="string">"========大碗宽面开始========"</span>);</span><br><span class="line">                Object invoke = method.invoke(<span class="keyword">new</span> MaleActor(<span class="string">"吴亦凡"</span>), objects);</span><br><span class="line">                System.out.println(<span class="string">"========大碗宽面结束========"</span>);</span><br><span class="line">                <span class="keyword">return</span> invoke;</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        MaleActor ma = (MaleActor)enhancer.create();</span><br><span class="line">        ma.work();</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h3 id="和AOP相关的名词："><a href="#和AOP相关的名词：" class="headerlink" title="和AOP相关的名词："></a>和AOP相关的名词：</h3><blockquote><p><strong>通知、增强处理（Advice）</strong></p></blockquote><p>通知、增强处理（Advice） 就是你想要的功能，也就是上说的安全、事物、日子等。你给先定义好，然后再想用的地方用一下。包含Aspect的一段处理代码</p><blockquote><p><strong>连接点（JoinPoint）</strong></p></blockquote><p>连接点（JoinPoint） 这个就更好解释了，就是spring允许你是通知（Advice）的地方，那可就真多了，基本每个方法的钱、后（两者都有也行），或抛出异常是时都可以是连接点，spring只支持方法连接点。其他如AspectJ还可以让你在构造器或属性注入时都行，不过那不是咱们关注的，只要记住，和方法有关的前前后后都是连接点。</p><blockquote><p><strong>切入点（Pointcut）</strong></p></blockquote><p>切入点（Pointcut） 上面说的连接点的基础上，来定义切入点，你的一个类里，有15个方法，那就有十几个连接点了对吧，但是你并不想在所有方法附件都使用通知（使用叫织入，下面再说），你只是想让其中几个，在调用这几个方法之前、之后或者抛出异常时干点什么，那么就用切入点来定义这几个方法，让切点来筛选连接点，选中那几个你想要的方法。</p><blockquote><p><strong>切面（Aspect）</strong></p></blockquote><p>切面（Aspect） 切面是通知和切入点的结合。现在发现了吧，没连接点什么事，链接点就是为了让你好理解切点搞出来的，明白这个概念就行了。通知说明了干什么和什么时候干（什么时候通过方法名中的befor，after，around等就能知道），二切入点说明了在哪干（指定到底是哪个方法），这就是一个完整的切面定义。</p><blockquote><p><strong>引入（introduction）</strong></p></blockquote><p>引入（introduction） 允许我们向现有的类添加新方法属性。这不就是把切面（也就是新方法属性：通知定义的）用到目标类中吗？</p><blockquote><p><strong>目标（target）</strong></p></blockquote><p>目标（target） 引入中所提到的目标类，也就是要被通知的对象，也就是真正的业务逻辑，他可以在毫不知情的情况下，被咋们织入切面。二自己专注于业务本身的逻辑。</p><blockquote><p><strong>织入（weaving）</strong></p></blockquote><p>织入（weaving） 把切面应用到目标对象来创建新的代理对象的过程</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200909131535830.png" alt="image-20200909131535830"></p><h3 id="AOP-实现"><a href="#AOP-实现" class="headerlink" title="AOP 实现"></a>AOP 实现</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 添加AOP织入依赖、 其余的之前添加过</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.9.4&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 配置头信息</span><br><span class="line">xmlns:aop=<span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/aop</span></span><br><span class="line">http:<span class="comment">//www.springframework.org/schema/aop/spring-aop-4.2.xsd</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 创建 advice 方法类，自定义before / after....方法</span><br><span class="line"></span><br><span class="line">注解实现：</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceInfo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="comment">//配置切入点 方法任意 也可以在每个方法前面加上execution(* com.xzk.service.impl.*.*(..))</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.xzk.service.impl.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>{}</span><br><span class="line"></span><br><span class="line">    <span class="comment">//springAop 自动的 5种 aop 这里全部列出</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"aa()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"---------方法执行前before()---------"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"aa()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"---------方法执行后after()---------"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"aa()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"---------方法返回后afterReturning()---------"</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"aa()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        System.out.println(<span class="string">"-------环绕前-------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"签名（拿到方法名）:"</span> + jp.getSignature());</span><br><span class="line">        <span class="comment">//执行目标方法proceed</span></span><br><span class="line">        Object proceed = jp.proceed();</span><br><span class="line">        System.out.println(<span class="string">"-------环绕后------"</span>);</span><br><span class="line">        System.out.println(proceed);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"aa()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrow</span><span class="params">()</span> </span>{</span><br><span class="line">        System.out.println(<span class="string">"--------------有异常发生-----------------"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">配置文件信息：</span><br><span class="line">    添加完相应 context 头信息后，加入下面两行代码搞定</span><br><span class="line">    </span><br><span class="line">    &lt;context:component-scan base-<span class="keyword">package</span>=<span class="string">"com.xzk"</span>/&gt;</span><br><span class="line">    &lt;aop:aspectj-autoproxy/&gt;</span><br><span class="line"></span><br><span class="line">XML 配置文件实现AOP 前提需要</span><br><span class="line">        &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:pointcut id=<span class="string">"mypc"</span> expression=<span class="string">"execution(* com.kaikeba.service.*.*(..))"</span>/&gt;</span><br><span class="line">        &lt;aop:aspect ref=<span class="string">"myaop"</span>&gt;</span><br><span class="line">            &lt;aop:before method=<span class="string">"before"</span> pointcut-ref=<span class="string">"mypc"</span>/&gt;</span><br><span class="line">            &lt;aop:after-returning method=<span class="string">"afterRun"</span> pointcut-ref=<span class="string">"mypc"</span>/&gt;</span><br><span class="line">            &lt;aop:around method=<span class="string">"around"</span> pointcut-ref=<span class="string">"mypc"</span>/&gt;</span><br><span class="line">            &lt;aop:after-throwing method=<span class="string">"ex"</span> pointcut-ref=<span class="string">"mypc"</span>/&gt;</span><br><span class="line">            &lt;aop:after method=<span class="string">"after"</span> pointcut-ref=<span class="string">"mypc"</span>/&gt;</span><br><span class="line">        &lt;/aop:aspect&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:config&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">"after"</span> pointcut-ref=<span class="string">"mypc"</span>/&gt;</span><br><span class="line">        &lt;aop:advisor advice-ref=<span class="string">"before"</span> pointcut-ref=<span class="string">"mypc"</span>/&gt;</span><br><span class="line">    &lt;/aop:config&gt;</span><br><span class="line"></span><br><span class="line">名词解释：</span><br><span class="line">aop:config    aop配置信息</span><br><span class="line">aop:pointcut  aop 切入点</span><br><span class="line">aop:aspect  aop切面，也就是将增强方法切入到切入点</span><br><span class="line"></span><br><span class="line">    aspect下的<span class="number">5</span>个切面方法</span><br><span class="line">        aop:before  方法前增强</span><br><span class="line">        aop:after-returning方法返回后增强，如果异常则不增强</span><br><span class="line">aop:around方法环绕增强，在before后，在after前</span><br><span class="line">        aop:after方法执行后 有没有异常都增强</span><br><span class="line">        aop:after-throwing 遇到异常后执行</span><br><span class="line">实现接口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">总的加载顺序：</span><br><span class="line"></span><br><span class="line">加载了 Set方法</span><br><span class="line">这是方法前执行</span><br><span class="line">环绕增强开始</span><br><span class="line">===========这是增强before=============</span><br><span class="line">加载了 Set方法</span><br><span class="line">===========这是增强after=============</span><br><span class="line">这是方法后执行</span><br><span class="line">环绕增强结束</span><br><span class="line">这是方法返回后执行</span><br><span class="line">===============上面是没有异常的================</span><br><span class="line">这是方法前执行</span><br><span class="line">环绕增强开始</span><br><span class="line">===========这是增强before=============</span><br><span class="line">这是方法后执行</span><br><span class="line">异常执行</span><br><span class="line">环绕增强结束</span><br><span class="line">这是方法返回后执行</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200909183315015.png" alt="image-20200909183315015"></p><h2 id="Spring-JDBC-连接数据库"><a href="#Spring-JDBC-连接数据库" class="headerlink" title="Spring JDBC 连接数据库"></a>Spring JDBC 连接数据库</h2><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 导入依赖</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;8.0.21&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;c3p0&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;c3p0&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.9.1.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.0.8.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        </span><br><span class="line"><span class="number">2</span>. 通过Java代码实现</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> PropertyVetoException </span>{</span><br><span class="line">        <span class="comment">// 连接数据库</span></span><br><span class="line">        ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        dataSource.setDriverClass(<span class="string">"com.mysql.cj.jdbc.Driver"</span>);</span><br><span class="line">        dataSource.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test?&amp;useSSL=false&amp;serverTimezone=UTC"</span>);</span><br><span class="line">        dataSource.setUser(<span class="string">"root"</span>);</span><br><span class="line">        dataSource.setPassword(<span class="string">"960315"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建jdbcTemplate 对象</span></span><br><span class="line">        JdbcTemplate jdbcTemplate = <span class="keyword">new</span> JdbcTemplate(dataSource);</span><br><span class="line"></span><br><span class="line">        String sql = <span class="string">"INSERT INTO EMPLOYEE VALUE(?,?,?,?)"</span>;</span><br><span class="line">        <span class="keyword">int</span> update = jdbcTemplate.update(sql, <span class="number">1</span>, <span class="string">"张三"</span>, <span class="string">"刺客"</span>, <span class="string">"5000"</span>);</span><br><span class="line">        System.out.println(update);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 通过Spring 配置文件实现</span><br><span class="line">&lt;bean id=<span class="string">"dataSource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"jdbcUrl"</span> value=<span class="string">"jdbc:mysql://localhost:3306/test?  useSSL=false&amp;amp;serverTimezone=UTC"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"driverClass"</span> value=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"user"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"password"</span> value=<span class="string">"960315"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;bean id=<span class="string">"jdbcTem"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"dataSource"</span> ref=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">4</span>. 通过properties文件注入 注意 username 读取问题，Fallback 为覆盖系统的username</span><br><span class="line">        &lt;context:property-placeholder location=<span class="string">"classpath:druid.properties"</span> system-properties-mode=<span class="string">"FALLBACK"</span>/&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"dataSource"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"jdbcUrl"</span> value=<span class="string">"${url}"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"driverClass"</span> value=<span class="string">"${driverClassName}"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"user"</span> value=<span class="string">"${username}"</span>/&gt;</span><br><span class="line">        &lt;property name=<span class="string">"password"</span> value=<span class="string">"${password}"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">获取单行数据</span><br><span class="line">    String sql = <span class="string">"SELECT * FROM EMPLOYEE WHERE ID = ?"</span>;</span><br><span class="line">User user = jdbcTem.queryForObject(sql, <span class="keyword">new</span> Object[]{<span class="number">1002</span>}, <span class="keyword">new</span> RowMapper&lt;User&gt;() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User(resultSet.getInt(<span class="string">"id"</span>), resultSet.getString(<span class="string">"name"</span>)</span><br><span class="line">                        , resultSet.getString(<span class="string">"job"</span>), resultSet.getDouble(<span class="string">"hurt"</span>));</span><br><span class="line">    }</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">获取多行数据</span><br><span class="line">    List&lt;User&gt; list = jdbcTem.query(sql, <span class="keyword">new</span> RowMapper&lt;User&gt;() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> User(resultSet.getInt(<span class="string">"id"</span>), resultSet.getString(<span class="string">"name"</span>)</span><br><span class="line">                        , resultSet.getString(<span class="string">"job"</span>), resultSet.getDouble(<span class="string">"hurt"</span>));</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">for</span> (User user : list) {</span><br><span class="line">            System.out.println(user);</span><br><span class="line">        }</span><br></pre></td></tr></tbody></table></figure><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. 配置数据源 因为spring 根据数据源会进行不同的事务操作</span><br><span class="line"></span><br><span class="line">&lt;bean id="manager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;</span><br><span class="line">&lt;property name="dataSource" ref="dataSource"/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">2. 添加tx命名空间</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">3. 配置文件实现 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4. 注解实现</span><br><span class="line">&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;</span><br><span class="line">    </span><br><span class="line">在方法前面添加 @Transactional</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200909213901167.png" alt="image-20200909213901167"></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200909213849714.png" alt="image-20200909213849714"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 核心框架篇 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSM框架 </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis入门</title>
      <link href="/posts/52715.html"/>
      <url>/posts/52715.html</url>
      
        <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>NoSql的特点： 高并发 高可用 易扩展 高效存储</p><p>常见的 Nosql 产品：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200905092622573.png" alt="image-20200905092622573"></p><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>Redis 全称：REmote DIctionary Server（远程字典服务器）。用C语言编写的，完全开源免费，它遵守BCD协议。是一个高性能的(key/value)<strong>分布式内存数据库</strong>；</p><p>Redis 的优势：</p><p>(1) <strong>性能极高</strong> – Redis能读的速度是110000次/s,写的速度是81000次/s 。</p><p>(2) <strong>丰富的数据类型</strong> – Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</p><p>(3) <strong>原子</strong> – Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</p><p>(4) <strong>丰富的特性</strong> – Redis还支持 publish/subscribe, 通知, key 过期等等特性</p><p>(5) <strong>采用单线程</strong>，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；</p><p>(6) 使用多路I/O复用模型，<strong>非阻塞IO</strong>(NIO) </p><h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><p>Redis下载    <a href="Http://www.redis.cn/">码云下载</a></p><p>Redis 配置C++ 环境：yum -y install gcc-c++</p><p>创建目录 然后传入文件 redis-5.0.5.tar.gz</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">我创建的目录是 /home/redis</span><br><span class="line"></span><br><span class="line">到 redis 目录， 解压</span><br><span class="line">[root@localhost redis]# tar -zxvf redis-5.0.5.tar.gz</span><br><span class="line"></span><br><span class="line">进入 redis-5.0.5 目录 然后编译,将.c文件编译为.o文件</span><br><span class="line">[root@localhost redis]# cd redis-5.0.5</span><br><span class="line">[root@localhost redis-5.0.5]# make</span><br><span class="line"></span><br><span class="line">安装</span><br><span class="line">[root@localhost redis-5.0.5]make PREFIX=/home/redis install</span><br><span class="line">安装完成后会出现一个 bin 文件夹 进入文件夹ll 会看到如下命令</span><br><span class="line"></span><br><span class="line">redis -benchmark--性能测试工具</span><br><span class="line">redis-check-aof --AOF 文件修复工具</span><br><span class="line">redis-check-rdb--RDB 文件检查工具 （持久化策略需要）</span><br><span class="line">redis-cli--命令行客户端</span><br><span class="line">redis-server--redis 服务器启动</span><br><span class="line"></span><br><span class="line">前端启动 直接在bin文件夹下 ./redis-server</span><br><span class="line"></span><br><span class="line">后端启动需要redis.conf 文件</span><br><span class="line">copy conf文件到redis文件夹下 cp redis.conf /home/redis</span><br><span class="line">修改conf文件</span><br><span class="line">vim redis.conf</span><br><span class="line">到daemonize 下 将no 改为yes 即可通过后端启动</span><br><span class="line">启动命令：[root@localhost redis]# ./bin/redis-server ./redis.conf</span><br><span class="line">用 ps aux | grep redis 查看是否启动成功 </span><br><span class="line"></span><br><span class="line">配置redis 图形化软件</span><br><span class="line">1. 关闭linux 防火墙</span><br><span class="line">2. conf 配置 bind 用户IP 修改成当前lunux 对应的ip  </span><br><span class="line"></span><br><span class="line">进入客户端</span><br><span class="line">[root@localhost redis]# ./bin/redis-cli (需要在服务启动的情况下)</span><br><span class="line">进入后会显示IP + 端口号的形式,如 127.0.0.1:6379&gt;  </span><br><span class="line">如果配置了IP 需要用./bin/redis-cli -h IP号 的形式进入</span><br><span class="line">关闭服务器 在进入端口的前提下 输入shutdown即可关闭对应ip的redis服务器</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200905101058955.png" alt="image-20200905101058955"></p><p><strong>连接—关闭—查看</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200905113600571.png" alt="image-20200905113600571"></p><h2 id="Redis常用数据结构"><a href="#Redis常用数据结构" class="headerlink" title="Redis常用数据结构"></a>Redis常用数据结构</h2><p>Redis是一种基于内存的数据库，并且提供一定的持久化功能，它是一种键值（key-value）数据库，使用 key 作为索引找到当前缓存的数据，并且返回给程序调用者。</p><p>当前的 Redis 支持 6 种数据类型，它们分别是字符串（String）、列表（List）、集合（set）、哈希结构（hash）、有序集合（zset）和基数（HyperLogLog）</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200905113750983.png" alt="image-20200905113750983"></p><h2 id="Redis常用指令"><a href="#Redis常用指令" class="headerlink" title="Redis常用指令"></a>Redis常用指令</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>set 键 值</p><p>get 键</p><p>mset 键 值 键 值 键 值…</p><p>mget 键 键 键…     没有值则返回 nil </p><p>DEL key</p><h4 id="字符串数字的递增递减"><a href="#字符串数字的递增递减" class="headerlink" title="字符串数字的递增递减"></a>字符串数字的递增递减</h4><p>INCR key （key没有值则从0开始 增加 1）</p><p>DECR key （key值减1）</p><p>INCRBY key increment （指定key 值增加多少）</p><p>DECRBY key increment （指定key 值减少多少）</p><h3 id="Hash散列"><a href="#Hash散列" class="headerlink" title="Hash散列"></a>Hash散列</h3><p>类似于 Java中的类属性</p><p>hset user1 name haha</p><p>hset user1 age 18</p><p>hget user1 age (取散列表中的值)</p><p>hmset key field value field value… (存多次值)</p><p>hmget key field field field…(取多次值)</p><p>hdel key field 删除</p><h3 id="list-有序集合"><a href="#list-有序集合" class="headerlink" title="list (有序集合)"></a>list (有序集合)</h3><p>lpush key value value value(往list 左边存多个值)</p><p>lpop key （取出左边第一个值） </p><p>rpush key value value value(往list 左边存多个值)</p><p>rpop key （取出左边第一个值） </p><p>llen kay    (查看key 中值的总数)</p><p>lrange key strat stop ( 查询key 中的多个值 第一个数值的坐标0)</p><p>左进右出  或者 右进左出  （队列的形式）</p><p>左进左出  或者  右进右出   （栈的形式）</p><h3 id="Set集合-（无序不重复）"><a href="#Set集合-（无序不重复）" class="headerlink" title="Set集合 （无序不重复）"></a>Set集合 （无序不重复）</h3><p>sadd key member member添加数据</p><p>smenbers key  查看key 的所有数据</p><p>srem key member删除信息</p><p>sismenber key member是否在set中</p><h3 id="Zset-有序集合，可排序"><a href="#Zset-有序集合，可排序" class="headerlink" title="Zset (有序集合，可排序)"></a>Zset (有序集合，可排序)</h3><p>zadd key menber </p><p>zrevrange key start stop 逆序排后返回结果</p><p>zscore key member </p><p>zrem key menber member …</p><p>zrevrange key start stop withscores  逆序排后返回结果包含分数</p><p>zincrby key increment member 给member 添加score</p><h3 id="HyoperLogLog"><a href="#HyoperLogLog" class="headerlink" title="HyoperLogLog"></a>HyoperLogLog</h3><p>HyperLogLog是一种使用随机化的算法，以少量内存提供集合中唯一元素数量的近似值。</p><p>PFADD key element [element …]    将指定的元素添加到指定的HyperLogLog 中</p><p>PFCOUNT key [key …]    返回给定 HyperLogLog 的基数估算值</p><p>PFMERGE destkey sourcekey [sourcekey …]    将多个 HyperLogLog 合并为一个 HyperLogLog</p><h3 id="其它指令"><a href="#其它指令" class="headerlink" title="其它指令"></a>其它指令</h3><p>keys * 查询所有key</p><p>keys k* 查询以k 开头的key</p><p>exist key 是否存在这个key</p><p>del key 删除这个key</p><p>rename 对可以重新命名</p><p>type key  查看key 的属性</p><p>expire key seconds 设置元素生存周期 多少秒后删除. </p><p>ttl key 查看剩余时间</p><p>presist 清除删除指令</p><p>info 查看服务器信息</p><p>flushdb 删库</p><p>flushall 删除全部数据库</p><p>select 0-15 选择数据库</p><p>move key 数据库号  移动key</p><h2 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis 事务"></a>Redis 事务</h2><p>multi 开启事务</p><p>exec 执行事务操作，保存结果</p><p>discard 放弃事务操作</p><p>假如事务中出现插入错误，语法错误等信息，事务内容不会执行</p><h2 id="Redis-发布订阅模式"><a href="#Redis-发布订阅模式" class="headerlink" title="Redis 发布订阅模式"></a>Redis 发布订阅模式</h2><p>subscribe channel 订阅一个频道</p><p>publish channel message 发布信息</p><h2 id="Redis-Jedis-连接"><a href="#Redis-Jedis-连接" class="headerlink" title="Redis Jedis 连接"></a>Redis Jedis 连接</h2><p>1 创建Maven 项目，导入依赖</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>2 配置单实例连接</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">Jedis jedis = new Jedis("192.168.150.100",6379);</span><br><span class="line">// 然后就可以进行配置了</span><br></pre></td></tr></tbody></table></figure><p>3 通过连接池连接</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 1.获取连接池配置对象,设置配置项</span></span><br><span class="line">JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line"><span class="comment">// 1.1最大的连接数</span></span><br><span class="line">config.setMaxTotal(<span class="number">30</span>);</span><br><span class="line"><span class="comment">// 1.2最大的空闲</span></span><br><span class="line">config.setMaxIdle(<span class="number">10</span>);</span><br><span class="line"><span class="comment">// 2.获取连接池</span></span><br><span class="line">JedisPool jedisPool = <span class="keyword">new</span> JedisPool(config, <span class="string">"192.168.197.129"</span>, <span class="number">6379</span>);</span><br><span class="line">Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">jedis = jedisPool.getResource();</span><br><span class="line"><span class="comment">// 3.设置数据</span></span><br><span class="line">jedis.set(<span class="string">"name"</span>, <span class="string">"张三"</span>);</span><br><span class="line">String name = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(<span class="string">"name="</span> + name);</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line"><span class="keyword">if</span> (jedis != <span class="keyword">null</span>) {</span><br><span class="line">jedis.close();</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 4.虚拟机关闭的时候，释放资源</span></span><br><span class="line"><span class="keyword">if</span> (jedisPool != <span class="keyword">null</span>) {</span><br><span class="line">jedisPool.close();</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="Redis-持久化策略"><a href="#Redis-持久化策略" class="headerlink" title="Redis 持久化策略"></a>Redis 持久化策略</h2><h3 id="RDB-策略（默认）"><a href="#RDB-策略（默认）" class="headerlink" title="RDB 策略（默认）"></a>RDB 策略（默认）</h3><p>dbfilename dump.rdb 存储文件名</p><p>优点：使用单独子进程来进行持久化，主进程不会进行任何 IO 操作，保证了 redis 的高性能</p><p>缺点：RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。所以这种方式更适合数据要求不严谨的时候</p><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF 默认关闭，开启方法，修改配置文件 reds.conf：appendonly yes</p><p>everysec：每秒同步一次，性能和安全都比较中庸的方式，也是 redis 推荐的方式。如果遇到物理服务器故障，有可能导致最近一秒内 aof 记录丢失(可能为部分丢失)</p><p>缺点 ： 文件较大，耗性能，恢复起来比较慢</p><h2 id="Redis主从复制"><a href="#Redis主从复制" class="headerlink" title="Redis主从复制"></a>Redis主从复制</h2><p>持久化保证了即使redis服务重启也不会丢失数据，但是当redis服务器的硬盘损坏了可能会导致数据丢失，通过redis的主从复制机制就可以避免这种单点故障（单台服务器的故障）</p><p>主redis中的数据和从上的数据保持实时同步,当主redis写入数据时通过主从复制机制复制到两个从服务上。</p><p>主从复制不会阻塞master，在同步数据时，master 可以继续处理client 请求.</p><p>主机master配置:无需配置</p><p>操作步骤</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.复制出一个从机 bin文件夹 (也可以重新安装一下)</span><br><span class="line">[root@localhost redis-5.0.5]make PREFIX=/home/redis1 install</span><br><span class="line">2.修改从机的redis.conf</span><br><span class="line">/replicaof 192.168.150.100 6379</span><br><span class="line">3.修改从机的port地址为6380</span><br><span class="line">/port 6380</span><br><span class="line">4.启动从机服务器,启动6380客户端</span><br><span class="line">5.启动主机服务器,启动6379客户端</span><br></pre></td></tr></tbody></table></figure><p>注意：主机一旦发生增删改操作，那么从机会自动将数据同步到从机中；从机不能执行写操作,只能读</p><p><strong>复制的过程原理</strong></p><ul><li>当从库和主库建立MS(master slaver)关系后，会向主数据库发送SYNC命令；</li><li>主库接收到SYNC命令后会开始在后台保存快照（RDB持久化过程），并将期间接收到的写命令缓存起来；</li><li>快照完成后,主Redis会将快照文件和所有缓存的写命令发送给从Redis；</li><li>从Redis接收到后，会载入快照文件并且执行收到的缓存命令；</li><li>主Redis每当接收到写命令时就会将命令发送从Redis，保证数据的一致；【内部完成,所以不支持客户端在从机人为写数据。】</li></ul><p>复制架构中出现宕机情况?</p><p>从Redis宕机:<strong>重启就好</strong></p><p>主Redis宕机:从数据库(从机)中执行SLAVEOF NO ONE命令，断开主从关系并且提升为主库继续服务[把一个从做为主机，这个时候新主机[之前的从机]就具备写入的能力]；主服务器修好后，重新启动后，执行SLAVEOF命令，将其设置为从库[老主机设置为从机]。[手动执行，过程复杂，容易出错。]是否有更好的方案</p><h2 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h2><p>哨兵模式的实现</p><ul><li>启动哨兵进程，首先需要创建哨兵配置文件vi sentinel.conf,可从源码配置redis-5.0.5/sentinel.conf中复制内容，也可以直接自定义该文件到bin目录下</li><li>在配置中输入:sentinel monitor mastername 内网IP(127.0.0.1) 6379 1</li></ul><p>各参数的含义：</p><p><strong>mastername</strong>    监控主数据的名称，自定义<br><strong>127.0.0.1</strong>    监控主数据库的IP;<br><strong>6379</strong>    端口<br><strong>1</strong>    最低通过票数</p><ul><li>把日志写入指定的文件 </li></ul><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost bin]# ps aux|grep redis 查询所有的redis进程</span><br><span class="line">[root@localhost bin]# ./redis-sentinel ./sentinel.conf &gt;sent.log &amp;</span><br></pre></td></tr></tbody></table></figure><ul><li>哨兵启动方式:</li></ul><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">[root@localhost bin]# ./redis-server ../redis.conf --sentinel</span><br></pre></td></tr></tbody></table></figure><p>总结：<br>主从集群：主机有写入权限。从机没有，只有可读。<br>意外宕机方案:<br>手动恢复：人为重启服务器，主机宕，把从机设置为主机。<br>自动恢复：使用哨兵监控。自动切换主从</p><h2 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h2><p><strong>集群架构图</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200906114743402.png" alt="image-20200906114743402"></p><p>架构图解释</p><p>(1)所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽.</p><p>(2)节点的fail是通过集群中超过半数的节点检测有效时整个集群才生效.</p><p>(3)客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可</p><p>(4)redis-cluster把所有的物理节点映射到[0-16383]slot上,cluster 负责维护node&lt;-&gt;slot&lt;-&gt;value</p><p>Redis 集群中内置了 16384 个哈希槽，当用户进行了写的操作，其写入的数据会先对 key 用 crc16算法算出一个结果，然后把结果对 16384 求余数，这样每个 key 都会对应一个编号在 0-16383 之间的哈希槽，同时，redis 会根据节点数量大致均等的将哈希槽映射到不同的节点，如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200906115200136.png" alt="image-20200906115200136"></p><p><strong>心跳机制</strong></p><ol><li>所有的master参与投票，如果半数的master主机与其中一个master主机通信超时，则可认为该主机挂掉</li></ol><p>集群不可用（fail）状态</p><ol><li>如果集群任意master挂掉,且当前master没有slave，则集群进入fail状态</li><li>如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态。</li></ol><h3 id="如何建立集群模式"><a href="#如何建立集群模式" class="headerlink" title="如何建立集群模式"></a>如何建立集群模式</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">最少集群演示（6台 redis）</span><br><span class="line">1. 创建文件夹 mkdir redis-cluster</span><br><span class="line">2. 从以前创建的主机中复制bin文件及 redis.conf文件 到 7001文件夹(这里直接将端口号命名成文件夹了)</span><br><span class="line">3. 删除 RDB 及 AOF 数据存储文件</span><br><span class="line">4. 修改redis.conf 文件 将Cluster-enable yes(默认是注释，将注释解掉)</span><br><span class="line">5. 复制出7002-7006 多台redis</span><br><span class="line">6. 修改7002-7006机器 redis.conf文件的端口</span><br><span class="line">7. 配置 startall.sh 文件，用与开启所有的redis服务器</span><br><span class="line"></span><br><span class="line">startall.sh 文件内容:</span><br><span class="line">cd 7001</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd 7002</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd 7003</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd 7004</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd 7005</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line">cd 7006</span><br><span class="line">./bin/redis-server ./redis.conf</span><br><span class="line">cd ..</span><br><span class="line"></span><br><span class="line">8. 修改startall.sh文件的权限: chmod u+x startall.sh (这里u+x 也可以是 a+x...)</span><br><span class="line">9. 运行startall.sh</span><br><span class="line"></span><br><span class="line">10. 创建集群 进入7001 bin 目录下 </span><br><span class="line">./redis-cli --cluster create 192.168.150.100:7001 192.168.150.100:7002 192.168.150.100:7003 192.168.150.100:7004 192.168.150.100:7005 192.168.150.100:7006 --cluster-replicas 1</span><br><span class="line">如下图所示即为创建成功 主机端口为 7001 7002 7003</span><br><span class="line"></span><br><span class="line">11. 连接集群</span><br><span class="line">任意连接一个客户端： </span><br><span class="line">[root@localhost 7001]# ./bin/redis-cli -h 192.168.150.100 -p 7001 -c (-c的意思是集群连接)</span><br><span class="line">任意写入数据，redis集群会根据hash计算结果 自动分配给三个端口</span><br></pre></td></tr></tbody></table></figure><p><strong>搭建成功</strong></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200918.png" alt="image-20200906120744216"></p><p><strong>查询集群及节点信息</strong></p><p>![image-20200906121956065](<a href="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/xshell" target="_blank" rel="noopener">https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/xshell</a> 集群节点信息.png)</p><p>通过jedis 2.9.0 连接 集群 </p><p>见Demo3</p><h2 id="Redis-缓存穿透、缓存雪崩"><a href="#Redis-缓存穿透、缓存雪崩" class="headerlink" title="Redis 缓存穿透、缓存雪崩"></a>Redis 缓存穿透、缓存雪崩</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3><p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p><h3 id="缓存穿透？"><a href="#缓存穿透？" class="headerlink" title="缓存穿透？"></a>缓存穿透？</h3><blockquote><p> 最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p></blockquote><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： <code>表名:列名:主键名:主键值</code> 。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getObjectInclNullById</span><span class="params">(Integer id)</span> </span>{</span><br><span class="line">    <span class="comment">// 从缓存中获取数据</span></span><br><span class="line">    Object cacheValue = cache.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空</span></span><br><span class="line">    <span class="keyword">if</span> (cacheValue == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 从数据库中获取</span></span><br><span class="line">        Object storageValue = storage.get(key);</span><br><span class="line">        <span class="comment">// 缓存空对象</span></span><br><span class="line">        cache.set(key, storageValue);</span><br><span class="line">        <span class="comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span></span><br><span class="line">        <span class="keyword">if</span> (storageValue == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="comment">// 必须设置过期时间，否则有被攻击的风险</span></span><br><span class="line">            cache.expire(key, <span class="number">60</span> * <span class="number">5</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> storageValue;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> cacheValue;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="bulongguolvqi"></p><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： <strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p><p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p><ol><li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ol><p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p><ol><li>对给定元素再次进行相同的哈希计算；</li><li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li></ol><p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p><p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/dataStructures-algorithms/data-structure/bloom-filter.md" target="_blank" rel="noopener">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h4 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h4><p>我发现缓存雪崩这名字起的有点意思，哈哈。</p><p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>举个例子：系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。</p><p>还有一种缓存雪崩的场景是：<strong>有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。</strong> 这样的情况，有下面几种解决办法：</p><p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p><h4 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h4><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li>限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li>设置不同的失效时间比如随机设置缓存的失效时间。</li><li>缓存永不失效。</li></ol><h3 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h3><p>细说的话可以扯很多，但是我觉得其实没太大必要（小声BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p><p>下面单独对  <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p><p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p><ol><li><strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li><strong>增加cache更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</li></ol><h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><p>具体参考课件吧！</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>Redis 命令总结：<a href="http://Redisdoc.com/string/set.html" target="_blank" rel="noopener">http://Redisdoc.com/string/set.html</a></li><li>通俗易懂的 Redis 数据结构基础教程：<a href="https://juejin.im/post/5b53ee7e5188251aaa2d2e16" target="_blank" rel="noopener">https://juejin.im/post/5b53ee7e5188251aaa2d2e16</a></li><li>WHY Redis choose single thread (vs multi threads): <a href="https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153" target="_blank" rel="noopener">https://medium.com/@jychen7/sharing-redis-single-thread-vs-multi-threads-5870bd44d153</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Nosql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> Nosql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/posts/46563.html"/>
      <url>/posts/46563.html</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><hr><h2 id="为啥要反过头来学正则"><a href="#为啥要反过头来学正则" class="headerlink" title="为啥要反过头来学正则"></a>为啥要反过头来学正则</h2><p>前几天 写快递系统，写到正则的时候写的脑壳痛，感觉用正则验证密码啊，身份证啊什么的完全就写不了，只会一个简单的 \d  \w 然后用标准的<code>/^\d{11}$/</code> 匹配11 位的数字，恩感觉是不是有点太low了，所以想反过头来学一学，看看别人的正则是怎么写的！！！</p><p>接下来步入正题：</p><p>来看看 至少包含一位大写字母、小写字母、数字 的正则表达式是怎么写的吧：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">弱密码验证:  /^\w{8,16}$/  </span><br><span class="line">强密码验证:/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,16}$/</span><br><span class="line">(强密码为至少包含一位大写字母，一位小写字母，一位数字，其余可为任意字符)</span><br></pre></td></tr></tbody></table></figure><p>强密码看的懂的扣1 ，不愧是大佬，佩服佩服，后面的允许你不用看了！</p><h2 id="正则的组成"><a href="#正则的组成" class="headerlink" title="正则的组成"></a>正则的组成</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">举例：/^\w{6,}$/</span><br></pre></td></tr></tbody></table></figure><p>先拿这样一个表达式来说，<strong>/ /</strong> 是修饰符，<strong>^ 、{n}、 $</strong> 是量词，<strong>\w</strong> 是元字符，总的意思就是匹配大于6位的字符</p><p>具体元字符，量词等完全体介绍可以参考<a href="https://www.runoob.com/jsref/jsref-obj-regexp.html" target="_blank" rel="noopener">菜鸟教程</a></p><p>这里说一些易错的</p><p><strong>方括号表达式</strong></p><table><thead><tr><th align="left">表达式</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">[abc]</td><td align="left">查找方括号之间的任何字符。</td></tr><tr><td align="left">[^abc]</td><td align="left">查找任何不在方括号之间的字符。</td></tr><tr><td align="left">[^]</td><td align="left">查找任意字符</td></tr></tbody></table><p><strong>元字符</strong></p><p>\d \w \D \W ；</p><p><code>.</code> 表示除了 \n \r 的任意字符 ，[^] 范围更大一点</p><p><strong>量词</strong></p><table><thead><tr><th align="left">量词</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">n+</td><td align="left">匹配任何包含至少一个 n 的字符串</td></tr><tr><td align="left">n*</td><td align="left">匹配任何包含零个或多个 n 的字符串</td></tr><tr><td align="left">n?</td><td align="left">匹配任何包含零个或一个 n 的字符串</td></tr><tr><td align="left">?=n</td><td align="left">匹配任何其后紧接指定字符串 n 的字符串</td></tr><tr><td align="left">?!n</td><td align="left">不匹配任何其后紧接指定字符串 n 的字符串</td></tr></tbody></table><p>此外，还有方括号<strong>[]</strong>、圆括号<strong>()</strong>、或 <strong>|</strong> 、至 <strong>-</strong> ；</p><ul><li>[] 内写的是字符范围，表示该范围中的任意一个字符</li><li>() 代表一个捕获组，一个捕获组中含有多个字符，捕获组与捕获组之间加 | 可以匹配多段内容，如/^(abc)$|^(bcd)$/ 指匹配abc 或者bcd，不加 | 捕获组与捕获组默认是字符集的合并</li><li>[] 内加| 默认代表 | 这个字符， 字符与字符之间、捕获组与捕获组之间，加 | 代表 任取一个的意思， 也就是或；捕获组获取 | 这个符号要加转义字符 \； </li><li>[] 内 可用减号 -  连接AscII 码表上连续的字符  如 ^(aa[!-9])$ 匹配 aa! 至 aa9 的内容；</li><li>[] 内不能追加 [] ；() 内可以追加() 和 [] ;</li></ul><h3 id="小试牛刀"><a href="#小试牛刀" class="headerlink" title="小试牛刀"></a>小试牛刀</h3><p>来看一看验证身份证的正则表达式：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">idCareReg = /^[<span class="number">1</span>-<span class="number">9</span>]\d{<span class="number">5</span>}(<span class="number">18</span>|<span class="number">19</span>|([<span class="number">23</span>]\d))\d{<span class="number">2</span>}((<span class="number">0</span>[<span class="number">1</span>-<span class="number">9</span>])|(<span class="number">10</span>|<span class="number">11</span>|<span class="number">12</span>))(([<span class="number">0</span>-<span class="number">2</span>][<span class="number">1</span>-<span class="number">9</span>])|<span class="number">10</span>|<span class="number">20</span>|<span class="number">30</span>|<span class="number">31</span>)\d{<span class="number">3</span>}[<span class="number">0</span>-<span class="number">9</span>Xx]$/;</span><br><span class="line"></span><br><span class="line">第一位 [<span class="number">1</span>-<span class="number">9</span>]（不为<span class="number">0</span>的一位数）</span><br><span class="line"><span class="number">2</span>-<span class="number">6</span>位 d{<span class="number">5</span>} 任意<span class="number">5</span>个数字</span><br><span class="line"><span class="number">7</span>-<span class="number">8</span>位 <span class="number">18</span>|<span class="number">19</span>|([<span class="number">23</span>]\d) 代表年份 <span class="number">18</span> 或 <span class="number">19</span> 或 [<span class="number">23</span>]+\d</span><br><span class="line"><span class="number">9</span>-<span class="number">10</span>位 d{<span class="number">2</span>} 任意两位数 </span><br><span class="line"><span class="number">11</span>-<span class="number">12</span>位 (<span class="number">0</span>[<span class="number">1</span>-<span class="number">9</span>])|(<span class="number">10</span>|<span class="number">11</span>|<span class="number">12</span>) 代表<span class="number">1</span>-<span class="number">12</span>月份</span><br><span class="line"><span class="number">13</span>-<span class="number">14</span>位 ([<span class="number">0</span>-<span class="number">2</span>][<span class="number">1</span>-<span class="number">9</span>])|<span class="number">10</span>|<span class="number">20</span>|<span class="number">30</span>|<span class="number">31</span> <span class="number">01</span>-<span class="number">31</span> 代表<span class="number">1</span>-<span class="number">31</span>号</span><br><span class="line"><span class="number">15</span>-<span class="number">17</span>位 d{<span class="number">3</span>} 任意三位数</span><br><span class="line"><span class="number">18</span>位 [<span class="number">0</span>-<span class="number">9</span>Xx] 字符范围 <span class="number">0</span>-<span class="number">9</span> X 或 x</span><br></pre></td></tr></tbody></table></figure><p><strong>注意：[] 中的 | 代表 | 这个符号， () 中 字符间的 | 代表选择</strong> </p><p>再来看下密码验证</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">pwdReg = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d).{8,16}$/;</span><br><span class="line"></span><br><span class="line">?= 表示匹配 = 后面的字符</span><br><span class="line">.*[a-z] 表示任意位数的字符 + 一位任意的小写字母</span><br></pre></td></tr></tbody></table></figure><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><p>只是提供了少部分的，都是本人亲自验证过的，有别的需求的话，掌握语法了可以自己写；</p><h3 id="数字验证："><a href="#数字验证：" class="headerlink" title="数字验证："></a>数字验证：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.纯数字：^[0-9]*$</span><br><span class="line">2.m-n位的数字：^\d{m,n}$</span><br><span class="line">3.零或非零开头的正整数：^(0|[1-9][0-9]*)$</span><br><span class="line">4.正数、负数、和小数：^(\-|\+)?\d+(\.\d+)?$</span><br><span class="line">5.有两位小数的正实数：^[0-9]+(\.[0-9]{2})?$</span><br></pre></td></tr></tbody></table></figure><h3 id="表单验证："><a href="#表单验证：" class="headerlink" title="表单验证："></a>表单验证：</h3><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1.用户名(2-16位字母数字下划线和汉字)： ^[a-zA-Z0-9_\u4e00-\u9fa5]{2,16}$</span><br><span class="line">2.姓名(2位以上的汉字)： ^[\u4e00-\u9fa5]{2,}$</span><br><span class="line">3.密码： ^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,16}$</span><br><span class="line">4.手机号：^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(18[0,5-9]))\d{8}$</span><br><span class="line">5.身份证：^[1-9]\d{5}(18|19|([23]\d))\d{2}((0[1-9])|(10|11|12))(([0-2][1-9])|10|20|30|31)\d{3}[0-9Xx]$</span><br><span class="line">6.邮箱验证：\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> regexp </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven入门级教程</title>
      <link href="/posts/567.html"/>
      <url>/posts/567.html</url>
      
        <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><p>如果你只有一个src 文件夹，没有相关的编译软件 eclipse / IDEA ，需要运行，怎么办呢？ 你总不能一个一个文件java c 去编译运行吧</p><p>这里就需要通过Maven 这个项目管理工具来实现了；</p><h2 id="Maven能做什么"><a href="#Maven能做什么" class="headerlink" title="Maven能做什么"></a>Maven能做什么</h2><p>当你编译文件需要依赖包时，他就会从网上自动下载 jar 包进行编译；当你需要运行tomcat 时，他也能自动下载 tomcat 依赖包，来进行web 项目的运行；总体来说，Maven 不是一个只能管理 jar 包的软件，他能让你实现各种工具、框架，在Maven 中里面运行；</p><p>与Maven 类似的项目管理工具还有<strong>gradle</strong>，gradle是一款基于Groove 语言建立的工具，其也能进行工程构建、依赖管理、仓库建设等；</p><h2 id="1-Maven-的下载"><a href="#1-Maven-的下载" class="headerlink" title="1. Maven 的下载"></a>1. Maven 的下载</h2><p>下载地址：<a href="http://maven.apache.org/" target="_blank" rel="noopener">http://maven.apache.org/</a></p><p>apache 软件官网命名规则 （ 工具+apache.org ）</p><ul><li><a href="http://maven.apache.org/" target="_blank" rel="noopener">http://maven.apache.org/</a>   项目管理工具</li><li><a href="http://tomcat.apache.org/" target="_blank" rel="noopener">http://tomcat.apache.org/</a>   web 应用服务器</li><li><a href="http://dubbo.apache.org/" target="_blank" rel="noopener">http://dubbo.apache.org/</a>   高性能RPC实现的服务框架</li><li><a href="http://rocketmq.apache.org/" target="_blank" rel="noopener">http://rocketmq.apache.org/</a>  分布式消息队列</li><li><a href="http://hadoop.apache.org/" target="_blank" rel="noopener">http://hadoop.apache.org/</a>  大数据分布式存储</li><li><a href="http://kafka.apache.org/" target="_blank" rel="noopener">http://kafka.apache.org/</a>  高吞吐量的分布式发布订阅消息系统</li><li><a href="http://zookeeper.apache.org/" target="_blank" rel="noopener">http://zookeeper.apache.org/</a>  分布式应用程序协调服务</li></ul><p>Maven下载界面如下： </p><p>apache-maven-3.6.3-bin.zip 为 Windows 版本</p><p>apache-maven-3.6.3-bin.tar.zip 为 linux 版本</p><p>再下面两个是源码包；</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200820185826.png" alt=""></p><blockquote><p>下载完成后需要进行环境变量配置</p><ol><li>解压</li><li>配置MAVEN_HOME</li><li>配置path，%MAVEN_HOME%\bin</li><li>cmd执行 mvn -v ，出现以下界面，成功</li></ol></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200820190414.png" alt=""></p><h2 id="2-Maven-Setting-文件与-IDEA-配置"><a href="#2-Maven-Setting-文件与-IDEA-配置" class="headerlink" title="2. Maven Setting 文件与 IDEA 配置"></a>2. Maven Setting 文件与 IDEA 配置</h2><h3 id="Setting-xml-文件配置"><a href="#Setting-xml-文件配置" class="headerlink" title="Setting.xml 文件配置"></a>Setting.xml 文件配置</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a08201.jpg" alt=""></p><p>Maven 文件解压完成后，如上图所示，这里我们关注conf 这个配置文件夹，打开后里面有一个 *<em>settings.xml *</em>配置文件，在修改之前可以先备份一下，以免数据改错后无法恢复，当然，也可以重新解压下 zip 包取文件；</p><p>这个*<em>settings.xml *</em>文件中，我们主要修改以下三个地方：</p><ul><li><strong>Maven 本地仓库文件夹路径修改</strong></li></ul><p>在文件的 localRepository 注释下面加上下面这行代码，中间是你配置的仓库路径（任意）</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">localRepository</span>&gt;</span>C:\Users\www92\repository<span class="tag">&lt;/<span class="name">localRepository</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>这个假如不配置的话，Maven 会默认下载到C:\Users\用户名\ .m2\repository 这个文件夹下；</p><ul><li><strong>阿里云镜像配置</strong>（加快 jar 包的下载速度，Maven 默认的中央仓库URL是外网）</li></ul><p>在<code>&lt;mirrors&gt;</code>标签内部配置如下代码</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>alimaven<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>aliyun maven<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>central<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><ul><li><strong>配置 JDK 编译版本号</strong>（不配置默认Maven 3 默认为 jdk 1.5 版本）本人用的是 JDK11</li></ul><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">profile</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>jdk-11<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activation</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">activeByDefault</span>&gt;</span>true<span class="tag">&lt;/<span class="name">activeByDefault</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdk</span>&gt;</span>11<span class="tag">&lt;/<span class="name">jdk</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">activation</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">maven.compiler.compilerVersion</span>&gt;</span>11<span class="tag">&lt;/<span class="name">maven.compiler.compilerVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">profile</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="IDEA环境配置"><a href="#IDEA环境配置" class="headerlink" title="IDEA环境配置"></a>IDEA环境配置</h3><ol><li>在 File -&gt; Settings  搜索Maven ，配置以下三个地方（配置当前项目的Maven）</li><li>同理，在File -&gt; New Porjects Settings -&gt; Setting for New Projects 下配置同样三处位置 （配置新建 Maven 项目）</li></ol><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/0820-2.png" alt=""></p><h2 id="3-Maven-工程目录"><a href="#3-Maven-工程目录" class="headerlink" title="3. Maven 工程目录"></a>3. Maven 工程目录</h2><p><strong>一个最基本的Maven工程目录如下</strong></p><figure class="highlight"><table><tbody><tr><td class="code"><pre><span class="line">src</span><br><span class="line">|--main</span><br><span class="line">|--java 源代码目录</span><br><span class="line">|--resources 资源目录</span><br><span class="line">|--test</span><br><span class="line">|--java 测试代码目录</span><br><span class="line">|--resources 测试资源目录</span><br><span class="line">|--target (编译后才有)</span><br><span class="line">    |--classes 编译后的class文件目录</span><br><span class="line">    |--test-classes 编译后的测试class文件目录</span><br><span class="line">pom.xml Maven工程配置文件</span><br></pre></td></tr></tbody></table></figure><h3 id="pom-xml-文件目录"><a href="#pom-xml-文件目录" class="headerlink" title="pom.xml 文件目录"></a>pom.xml 文件目录</h3><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">        <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>这里说一下pom 文件必不可少的几个配置：</p><p>头信息在这里忽略，默认配置</p><p><code>modelVersion</code> 模型版本需要设置为 4.0.0，默认配置</p><p><code>artifactId</code> Maven 仓库的坐标组成，通常为工程的名称</p><p><code>groupId</code> Maven 仓库的坐标组成，命名规则类似于Java中的包名 com.XXX</p><p><code>version</code> 版本号，还有SNAPSHOT 开发版，LATEST 最新版，RELEASE 稳定版</p><p><strong>通过 <code>artifactId</code>、<code>groupId</code>、<code>version</code>可以找到中央仓库中的任何一个jar包</strong></p><p><code>packaging</code> 默认为jar ，打包类型，还有war、javadoc….等</p></blockquote><p>有了这些配置就能搭起来一个Maven 项目了</p><h2 id="4-Maven生命周期"><a href="#4-Maven生命周期" class="headerlink" title="4. Maven生命周期"></a>4. Maven生命周期</h2><blockquote><p> <strong>maven生命周期其实就是描述了一个项目从源代码到部署的整个周期</strong></p></blockquote><p>Maven有三个内置的生命周期：默认（default），清洁（clean）和站点（site）。</p><ul><li>清洁（clean） 为执行以下工作做必要的清理。就是我们经常做的，删除out文件夹。</li><li>默认（default） 真正进行项目编译打包等工作的阶段</li><li>站点（site） 生成项目报告，站点，发布站点</li></ul><p>默认阶段主要有一下几个步骤：</p><table><thead><tr><th align="left">阶段</th><th align="left">处理</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">验证 validate</td><td align="left">验证项目</td><td align="left">验证项目是否正确且所有必须信息是可用的</td></tr><tr><td align="left">编译 compile</td><td align="left">执行编译</td><td align="left">源代码编译在此阶段完成</td></tr><tr><td align="left">测试 Test</td><td align="left">测试</td><td align="left">使用适当的单元测试框架（例如JUnit）运行测试。</td></tr><tr><td align="left">包装 package</td><td align="left">打包</td><td align="left">创建JAR/WAR包如在 pom.xml 中定义提及的包</td></tr><tr><td align="left">检查 verify</td><td align="left">检查</td><td align="left">对集成测试的结果进行检查，以保证质量达标</td></tr><tr><td align="left">安装 install</td><td align="left">安装</td><td align="left">安装打包的项目到本地仓库，以供其他项目使用</td></tr><tr><td align="left">部署 deploy</td><td align="left">部署</td><td align="left">拷贝最终的工程包到远程仓库中，以共享给其他开发人员和工程</td></tr></tbody></table><h3 id="Maven-常用命令"><a href="#Maven-常用命令" class="headerlink" title="Maven 常用命令"></a>Maven 常用命令</h3><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">mvn –version</td><td align="left">显示版本信息</td></tr><tr><td align="left">mvn clean*</td><td align="left">清理项目生产的临时文件,一般是模块下的target目录</td></tr><tr><td align="left">mvn compile *</td><td align="left">编译源代码，一般编译模块下的src/main/java目录</td></tr><tr><td align="left">mvn package*</td><td align="left">项目打包工具,会在模块下的target目录生成jar或war等文件</td></tr><tr><td align="left">mvn test</td><td align="left">测试命令,或执行src/test/java/下junit的测试用例</td></tr><tr><td align="left">mvn install</td><td align="left">将打包的jar/war文件复制到你的本地仓库中,供其他模块使用</td></tr><tr><td align="left">mvn deploy</td><td align="left">将打包的文件发布到远程参考,提供其他人员进行下载依赖</td></tr><tr><td align="left">mvn site</td><td align="left">生成项目相关信息的网站</td></tr><tr><td align="left">mvn dependency:tree</td><td align="left">打印出项目的整个依赖树</td></tr><tr><td align="left">mvn archetype:generate</td><td align="left">创建Maven的普通java项目</td></tr><tr><td align="left">mvn tomcat7:run</td><td align="left">在tomcat容器中运行web应用</td></tr></tbody></table><h2 id="5-Maven-依赖"><a href="#5-Maven-依赖" class="headerlink" title="5. Maven 依赖"></a>5. Maven 依赖</h2><blockquote><p>Maven 最强大的优势之一就是其对依赖包的管理，在Maven 中央仓库基本上可以下载到你所需要的任何jar 包，并且你只需要在pom文件下配置依赖信息即可，例如；</p></blockquote><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="依赖搜索顺序"><a href="#依赖搜索顺序" class="headerlink" title="依赖搜索顺序"></a>依赖搜索顺序</h3><p>当需要下载jar 包时，Maven 会先去<strong>本地仓库</strong>，也就是之前配置的 repository 下面找，没有找到的话，再去<strong>中央仓库</strong>中找；假如有的公司配置了远程仓库（存储一些公司专用 jar 包），中央仓库找不到，则会去<strong>远程仓库</strong>找； 如果可以找到，则下载到本地，如果未找到相应 jar包 ，Maven 将简单的停滞处理并抛出错误（无法找到依赖的文件）。</p><h3 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h3><p>上面代码中有一个标签 <code>scope</code> 代表的就是依赖包的适用范围；</p><p>一般我们使用的以下依赖范围：compile(编译时，默认)，test(测试时)，runtime(运行时)，provide(已提供)</p><table><thead><tr><th align="left">依赖范围</th><th>编译时</th><th>运行时</th><th>测试时</th></tr></thead><tbody><tr><td align="left">compile</td><td>√</td><td>√</td><td>√</td></tr><tr><td align="left">runtime</td><td>×</td><td>√</td><td>√</td></tr><tr><td align="left">test</td><td>×</td><td>×</td><td>√</td></tr><tr><td align="left">provided</td><td>√</td><td>×</td><td>√</td></tr></tbody></table><p>√ 表示有效，× 表示无效</p><h3 id="子父模块的依赖继承"><a href="#子父模块的依赖继承" class="headerlink" title="子父模块的依赖继承"></a>子父模块的依赖继承</h3><p>当我们需要配置多个模块继承同一个 jar 包时，假如每个模块都写 dependces，是不是会很麻烦，这里我们用到了聚合模块（父模块）的概念；</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--父模块pom文件配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明子模块名称--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modules</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-one<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>child-two<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span>web<span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--打包方式为pom--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 定义常量属性，查看各jar包的版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fastJson-version</span>&gt;</span>1.2.73<span class="tag">&lt;/<span class="name">fastJson-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">druid-version</span>&gt;</span>1.2.18<span class="tag">&lt;/<span class="name">druid-version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">common-lang-version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">common-lang-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--父模块依赖包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--依赖包管理，子类写依赖才会加载，并且子类继承父类依赖管理包的版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>${fastJson-version}<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>配置完成后，两个子类chile-one 、child-two 都可以使用父模块的依赖包；</p><p>子模块pom配置如下代码所示</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--子模块继承父模块配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven_test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--子模块名称 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>child-one<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--子模块依赖包配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>fastjson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p><strong>注意：</strong>假如父类依赖放在 dependencyManagement 中，子类不写该依赖是不会下载jar文件的，写依赖后会自动继承父类依赖的版本号，并下载jar 包；而假如父类依赖写在dependencies，没有在dependencyManagement内部，则子类会直接继承，并下载；</p></blockquote><h2 id="6-Maven-插件"><a href="#6-Maven-插件" class="headerlink" title="6. Maven 插件"></a>6. Maven 插件</h2><p><strong>Maven 的另一大特色是其强大的插件功能（plugins）</strong></p><p>Maven 的命令操作几乎都是建立在插件的运行上，比如clean 操作需要用到 maven-clean-plugin 插件，compile 操作需要用到 maven-compile-plugin 插件，假如你想在 Maven上运行 tomcat ，只需要下载 tomcat7-maven-plugin 插件即可 ，配置如下：</p><p>注：假如有 IDEA 的同学打开Maven工具项目下的plugins一栏，里面的插件使用一些命令，双击也可以运行其命令；</p><figure class="highlight xml"><table><tbody><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">port</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">port</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">uriEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">uriEncoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">path</span>&gt;</span>/test<span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h2 id="7-Maven-自动创建项目"><a href="#7-Maven-自动创建项目" class="headerlink" title="7. Maven 自动创建项目"></a>7. Maven 自动创建项目</h2><p>Archetype 是一个 Maven 插件，其任务是按照其模板来创建一个项目结构</p><p>可以通过以下代码 cmd 命令实现</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个普通Maven工程项目</span></span><br><span class="line">mvn archetype:generate </span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个Maven war工程项目</span></span><br><span class="line">mvn archetype:generate -DgroupId=org.name -DartifactId=name -DarchetypeArtifactId=maven-archetype-webapp</span><br></pre></td></tr></tbody></table></figure><p>也可以通过IDEA 自带的模板创建</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200820225804.png" alt=""></p><p>Maven 主要注意的点是Pom文件下的一些配置，依赖包，插件，还有一些build 原生配置，这里给大家个链接，自拿学习；</p><p><a href="https://blog.csdn.net/weixin_38569499/article/details/91456988?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522159793613419724843361120%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=159793613419724843361120&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-91456988.pc_ecpm_v3_pc_rank_v3&amp;utm_term=maven+pom&amp;spm=1018.2118.3001.4187" target="_blank" rel="noopener">maven：pom文件详解</a></p><p>花了两天时间学的Maven 总结，希望搭嘎能给个好评！撒花 biubiubiu~~</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> 项目管理工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引及SQL语句优化</title>
      <link href="/posts/63306.html"/>
      <url>/posts/63306.html</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- mysql文件保存位置</span><br><span class="line">show global variables like "%datadir%";</span><br><span class="line"></span><br><span class="line">-- MySQL8.0 以元数据文件、非事务表来存储的文件被删除了，比如：.frm, .par, .trn, .isl, .db.opt等都在MySQL8.0中不存在了用专门的表空间mysql.idb来存储。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看表索引</span><br><span class="line">-- show index from orders;</span><br><span class="line">-- show keys from users;</span><br><span class="line">-- desc users;</span><br><span class="line">-- show create table users;</span><br><span class="line"></span><br><span class="line"># 主键索引与普通索引</span><br><span class="line">-- explain select * from orders where cust_id = 10001;</span><br><span class="line">-- explain select * from orders where order_num =20005;</span><br><span class="line"></span><br><span class="line"># 添加唯一索引 失败</span><br><span class="line">-- alter table orderitems add unique u_pid(prod_id);</span><br><span class="line"></span><br><span class="line"># 添加普通索引</span><br><span class="line">-- alter table users add index in_age(age);</span><br><span class="line">-- explain select * from users where age&gt;25;</span><br><span class="line"># 删除普通索引</span><br><span class="line">-- drop index in_age on users;</span><br><span class="line"></span><br><span class="line"># 全文索引</span><br><span class="line">-- explain select * from productnotes where note_text like 'Customer%';</span><br><span class="line"></span><br><span class="line"># 联合索引</span><br><span class="line">-- explain select * from orderitems where order_item = 1;</span><br><span class="line">-- explain select * from orderitems where order_num = 20005;</span><br><span class="line">-- explain select * from orderitems where order_item = 1 and order_num = 20005;</span><br></pre></td></tr></tbody></table></figure><p>按照老师提供的文档进行了1000W 条数据的插入，想看看索引到底会占多少的存储空间，然后花了半小时才加到了44W 行，果断放弃了!</p><hr><p>添加索引前文件大小：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200808112138351.png" alt=""></p><p>查找 age=18 花费时间：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200808123622779.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a1_%E7%88%B1%E5%A5%87%E8%89%BA_%E7%88%B1%E5%A5%87%E8%89%BA.jpg" alt="">添加普通索引后文件大小：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a33.png" alt=""></p><p>查找 age=18 花费时间：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a4.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a2.png" alt=""></p><p>具体原因可能是优化器的优化选择方面出了问题（原因未知）；</p><p>文件内容：共44W行数据；</p><p><strong>注意： drop index 删除索引并不会删除存储空间，我理解的是只是断开了与建立索引的链接，并且，后续假如建立相同名称的索引，是不需要消耗空间的；</strong></p><p>具体如何删除表中索引并释放空间的方法没有查到；</p><h2 id="书写高质量的Mysql-语句"><a href="#书写高质量的Mysql-语句" class="headerlink" title="书写高质量的Mysql 语句"></a>书写高质量的Mysql 语句</h2><p>参考链接：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486461&amp;idx=1&amp;sn=60a22279196d084cc398936fe3b37772&amp;chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&amp;token=1987003517&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">书写高质量SQL的30条建议</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> SQL索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络面试题</title>
      <link href="/posts/61055.html"/>
      <url>/posts/61055.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTP-协议"><a href="#1-HTTP-协议" class="headerlink" title="1. HTTP 协议"></a>1. HTTP 协议</h2><p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的<strong>应用层协议</strong>。HTTP是万维网的数据通信的基础</p><p>http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。——百度百科</p><h3 id="关于域名解析"><a href="#关于域名解析" class="headerlink" title="关于域名解析"></a>关于域名解析</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200811093557830.png" alt=""></p><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了<strong>请求/响应模型</strong>。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是 HTTP 请求/响应的步骤：</p><ol><li><p>客户端连接到Web服务器<br>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址，一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.luffycity.com/" target="_blank" rel="noopener">http://www.luffycity.com</a>。</p></li><li><p>发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由<strong>请求行、请求头部、空行和请求数据</strong>4部分组成。</p></li><li><p>服务器接受请求并返回HTTP响应<br>Web服务器<strong>解析请求，定位请求资源</strong>。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由<strong>状态行、响应头部、空行和响应数据</strong>4部分组成。</p></li><li><p>释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><p>　　<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a0814.jpg" alt=""></p><p>　　<strong>http协议是基于TCP/IP协议之上的应用层协议。</strong></p><p>　　<strong>基于 请求-响应 的模式</strong></p><p>　　HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应，<strong>服务端不能主动说话。</strong></p><p>　　　　<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/b0814.png" alt=""></p><p>　　<strong>无状态</strong></p><p>　　HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于<strong>发送过的请求或响应都不做持久化处理</strong>。</p><p>　　　　<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/c0814.png" alt=""></p><p>　　使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是<strong>引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管理状态了</strong>。有关Cookie的详细内容稍后讲解。</p><p>　　<strong>无连接</strong></p><p>　　无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现<strong>在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在</strong>，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。</p><blockquote><p><strong>来个总结 http 是一种基于请求和响应的无状态、无连接的协议</strong></p></blockquote><h2 id="2-OSI与TCP-IP各层的结构与功能"><a href="#2-OSI与TCP-IP各层的结构与功能" class="headerlink" title="2. OSI与TCP/IP各层的结构与功能"></a>2. OSI与TCP/IP各层的结构与功能</h2><blockquote><p>学习计算机⽹络时一般我们会将 OSI 和 TCP/IP 的优点进行合并，采用一种只有五层协议的体系结构，如下图所示，这样既简洁⼜能将概念阐述清楚</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200807090901.png" alt=""></p><h3 id="网络通信过程"><a href="#网络通信过程" class="headerlink" title="网络通信过程"></a>网络通信过程</h3><p>在<a href="https://baike.baidu.com/item/网络通信/9636548" target="_blank" rel="noopener">网络通信</a>的过程中，将发出数据的主机称为源主机，接收数据的主机称为目的主机。当源主机发出数据时，数据在源主机中从上层向下层传送。源主机中的应用进程先将数据交给应用层，应用层加上必要的控制信息就成了报文流，向下传给传输层。传输层将收到的数据单元加上本层的控制信息，形成报文段、数据报，再交给网际层。网际层加上本层的控制信息，形成IP数据报，传给网络接口层。网络接口层将网际层交下来的IP数据报组装成帧，并以比特流的形式传给网络硬件（即物理层），数据就离开源主机。</p><h3 id="五层协议结构"><a href="#五层协议结构" class="headerlink" title="五层协议结构"></a>五层协议结构</h3><p><strong>应用层</strong></p><p><strong>应用层作用：定义数据格式并按照对应的格式解读数据。</strong></p><p>应用层的协议很多，比如域名系统DNS，万维网HTTP协议，支持电子邮件的SMTP协议等；</p><p>通常我们把应用层交互的数据单元称为 <strong>报文</strong>；</p><p><strong>传输层</strong></p><p><strong>传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作</strong></p><p>其主要使用以下两种协议：</p><ol><li><p>传输控制协议 TCP（Transmission Control Protocol）提供面向连接的，可靠的数据传输服务。 </p></li><li><p>用户数据协议 UDP（User Datagram Protocol）提供无连接的，尽最大努力的数据传输服务 （不保证数据传输的可靠性）。</p></li></ol><p><strong>网络层</strong></p><p><strong>网络层主要解决不同子网间的通信</strong>。</p><p>在计算机网络络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送，在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用的是IP协议，因此分组也叫 IP 数据报 ，简称数据报</p><p><strong>数据链路层</strong></p><p>该层的主要功能是：<strong>通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路</strong></p><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）</p><p><strong>物理层</strong></p><p><strong>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</strong></p><p>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>具体可以参考：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">OSI七层模型详解</a></p><h3 id="一张大图让你清晰了解OSI-七层模型"><a href="#一张大图让你清晰了解OSI-七层模型" class="headerlink" title="一张大图让你清晰了解OSI 七层模型"></a>一张大图让你清晰了解OSI 七层模型</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/000807.jpg" alt=""></p><h2 id="3-TCP-三次握手和四次挥手-面试常客"><a href="#3-TCP-三次握手和四次挥手-面试常客" class="headerlink" title="3. TCP 三次握手和四次挥手(面试常客)"></a>3. TCP 三次握手和四次挥手(面试常客)</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200811111310633.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql学习总结</title>
      <link href="/posts/16637.html"/>
      <url>/posts/16637.html</url>
      
        <content type="html"><![CDATA[<hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库就是按照数据结构来组织，存储和管理数据的仓库</p><p>数据库特点：</p><ul><li>对数据进行持久化保存</li><li>方便数据的存储和查询，速度快，安全，方便</li><li>可以处理并发访问</li><li>更加安全的权限管理访问机制</li></ul><p>常见的数据库：</p><p>Mysql 、oricle 、PostgerSQL 、SQLServer(微软)  关系型数据库<br>redis 非关系型数据库（数据存储在内存中，读取速度快，键值对的形式存储，不是二维表的形式）<br>mongoDB 文档型数据库 也是非关系型数据库   配合上面数据库使用 </p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎： 对具体数据进行操作，读取表中数据，以及将数据存储进物理内存中；</p><p>客户端： 连接 Mysql<br>服务器： 连接管理、查询缓存、语法解析、查询优化等操作<br>存储引擎：真实的存取数据</p><p>Mysql 支持的存储引擎：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200729164116.png" alt=""></p><blockquote><p>我们一般常用的是 InnoDB 与 MyISAM</p></blockquote><h3 id="InnoDB-与-MyISAM-的区别"><a href="#InnoDB-与-MyISAM-的区别" class="headerlink" title="InnoDB 与 MyISAM 的区别"></a>InnoDB 与 MyISAM 的区别</h3><blockquote><p>MyISAM是MySQL的默认数据库引擎（5.5版之前）,其提供了⼤量的特性，包括全⽂索引、压缩、空间函数等，但MyISAM不⽀持事务和行级锁，而且最⼤的缺陷就是崩溃后无法安全恢复，所以MySQL 5.5版本后默认的存储引擎修改为InnoDB。</p></blockquote><table><thead><tr><th align="center"></th><th align="center">InnoDB</th><th align="center">MyISAM</th></tr></thead><tbody><tr><td align="center">事务与锁</td><td align="center">支持事务和行级锁</td><td align="center">只支持表级锁</td></tr><tr><td align="center">存储结构</td><td align="center">两个（.frm .ibd ）</td><td align="center">三个（.frm .MYI .MYD）</td></tr><tr><td align="center">表主键</td><td align="center">没有会自动创建6字节主键</td><td align="center">允许没有任何索引和主键</td></tr><tr><td align="center">表行数</td><td align="center">未生成最大行数（count效率低）</td><td align="center">生成最大行数（count效率高）</td></tr><tr><td align="center">外键</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">CURD操作</td><td align="center">trancate table（用于删除大量行）</td><td align="center">适用于大量select 操作</td></tr><tr><td align="center">应用场景</td><td align="center">大型高并发应用</td><td align="center">小型应用</td></tr></tbody></table><ul><li>表级锁： MySQL中锁定<strong>粒度最大</strong>的⼀种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最⼤，触发锁冲突的概率最高，并发度最低， MyISAM和 InnoDB引擎都支持表级锁。 </li><li>行级锁： MySQL中锁定<strong>粒度最小</strong>的⼀种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><h2 id="mysql-事务"><a href="#mysql-事务" class="headerlink" title="mysql 事务"></a>mysql 事务</h2><p>事务：一系列增删改查等操作所组成的一个逻辑执行单元</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200805170325.png" alt=""></p><h3 id="事务的语法"><a href="#事务的语法" class="headerlink" title="事务的语法"></a>事务的语法</h3><p>事务开启： start transaction;/ begin;</p><p>提交：commit; 使得当前的修改确认</p><p>回滚：rollback; 使得当前的修改被放弃</p><h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><ul><li><strong>原子性</strong></li></ul><p>事务是最小的执行单位，事务开启后，操作要么全部成功，要么全部失败；</p><blockquote><p>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执⾏过程中出错， 会回滚到事务开始前的状态，所有的操作就像没有发⽣⼀样。也就是说事务是⼀个不可分割的整体，就像化学中学过的原⼦，是物质构成的基本单位。</p></blockquote><ul><li><strong>一致性</strong></li></ul><p>执行事务前后，数据保持一致，多个事务对同一数据的读取结果相同；（理解成数据的总和相同）A+ 则B-</p><ul><li><strong>隔离性</strong></li></ul><p>并发访问数据库时，⼀个用户的事务不被其他事务所⼲扰，各并发事务 之间数据库是独⽴的；</p><ul><li><strong>持久性</strong></li></ul><p>⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响； （写入磁盘，除非硬盘损坏）</p><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><p><strong>丢失修改：</strong>指一个事务读取一个数据时，另一个事务也对这个数据进行了读取，如果两个事务都对此数据进行了修改，那么前者的数据修改将会丢失；</p><p><strong>脏读：</strong>读到了未提交的数据； 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的 数据是脏数据。</p><p><strong>不可重复读：</strong>同⼀条命令返回不同的结果集；.事务 A 多次读取同⼀数据，事务 B 在事务A 多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同⼀数据时，结果不⼀致；</p><p><strong>幻读：</strong>重复查询的过程中，数据就发⽣了量的变化（insert， delete）</p><ul><li>诡异的更新事件：<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/1-15.jpg" alt=""></li></ul><p><strong>不可重复读和幻读区别：</strong> 不可重复读的重点是修改，比如多次读取⼀条记录发现其中某些列的值被修改，幻读的重点在于新增或删除，⽐如多次读取⼀条记录发现记录增多或减少了；</p><p><strong>顺序读：</strong> 隔离的最高级别，事务依次逐个进行，不允许并发执行；</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200805185614.png" alt=""></p><p>MySQL InnoDB 存储引擎的默认⽀持的隔离级别是 REPEATABLE-READ（可重读）；<br>mysql 5.7 可通过 <code>select @@tx_isolation;</code> 来查看；<br>mysql 8.0 以上可通过<code>select @@transaction_isolation;</code> 来查看；</p><h3 id="不同的隔离级别的锁的情况"><a href="#不同的隔离级别的锁的情况" class="headerlink" title="不同的隔离级别的锁的情况"></a>不同的隔离级别的锁的情况</h3><ol><li>读未提交（RU）: 有行级的锁，没有间隙锁。它与RC的区别是能够查询到未提交的数据。</li><li>读已提交（RC）：有行级的锁，没有间隙锁，读不到没有提交的数据。</li><li>可重复读（RR）：有行级的锁，也有间隙锁，每次读取的数据都是⼀样的，并且没有幻读的情况，存在诡异更新的情况。</li><li>序列化（S）：有行级锁，也有间隙锁，读表的时候，就已经上锁了</li></ol><h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><blockquote><p>事务中输入DDL(Data Define Language) 定义语句时，如(建库,建表,修改表,索引操作,存储过程,视图<strong>等修改表结构的操作</strong>)，都会将修改的结果进行隐式提交；</p></blockquote><h3 id="多版本控制MVCC"><a href="#多版本控制MVCC" class="headerlink" title="多版本控制MVCC"></a>多版本控制MVCC</h3><p>MVCC : 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><a href="https://blog.csdn.net/qq_34337272/article/details/80611486" target="_blank" rel="noopener">Mysql锁机制简单了解</a></p><h2 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h2><p>当MySQL单表记录数过⼤时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下：</p><ul><li>限定数据的范围</li></ul><p>添加限制条件，尽量少使用 * 的查找，除非表数据较少；</p><ul><li>读/写分离</li></ul><p>经典的数据库拆分⽅案，主库负责写，从库负责读；</p><ul><li><p>垂直分区</p></li><li><p>数据库分片</p></li></ul><p>MySQL大表优化⽅案：<a href="https://segmentfault.com/a/1190000006158186" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006158186</a></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="mysql-存储过程"><a href="#mysql-存储过程" class="headerlink" title="mysql 存储过程"></a>mysql 存储过程</h3><p> mysql存储：将一段SQL 语句打包成一个方法存储下来，处理速度更快，因为是预编译好的方法体；</p><p><strong>创建过程</strong></p><p><code>\d //</code>修改MySQL默认的语句结尾符 ; 改为 // （因为多条语句中会穿插分号；） </p><p><code>create procedure</code> 创建语句 </p><p>BEGIN和END语句⽤来限定存储过程体</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- 定义存储过程</span><br><span class="line">\d //</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">set @i=10;</span><br><span class="line">while @i&lt;90 do</span><br><span class="line">insert into users values(null,concat('user:',@i),@i,0);</span><br><span class="line">set @i=@i+1;</span><br><span class="line">end while;</span><br><span class="line">end;</span><br><span class="line">//</span><br><span class="line">\d ;</span><br></pre></td></tr></tbody></table></figure><p>查看存储过程：<code>show create procedure p1\G</code></p><p>删除存储过程：<code>drop procedure p1</code></p><p><strong>总结</strong></p><ul><li><p>业务逻辑不要封装在数据库里面,应该由应用程序（ JAVA、Python、PHP）处理。 </p></li><li><p>让数据库只做它擅长和必须做的，减少数据库资源和性能的消耗。 </p></li><li><p>维护困难，大量业务逻辑封装在存储过程中，造成业务逻辑很难剥离出来；动A影响B。 </p></li><li><p>人员也难招聘，因为既懂存储过程，又懂业务的⼈少，使用困难。</p><p><strong>在电信、银行业、金融饭店以及国企都普遍使用存储过程来熟悉业务逻辑，但在互联网中相对较少。</strong></p></li></ul><h3 id="mysql触发器"><a href="#mysql触发器" class="headerlink" title="mysql触发器"></a>mysql触发器</h3><blockquote><ul><li><p>触发器是MySQL响应写操作(增、删、改)而自动执行的一条或一组定义在BEGIN和END之间的 MySQL语句</p></li><li><p>执行触发器类似于JavaScript中的事件</p></li></ul></blockquote><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt</span><br><span class="line"># 说明：</span><br><span class="line"># trigger_name：触发器名称</span><br><span class="line"># trigger_time:触发时间，可取值：BEFORE或AFTER</span><br><span class="line"># trigger_event：触发事件，可取值：INSERT、UPDATE或DELETE。</span><br><span class="line"># tb1_name：指定在哪个表上</span><br><span class="line"># trigger_stmt：触发处理SQL语句。</span><br><span class="line"></span><br><span class="line">-- 查看所有的 触发器</span><br><span class="line">show triggers\G</span><br><span class="line">-- 删除触发器</span><br><span class="line">drop trigger trigger_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 举例：创建⼀个删除的触发器,在users表中删除数据之前,往del_users表中添加⼀个数据</span><br><span class="line"></span><br><span class="line">-- 1,复制当前的⼀个表结构</span><br><span class="line">create table del_users like users;</span><br><span class="line"></span><br><span class="line">-- 2,创建 删除触发器 注意在创建删除触发器时,只能在删除之前才能获取到old(之前的)数据</span><br><span class="line">\d //</span><br><span class="line">create trigger deluser before delete on users for each row</span><br><span class="line">begin</span><br><span class="line">insert into del_users values(old.id,old.name,old.age,old.account);</span><br><span class="line">end;</span><br><span class="line">//</span><br><span class="line">\d ;</span><br></pre></td></tr></tbody></table></figure><p><strong>tips：</strong></p><ul><li><strong>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行</strong></li><li><strong>在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，访问被删除的行</strong></li><li><strong>在UPDATE触发器代码中，可以引用NEW/ OLD 来访问被删除或被插入的行</strong></li></ul><p><strong>注意：</strong> <strong>OLD中的值全都是只读的，不能更新；在AFTER DELETE的触发器中无法获取OLD虚拟表</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- 练习：</span><br><span class="line">-- 1.创建⼀个表, users_count ⾥⾯有⼀个 num的字段 初始值为0或者是你当前users表中的count</span><br><span class="line">-- 2,给users表创建⼀个触发器</span><br><span class="line">-- 当给users表中执⾏insert添加数据之后,就让users_count⾥⾯num+1,</span><br><span class="line">-- 当users表中的数据删除时,就让users_count⾥⾯num-1,</span><br><span class="line">-- 想要统计users表中的数据总数时,直接查看 users_count</span><br><span class="line"></span><br><span class="line">\d //</span><br><span class="line">create trigger addcount after insert on users for each row</span><br><span class="line">begin</span><br><span class="line">update user_count set num = num+1;</span><br><span class="line">end;</span><br><span class="line">create trigger delcount before delete on users for each row</span><br><span class="line">begin</span><br><span class="line">update user_count set num = num-1;</span><br><span class="line">end;</span><br><span class="line">//</span><br><span class="line">\d ;</span><br></pre></td></tr></tbody></table></figure><h3 id="mysql-视图"><a href="#mysql-视图" class="headerlink" title="mysql 视图"></a>mysql 视图</h3><p><strong>什么是视图？</strong> </p><blockquote><ul><li>可以理解成用sql查询语句创建的一个表，用于查看符合查询语句条件的数据；</li><li>视图本身不包含数据，返回的数据是通过其他表查询而来</li><li>对视图进行增删修改等操作，实际是操作查询的原数据表</li><li></li></ul><p><strong>总结：</strong>视图是对SQL 查询语句的封装，不包含任何数据，具有表的结构体，可以增删改查（操作查询的那个表）</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- 创建过程</span><br><span class="line">create view v_table as SQL select...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show tables; -- 可以查看到所有的表和视图</span><br><span class="line">show table status where comment='view'\G -- 只查看当前库中的所有视图</span><br><span class="line"></span><br><span class="line">drop view v_table; -- 删除视图</span><br></pre></td></tr></tbody></table></figure><blockquote><p> 总结一下：mysql存储相当于是定义一个方法体，mysql触发器是在（增、删、修改）事件发生前/后执行某某操作，mysql视图是封装一段动态的查询语句；</p></blockquote><h2 id="索引与优化"><a href="#索引与优化" class="headerlink" title="索引与优化"></a>索引与优化</h2><h3 id="索引的概述与分类"><a href="#索引的概述与分类" class="headerlink" title="索引的概述与分类"></a>索引的概述与分类</h3><p>什么是索引？</p><ul><li><p>类似于图书的目录，提高数据检索效率，降低数据库的IO成本 </p></li><li><p>也可以理解成一种快速查找排好序的数据结构</p></li></ul><p>索引分类（按查找效率）：</p><ul><li>主键索引 ：根据主键建立索引，不允许重复，不为空；</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a1.png" alt=""></p><ul><li>唯一索引  ：用来建立索引的列的值必须是唯一的，允许为空值</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806154340.png" alt=""></p><ul><li>普通索引：用表中的普通列构建的索引，没有限制</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806154501.png" alt=""></p><ul><li>全文索引：大文本对象的列来构建索引（分池）</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806154808.png" alt=""></p><ul><li><p>组合索引：用多个列组合构建的索引，多个列中不允许有空值</p><p>组合索引的最左前缀原则，如上图所示，必须从email开始查找，不能直接从phone开始查；</p></li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a0806.jpg" alt=""></p><h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>MySQL索引的数据结构：</p><ul><li><p>哈希索引（用于memory存储引擎,速度快，散列分布，不支持范围查找与排序）</p></li><li><p>B+TREE索引，大部分场景都使用此数据结构进行索引</p></li></ul><p>正常情况下，在mysql中如果不指定索引的类型，那么⼀般是指B+Tree索引（或者B+Tree索引）。</p><h3 id="B-树与B-树比较"><a href="#B-树与B-树比较" class="headerlink" title="B 树与B+树比较"></a>B 树与B+树比较</h3><p>下图一个三阶的B树，每一个节点都带有数据，倘若需要范围查找，比如查找1-5中的数据，此时需要遍历9次</p><p>数字： 1 2 3 4 5</p><p>步数： 3 4 5 7 9</p><p>所以使用B树会有以下缺点：</p><ol><li>查找效率不均一 </li><li>范围查找需要中序遍历（返回上层查找）</li><li>每⼀个叶子结点上都带有数据（地址不连续）</li></ol><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806181409.png" alt=""></p><p>再来看看B+树</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806183054.png" alt=""></p><p>B+ 树相对于 B树的优势：</p><ol><li>磁盘的读写代价更低：B树是索引与数据一起存储，读深层数据IO次数多，B+ 树索引部分只存索引，相同的块空间存储的索引更多</li><li>随机IO次数更少：随机IO指读取地址不连续的数据，相较而言B树的随机IO明显多余B+树，B+树则是顺序IO较多</li><li>查询速度更稳定：B+树查询的所有数据都要到叶子节点；</li></ol><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p>用主键建立的索引为主索引，其余为辅助索引（数据和索引分离），主键索引只有一个，辅助索引可以有很多个；</p><ul><li><p>聚簇索引：能通过索引找到要查找的数据</p></li><li><p>非聚簇索引：通过索引只能找到索引值和key，如果查找其他数据需要回表（去主键索引中查找数据）</p></li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/2020-08.jpg" alt=""></p><p>myISAM也使用了B+树的数据结构来存储数据，只是在其叶子节点中只存储了索引和行号，即需要查找数据都要根据行号去对应的文件中查找，这种行为我们称之为 ‘回行’ ；</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806212553.png" alt=""></p><p><strong>总结</strong></p><p>InnoDB 中的主键索引是聚簇索引，其余的辅助索引为非聚簇索引；</p><p>MyISAM中的主键索引与辅助索引都是非聚簇索引；</p><h2 id="慢查询与SQL优化"><a href="#慢查询与SQL优化" class="headerlink" title="慢查询与SQL优化"></a>慢查询与SQL优化</h2><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>即慢查询日志，即用来记录响应时间超过查询阈值的语句；一般除非调优，不需要开启，会影响性能；</p><p>慢查询⽇志可用于查找需要很长时间才能执行的查询，因此是优化的候选者。</p><p>慢查询语法：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- 查看慢查询配置</span><br><span class="line">show variables like '%slow%';  </span><br><span class="line"></span><br><span class="line">-- 查看慢查询时间定义</span><br><span class="line">show variables like 'long_query_time';</span><br><span class="line"></span><br><span class="line">-- 设置慢查询的时间定义</span><br><span class="line">set long_query_time=2;</span><br><span class="line"></span><br><span class="line">-- 开启慢日志</span><br><span class="line">set global slow_query_log ='ON';</span><br></pre></td></tr></tbody></table></figure><p>通过慢查询日志以及 explain 来对查询进行解析</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806215907.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806220108.png" alt=""></p><p>建立无用的索引会浪费磁盘空间，虽然可以显著提高查找效率；1000W条数据量大概的存储空间为800M，增加一个主键索引变成了1.2G；过多的索引也会影响写入性能；相对应的维护成本也会提高；</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p><strong>适当建立索引</strong></p><ol><li>创建并使用自增数字建立主键索引</li><li>经常使用的where字段才建立索引</li><li>添加索引尽可能的保持一致性</li><li>可考虑联合索引进行索引覆盖</li></ol><p><strong>合理使用索引</strong></p><ol><li>不要在列上使用函数或进行计算：如 select * from news where year(public_time) =2017 或 select * from news where id/100 = 1;</li><li>防止两侧数据不一致导致隐式转换</li></ol><p><strong>注意：当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。</strong></p><ol start="3"><li>like 语句的索引失效问题</li></ol><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806223133.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806223319.png" alt=""></p><h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><ol><li>避免嵌套语句（子查询）</li><li>避免多表查询（复杂查询简单化）</li></ol><h2 id="mysql-相关文章推荐"><a href="#mysql-相关文章推荐" class="headerlink" title="mysql 相关文章推荐"></a>mysql 相关文章推荐</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485097&amp;idx=1&amp;sn=84c89da477b1338bdf3e9fcd65514ac1&amp;chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&amp;token=79317275&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">一条SQL语句在MySQL中如何执行的</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485117&amp;idx=1&amp;sn=92361755b7c3de488b415ec4c5f46d73&amp;chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&amp;token=79317275&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">MySQL高性能优化规范建议</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485185&amp;idx=1&amp;sn=66ef08b4ab6af5757792223a83fc0d45&amp;chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&amp;token=79317275&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">腾讯⾯试：⼀条SQL语句执⾏得很慢的原因有哪些？—不看后悔系列</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486461&amp;idx=1&amp;sn=60a22279196d084cc398936fe3b37772&amp;chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&amp;token=1987003517&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">书写高质量SQL的30条建议</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> SQL语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法的学习之路</title>
      <link href="/posts/22223.html"/>
      <url>/posts/22223.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法学习之路"><a href="#算法学习之路" class="headerlink" title="算法学习之路"></a>算法学习之路</h1><h2 id="20道比较经典的算法题"><a href="#20道比较经典的算法题" class="headerlink" title="20道比较经典的算法题"></a>20道比较经典的算法题</h2><h4 id="来道开胃菜：欧几里得算法"><a href="#来道开胃菜：欧几里得算法" class="headerlink" title="来道开胃菜：欧几里得算法"></a>来道开胃菜：欧几里得算法</h4><p>其实也就是求最大公约数，代码如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="number">0</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">int</span> r = p%q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q,r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>三行代码就求出来了， 是不是很优雅的操作，假如 p &gt; q ，返回的是正常求余，然后递归，假如 p &lt; q ，则返回两者的交换值，继续正常求余操作，递归的到结果；</p><p>个人觉得，优雅的书写代码前提之一就是学好算法；</p><h4 id="1-KMP算法"><a href="#1-KMP算法" class="headerlink" title="1. KMP算法"></a>1. KMP算法</h4><h4 id="2-替换空格"><a href="#2-替换空格" class="headerlink" title="2. 替换空格"></a>2. 替换空格</h4><blockquote><p>算法题：剑指offer：请实现⼀个函数，将⼀个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy</p><p>知识点：StringBuffer 的常用方法、String API</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 方法一 暴力替换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>{</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> length = str.length();</span><br><span class="line">    <span class="comment">// System.out.println("length=" + length);</span></span><br><span class="line">    StringBuffer result = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) {</span><br><span class="line">        <span class="keyword">char</span> b = str.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (String.valueOf(b).equals(<span class="string">" "</span>)) {</span><br><span class="line">            result.append(<span class="string">"%20"</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            result.append(b);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line"> }</span><br><span class="line"><span class="comment">// 方法二 使用String API </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceSpace</span><span class="params">(StringBuffer str)</span> </span>{</span><br><span class="line"><span class="keyword">return</span> str.toString().replaceAll(<span class="string">" "</span>,<span class="string">"%20"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-最长公共前缀"><a href="#3-最长公共前缀" class="headerlink" title="3. 最长公共前缀"></a>3. 最长公共前缀</h4><blockquote><p>Leetcode: 编写⼀个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”</p><p>示例：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输⼊: ["flower","flow","flight"]</span><br><span class="line">输出: "fl"</span><br><span class="line"></span><br><span class="line">输⼊: ["dog","racecar","car"]</span><br><span class="line">输出: ""</span><br><span class="line">解释: 输⼊不存在公共前缀。</span><br></pre></td></tr></tbody></table></figure><p>知识点：数组排序 Arrays.sort()</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 思路：先利⽤Arrays.sort(strs)为数组排序，再将数组第⼀个元素和最后⼀个元素的字符从前往后对⽐即可！</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">common</span><span class="params">(String[] strs)</span></span>{</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span>(!checkNull(strs)){</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> len = strs.length;</span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        Arrays.sort(strs);</span><br><span class="line">        <span class="keyword">int</span> m = strs[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">int</span> n = strs[len - <span class="number">1</span>].length();</span><br><span class="line">        <span class="keyword">int</span> num = Math.min(m, n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) {</span><br><span class="line">            <span class="keyword">if</span> (strs[<span class="number">0</span>].charAt(i) == strs[len - <span class="number">1</span>].charAt(i)) {</span><br><span class="line">                res.append(strs[<span class="number">0</span>].charAt(i));</span><br><span class="line">            } <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkNull</span><span class="params">(String[] strs)</span></span>{</span><br><span class="line">        <span class="comment">// 定义返回值</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (String str : strs) {</span><br><span class="line">            <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.length()!=<span class="number">0</span>) {</span><br><span class="line">                flag = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                flag = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="comment">// 测试</span></span><br><span class="line">        String[] st = {<span class="string">"abc"</span>,<span class="string">"ab"</span>,<span class="string">"ac"</span>};</span><br><span class="line">        <span class="comment">//String[] st = {null};</span></span><br><span class="line">        <span class="comment">//String[] st = {""};</span></span><br><span class="line">        System.out.println(Demo1.common(st));</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h4 id="4-回文串"><a href="#4-回文串" class="headerlink" title="4. 回文串"></a>4. 回文串</h4><h5 id="最长回文串"><a href="#最长回文串" class="headerlink" title="最长回文串"></a>最长回文串</h5><blockquote><p><strong>LeetCode: 给定⼀个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。在构造过程中，请注意区分大小写。比如 “Aa” 不能当做⼀个回文字符串。注意:假设字符串 的长度不会超过 1010。</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">输⼊:</span><br><span class="line">"abccccdd"</span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line">解释:我们可以构造的最⻓的回⽂串是"dccaccd", 它的⻓度是 7。</span><br></pre></td></tr></tbody></table></figure><p>分析：回文串出现的两种情况：</p><ol><li>字符出现次数为双数的组合 ；如：abccba</li><li>字符出现次数为双数的组合+⼀个只出现⼀次的字符 ；如：abcba</li></ol></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">// 思路： 找到一组重复字符，则count++，然后进行移除，查找下一组重复的字符，最后统计为，情况一则是count*2（没有剩余字符，均两两配对成功），若存在剩余字符，则结果为count*2+1;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span></span>{</span><br><span class="line">        <span class="keyword">if</span> (s.length()==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        HashSet&lt;Character&gt; hashSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">            <span class="keyword">if</span> (!hashSet.contains(s.charAt(i))){</span><br><span class="line">                hashSet.add(s.charAt(i));</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                hashSet.remove(s.charAt(i));</span><br><span class="line">                count++;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> hashSet.isEmpty()?count*<span class="number">2</span>:count*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h5 id="验证回文串"><a href="#验证回文串" class="headerlink" title="验证回文串"></a>验证回文串</h5><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机之初出茅庐</title>
      <link href="/posts/63558.html"/>
      <url>/posts/63558.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h1><hr><h2 id="来一些干历史"><a href="#来一些干历史" class="headerlink" title="来一些干历史"></a>来一些干历史</h2><h3 id="世界上第一款商用Java虚拟机"><a href="#世界上第一款商用Java虚拟机" class="headerlink" title="世界上第一款商用Java虚拟机"></a>世界上第一款商用Java虚拟机</h3><blockquote><p>是什么呢？ 它就是我们如今虚拟机的始祖，Sun Classic虚拟机</p><p>这款虚拟机发布于JDK1.0版本，离我们已经相当遥远了，它只能通过纯解释器方式来执行Java代码，如果此时要使用即时编译器，那么这个虚拟机的解释器就只能进行外挂，而外挂的结果就是编译器完全接管了虚拟机的执行系统，解释器不能进行正常工作；</p><p>可见古老的科技还是比较落后的，没有特变强大的适应力；</p></blockquote><h3 id="如今的主流虚拟机：Hotspot-VM"><a href="#如今的主流虚拟机：Hotspot-VM" class="headerlink" title="如今的主流虚拟机：Hotspot VM"></a>如今的主流虚拟机：Hotspot VM</h3><blockquote><p>没错，这台虚拟机就是我们如今现在正在使用的Java虚拟机，也是目前使用范围最广的虚拟机，他是Sun/OracleJDK 中的默认虚拟机，它最强大的功能就是像它名字所说的“热”技术，也就是热点代码探测技术，热点探测技术可以通过执行计数器找出最具有编译价值的代码，然后通知及时编译器以方法为单位进行编译；</p><p>那它主要的结构是什么呢？</p><p>它的即时编译系统主要有两部分，第一部分是主要负责编译耗时短，输出代码优化程度比较低的客户端编译器，简称C1，另一部分是编译耗时时间长，但代码优化质量比较高的服务端编译器，简称C2；他们通常会在分层编译的机制下与解释器相互配合来共同构成Hotspot虚拟机的执行子系统（抱歉，不是太了解什么是执行子系统，在这里就不要多提问了！）</p><p>自JDK10起，Hotspot 编译器中又多加了一个新“兄弟”：Graal编译器，它的长远目标是用于替代C2的，尽管如今的C2还能用，但是由于历史长久的原因，它的身材已经过于庞大了，维护起来相当困难，已经连当初创作它的Cliiff Click博士本人都不愿意去维护这个庞大的家伙；所以，Graal 编译器应运而生，目前Graal 编译器的性能已经基本上与C2持平了，个人觉得取代只是迟早的事情；</p></blockquote><h3 id="黑科技之Graal-VM"><a href="#黑科技之Graal-VM" class="headerlink" title="黑科技之Graal VM"></a>黑科技之Graal VM</h3><blockquote><p>2018年4月，Oracle Labs公开了一项黑科技，Graal VM，它是在HotSpot 虚拟机的基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台来使用；在此不再过多赘述了，有兴趣的可以了解一下，据称是未来可以替代Hotspot的候选项；</p></blockquote><p>在此总结一下：Java为什么能成为世界第一的计算机编程语言，一方面出于它结构严谨，面向对象的思想，另一方面是多平台的优势，即编译一次，随处运行，而多平台归功于Java虚拟机的强大，虚拟机帮助它实现了热点代码检测以及运行时编译及优化；此外，还有它的开源性以及强大的第三方类库，帮助着用户解决各种各样的难题········</p><h2 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h2><p>我们之前学过，虚拟机的运行时内存划分为 栈，堆，方法区、PC寄存器、本地方法栈五大类；在这里我按照虚拟机相关的书籍大概总结了一下，如图：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200718110626591.png" alt=""></p><p>我们先来明确一个概念：什么是<strong>线程私有</strong>内存；</p><blockquote><p>线程私有内存，通俗来讲就是各线程之间互不影响，独自存储和使用的内存空间，称之为线程私有内存；</p></blockquote><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote><p>程序计数器（Program Counter Register）也叫PC寄存器，它在虚拟机中的主要作用是记录线程执行的字节码的行号指示器；</p><p>在编译过程中，字节码解释器怎么获取下一行应该执行什么内容呢？它通过改变程序计数器的值，来获取下一行需要执行的字节码指令；可以把它看成是程序控制的一个指示器，循环，跳转，异常处理，线程恢复，都依赖于计数器的指示下进行；</p><p>另外，除了引导程序流，它还是多线程轮流切换的一个flag；A 线程跳转到 B 线程后，怎么回到A 呢，这个时候靠程序计数器的引导下回来；所以，程序计数器是线程私有内存，每一个线程只能拥有一个程序计数器；</p><p>此外，当线程执行的是Java方法时，程序计数器几率的是虚拟机字节码指令的地址，如果执行的是本地方法时，计数器记录的是空；</p></blockquote><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote><p>虚拟机栈，也就是我们平常所说的 “栈”，只不过我们一般只关注它的局部变量部分；虚拟机栈描述的是Java方法执行的线程内存模型，即每个方法被执行的时候，虚拟机都会同步创建一个<strong>栈桢</strong>来存储局部变量表，操作数栈、动态连接、方法出口等信息。当一个方法被调用的，对应着一个栈桢在虚拟机栈中入栈，一个方法执行完，对应从虚拟机中出栈；一个方法对应着一个栈桢；</p><p>虚拟机栈空间也是线程私有的，它与线程的生命周期相同，同生共死；</p><p>局部变量表存储着各种基本数据类型（int/float/char/double…..)以及对象引用（reference，指向对象起始地址的引用指针）和 returnAddress （指向一条字节码指令的地址）；这些数据类型在局部变量表的存储形式以局部变量槽（Slot）的形式体现，其中long、double 类型的数据会占两个变量槽，其余类型的数据占一个，具体如图所示</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200718115902122.png" alt=""></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote><p>本地方法栈与虚拟机栈的作用类似，主要区别就是本地方法栈对应的是本地方法(Native Method)，本地方法指其它编程语言的方法，类如（C、C++等），在读取.dll文件内的方法时，Java调用非Java代码的接口，就会开启本地方法栈；在此不多做描述；</p></blockquote><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><blockquote><p>堆（Heap）大家应该比较熟悉，是整个虚拟机所管理内从中最大的一块，也是被所有线程所共享的一块内存区域；此内存区块存在的唯一目的就是存放对象实例，没错，就是<strong>new 对象</strong>；基本可以认为，所有的实例对象都存放于堆中；同时，Java堆也只能存放实例对象；</p><p>Java堆内存是垃圾回收器重点关注区域，所以有一些资料也称其为 GC堆；按照以往的垃圾回收器机制来划分，堆可以划分为“新生代、老年代、永久代、Eden、Survivor·······”；但站在目前的角度来说，应该根据虚拟机所用的堆内存垃圾回收器的具体机制来划分；</p><p>堆中内存的分配方式：这个涉及到 虚拟机的类加载机制，我还没研究透，但总体来说有两种；</p><p>第一种是基于堆内存空间规整的分配方式，这个条件下，堆内存的分配方式为“指针碰撞”；</p><p>第二种是堆内存空间不规整的情况下划分，这种情况没有办法进行简单的指针碰撞，需要通过一个列表来记录，哪些内存是可用的，找到一块足够大，能装的下对象内存的区域后，再划分给对象，这种分配方式叫“空闲列表”；</p></blockquote><h3 id="方法区（没想好怎么写）"><a href="#方法区（没想好怎么写）" class="headerlink" title="方法区（没想好怎么写）"></a>方法区（没想好怎么写）</h3><blockquote><p>方法区与堆 一样，是各个线程共享的内存区域，用于储存已经被虚拟机加载的类型信息、常量、静态变量、即时编译器后的代码缓存等数据；它有个有意思的别名，叫做 <strong>非堆</strong>。</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20171115215708642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ2JpYW8wMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之九阳神功秘籍</title>
      <link href="/posts/48121.html"/>
      <url>/posts/48121.html</url>
      
        <content type="html"><![CDATA[<h1 id="多线程之旅"><a href="#多线程之旅" class="headerlink" title="多线程之旅"></a>多线程之旅</h1><hr><h2 id="什么是多线程？"><a href="#什么是多线程？" class="headerlink" title="什么是多线程？"></a>什么是多线程？</h2><p>我们先来看看，什么是线程：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710152151.png" alt="进程与线程"></p><p><strong>问题1：不运行的程序，是什么？</strong></p><blockquote><p>程序可以理解成一个静态的指令集合，当系统运行程序时， 程序中的指令就被激活了，转变成进程开始执行任务。</p></blockquote><p><strong>问题2：进程之间会相互影响吗？</strong></p><blockquote><ol><li>进程是系统中独立存在的实体，每一个进程都拥有自己私有的地址空间。在没有经过进程本身的允许的情况下，一个用户进程是不可以直接访问其他进程的地址空间的；</li><li>多个进程可以在单个处理器上并发执行，并且多进程之间不会互相影响。</li></ol></blockquote><p><strong>问题3：线程之间会互相影响吗？</strong></p><blockquote><p>线程可以理解成进程的执行单元，一个线程必须有一个父进程，当进程被初始化，主线程就创建了，它们共享着父进程的内存资源。线程可以拥有自己的堆栈，自己的程序计数器和自己的局部变量，但不拥有系统资源；他们可以通过调用父线程的资源来相互影响，但是要做到不要相互妨碍；</p></blockquote><blockquote><p>总结起来就是一句话，一个程序的运行，至少依托着一个进程的支持，一个进程的运行，至少需要一个线程；</p></blockquote><p><strong>多线程的优势(相较于多进程)</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. 进程之间不能共享内存，线程之间能轻易实现内存的共享；</span><br><span class="line"></span><br><span class="line">2. 系统创建进程需要为该进程重新分配系统资源，而创建线程的代价相比之下就小得多，因此使用多线程来实现任务并发就比多进程的效率高；</span><br><span class="line"></span><br><span class="line">3. Java语言内置了多线程功能的支持，而不是单纯地作为底层操作系统的调度方式，从而简化了Java的多线程编程。</span><br></pre></td></tr></tbody></table></figure><h2 id="线程的创建与启动"><a href="#线程的创建与启动" class="headerlink" title="线程的创建与启动"></a>线程的创建与启动</h2><blockquote><p>三种方法：1. 继承Thread类创建；2. 实现Runnable接口创建；3. 使用Callable和Future创建</p></blockquote><h3 id="第一种继承创建"><a href="#第一种继承创建" class="headerlink" title="第一种继承创建"></a>第一种继承创建</h3><p>见如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"多线程不好玩"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"多线程真好玩"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>运行结果中能看到交替运行:<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710162128.png" alt="运行结果"></p></blockquote><blockquote><p>当然，这么写有点麻烦，因为Mythread子类只用了一次，可以创建匿名内部类的形式简化上述代码:</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++){</span><br><span class="line">                    System.out.println(<span class="string">"多线程好玩:"</span>+i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++){</span><br><span class="line">            System.out.println(<span class="string">"多线程真好玩:"</span>+i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第二种Runnable接口创建（最常用）"><a href="#第二种Runnable接口创建（最常用）" class="headerlink" title="第二种Runnable接口创建（最常用）"></a>第二种Runnable接口创建（最常用）</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"多线程真好玩"</span>);</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"多线程不好玩"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>由于这个Runnable 接口只有run这一个方法需要实现，所以可以利用<strong>Lambda</strong>表达式来进一步简化：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"多线程真好玩"</span>+i);</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"多线程不好玩"</span>+i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第三种Callable创建（带有返回值的接口线程创建）"><a href="#第三种Callable创建（带有返回值的接口线程创建）" class="headerlink" title="第三种Callable创建（带有返回值的接口线程创建）"></a>第三种Callable创建（带有返回值的接口线程创建）</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        Callable&lt;Integer&gt; c = <span class="keyword">new</span> MyCallable&lt;&gt;();</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(c);</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        System.out.println(<span class="string">"子线程的返回值为："</span>+task.get());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">            System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span>&lt;<span class="title">Interger</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：如果子线程与主线程之间存在 task.get() 获取子线程的返回值，主线程会等待返回值得到，也就是子线程执行完，再开始执行主线程；<br>如果想停止子线程的运行，通过task.cancel()来停止</p></blockquote><h3 id="三种创建方法的比较"><a href="#三种创建方法的比较" class="headerlink" title="三种创建方法的比较"></a>三种创建方法的比较</h3><blockquote><p>Thread继承与Runnable创建比较<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710172644.png" alt="比较"><br>Runnable 与 Callable 比较：<br>Runnable不带返回值，代码实现简单，对主线程影响较小;<br>而Callable带返回值，除了实现call方法外，还要用FutureTask 类来实现返回值的调用，并且调取get()方法会引起主线程阻塞；</p></blockquote><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><blockquote><p>按照老师的课程，线程的执行过程中，有一下6种状态：New(新建状态)，Runnable(运行状态)，Blocker(阻塞状态)，Waiting/TimedWaiting(有限等待、无限等待状态)，Teminated(终止状态)</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710174520.png" alt="线程的6种状态"></p><blockquote><p>查阅了相关书籍后，我觉得按照这个图来形容来划分比较合理：</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200711095406.png" alt=""></p><blockquote><p>为什么start()后要划分成就绪跟运行状态？<br>由于线程启动后，不会一直“霸占”着CPU来执行，CPU会在多线程之间来回切换，所以线程也会在运行，就绪之间往复交替；</p></blockquote><h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><blockquote><p><strong>设置守护线程：</strong><br>(线程的引用)t.setDaemon(true)<br>守护线程的概念，守护线程也可以叫后台线程，其特征为：当所有的前台线程死亡后，后台线程自动结束，（）内输入 true 为设置成守护线程，不输入或者输入false,为不设置；<br>JVM 的垃圾回收就是典型的后台线程;</p></blockquote><blockquote><p><strong>让线程按下暂停键</strong><br>Thread.sleep()<br>在代码中插入<code>Thread.sleep()</code>后会使程序暂停一段时间，并进入阻塞状态；相比较而言，yield()方法，这个方法只会让线程重新调度一下，并不会暂停；</p></blockquote><blockquote><p><strong>改变程序的优先级</strong><br>Thread.currenttThread().setPriority(5)<br>赋予线程优先级，优先级高的更容易被执行；<br>括号内的数值范围是（1-10）,分别对应10种优先级，也可以调用三个静态常量MAX_PRIORITY/NORM_PRIORITY/MIN_PRIORITY（10/5/1）；</p></blockquote><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>想象这样一个画面：<br>A , B 同时去银行取钱，然后银行余额都显示1000元，A取500，B取1000，如果 A B两人扣款时间也一样，那银行余额是不是就变成了-500；</p><p>这样就是线程同步而引发出来的线程不安全行为；</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710211748.png" alt=""></p><p>如何去解决线程不安全：</p><blockquote><p><strong>方法1 ：同步代码块</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//代码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>{<span class="comment">//线程安全性解读一</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">           Runnable r = <span class="keyword">new</span> Ticket();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">       }</span><br><span class="line">   </span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">           <span class="comment">//总票数</span></span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span> ;</span><br><span class="line">           <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">               <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                   <span class="keyword">synchronized</span> (o) {<span class="comment">//在执行方法前插入同步代码块sychronized</span></span><br><span class="line">                       <span class="keyword">if</span>(count&gt;<span class="number">0</span>) {</span><br><span class="line">                           System.out.println(Thread.currentThread().getName() + <span class="string">"准备卖票，总票数为："</span> + count);</span><br><span class="line">                           <span class="keyword">try</span> {</span><br><span class="line">                               Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                           } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                               e.printStackTrace();</span><br><span class="line">                           }</span><br><span class="line">                           count--;</span><br><span class="line">                           System.out.println(<span class="string">"卖票成功，余票为："</span> + count);</span><br><span class="line">                       }<span class="keyword">else</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>理解如下：</p><p>当Thread-0/Thread-1/Thread-2 到达if 循环前，最先到达的那个线程会被套上 sychronized 给的标记 o，当标记 o 激活时，假定最先到达的是Thread-0，Thread-1/Thread-2 会在原地等待，等待标记消失后再向下执行，而当Thread-0执行完成if中的语句后，标记会被清除，Thread-0会随着循环再一次来到if前，而标记清除后，Thread-1/Thread-2 接收到标记消失命令，再开始往下执行；这个时候谁会执行是不一定的，取决于谁能争抢到时间片；</p></blockquote><blockquote><p><strong>方法2 ：同步方法</strong></p><p>将if后面的代码打包成一个方法，然后用synchronized进行修饰（准确说是进行装饰），代码如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>{<span class="comment">//线程安全性解读</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">        <span class="comment">//总票数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span> ;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">this</span>.sale();</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>{<span class="comment">//用synchronized修饰sale()方法，依然放在if前</span></span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"准备卖票，总票数为："</span> + count);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(<span class="string">"卖票成功，余票为："</span> + count);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p><strong>方法3 ：添加显示锁</strong></p><p>上述的两种方式相当于是隐式锁的概念，从Java 5 开始，Java官方添加了一种更强大的线程同步机制——同步锁，由Lock对象充当；</p><p>同步锁一般比较常用的是Lock对象的实现类ReentrantLock（可重入锁），代码如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>{<span class="comment">//线程安全性解读</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">           Runnable r = <span class="keyword">new</span> Ticket();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">           <span class="comment">//总票数</span></span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span> ;</span><br><span class="line">           <span class="keyword">private</span> Lock l = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">               <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                   l.lock();</span><br><span class="line">                   <span class="keyword">try</span> {</span><br><span class="line">                       <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                           System.out.println(Thread.currentThread().getName() + <span class="string">"准备卖票，总票数为："</span> + count);</span><br><span class="line">                           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                           count--;</span><br><span class="line">                           System.out.println(<span class="string">"卖票成功，余票为："</span> + count);</span><br><span class="line">                       } <span class="keyword">else</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                   }<span class="keyword">catch</span>(InterruptedException e){</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   }<span class="keyword">finally</span>{</span><br><span class="line">                       l.unlock();</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p>ReentrantLock() 括号内可传入boolean 参数，传入true后，锁就变成了公平锁，会让线程排队执行，以上述为例，会依次Thread -0（假设0线程第一个执行）、Thread-1(假设第二个执行)、Thread-2(第三个执行)，会依次 0/1/2、0/1/2的顺序（当然也可以102,201的顺序，取决于谁先抢到时间片，但第一次循环后，顺序就固定下来了）执行，直至线程结束； </p></blockquote><blockquote><p><strong>死锁</strong></p></blockquote><p>在线程同步中，添加同步监视器过多，可能会导致死锁的现象；</p><p>可以这样来理解：在A 运行的代码中加入B的锁，等待B解锁后才能向下执行；又在B运行的代码中加入A 的锁，等待 A 解锁后才向下执行，假如 A 等待 B 的时候，B又在等待 A ，这样死锁就产生了；</p><p>一旦死锁产生，整个程序不会出错，也没有任何提示，整个处于阻塞的状态，无法继续。</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><blockquote><p><strong>生产者和消费者问题：</strong></p></blockquote><p>A 是生产者，负责生产食物和数量，B 是消费者，负责接收食物和数量，想象一个场景，假如 A 生产两种食物，循环递给B，B负责消费，消费完成后 ，通知A 进行生产 ，依次按顺序循环100次，怎样进行如上的代码实现呢；</p><p>方法一：</p><p>Object 类有三个有助于线程通信的方法，wait() 使当前线程等待，notify() 随机唤醒一个线程，notifyAll()，唤醒所有线程；</p><p>利用这三个方法，再加上标签flag = ture /false ，可以很好的实现如上代码需求；具体代码就不展示了，有点占篇幅；</p><p>方法二：</p><p>使用BlockingQueue（阻塞队列）</p><p>put() 把元素放入队列，如果队列已满，则阻塞该线程</p><p>take() 从队列头取走元素，如果队列已空，则阻塞线程；</p><p>这个不是太会；后面再研究</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote><p><strong>为什么需要线程池？</strong></p></blockquote><ol><li>系统创建一个新线程的耗费是很大的，而运行一个线程耗费要小很多，运用线程池的概念，可以很好的提升系统性能；</li><li>线程池可以很好的控制系统中并发线程的数量，即在创建初直接指定并发执行的线程数；</li><li>线程池能提供定时执行、定期执行、单线程、并发数控制等功能</li></ol><blockquote><p><strong>四种线程池的创建</strong></p></blockquote><p>第一种，缓存线程池：</p><p><code>newCachedThreadPool()</code>，创建一个具有缓存功能的线程池，可灵活回收空闲线程；</p><p>第二种，定长线程池：</p><p><code>newFixedThreadPool(初始线程数)</code>，初始线程数一旦被固定，就只能使固定数量的线程并发运行；</p><p>第三种，单线程线程池</p><p><code>newSingleThreadExecutor()</code> ，创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务</p><p>第四种，周期执行线程池</p><p><code>newScheduledThreadPool()</code>，创建一个定长线程池，支持定时及周期性任务执</p><h2 id="多线程面试题"><a href="#多线程面试题" class="headerlink" title="多线程面试题"></a>多线程面试题</h2><p>参考链接：<a href="https://blog.csdn.net/cmyperson/article/details/79610870" target="_blank" rel="noopener">50个多线程面试题汇总</a></p><p><strong>什么是线程？</strong></p><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。</p><p>比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒</p><p><strong>什么是线程安全和线程不安全？</strong></p><p>线程安全: 就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染</p><p>线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p><p><strong>什么是自旋锁？</strong></p><p>当线程A想要获取一把自旋锁而该锁又被其它线程锁持有时，线程A会在一个循环中自旋以检测锁是不是已经可用了</p><p><strong>什么是乐观锁和悲观锁？</strong></p><p>悲观锁</p><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。</p><p>乐观锁</p><p>乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做</p><p>==============================</p><p>还有很多题目，详见参考链接，就不一一赘述了；</p><p>全剧终</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Finally之未解之谜</title>
      <link href="/posts/6199.html"/>
      <url>/posts/6199.html</url>
      
        <content type="html"><![CDATA[<h1 id="Finally-关键字"><a href="#Finally-关键字" class="headerlink" title="Finally 关键字"></a>Finally 关键字</h1><hr><h2 id="Finally-是什么？"><a href="#Finally-是什么？" class="headerlink" title="Finally 是什么？"></a>Finally 是什么？</h2><p>有一些代码，可能会希望try块中的异常无论是否抛出，都需要执行某一些语句，这个时候，我们就用到了finally;</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">try块语法：</span><br><span class="line">try{</span><br><span class="line"></span><br><span class="line">}catch(异常类 形参){</span><br><span class="line"></span><br><span class="line">}finally{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">try块 catch和finally可任选一个，一般两个都写，不可以两个都不写；</span><br></pre></td></tr></tbody></table></figure><h2 id="Finally常见问题"><a href="#Finally常见问题" class="headerlink" title="Finally常见问题"></a>Finally常见问题</h2><h3 id="1-try语句中有异常，finally-语句块会执行吗？"><a href="#1-try语句中有异常，finally-语句块会执行吗？" class="headerlink" title="1. try语句中有异常，finally 语句块会执行吗？"></a>1. try语句中有异常，finally 语句块会执行吗？</h3><p>这个答案是肯定的。finally语句的优先级等级很高，只要不涉及一些关键字眼，如<strong>JVM异常关闭</strong>,<strong>系统异常崩溃</strong>等，finally中的语句总是会执行的，不管是否有异常抛出。</p><h3 id="2-finally-与-continue-break之间的关系"><a href="#2-finally-与-continue-break之间的关系" class="headerlink" title="2. finally 与 continue,break之间的关系"></a>2. finally 与 continue,break之间的关系</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">continue</span>与<span class="keyword">break</span> 代表着跳出本次循环、结束本次循环，<span class="keyword">finally</span>遇上这两个代码会怎么样呢？</span><br><span class="line"></span><br><span class="line">请看以下代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) {</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//continue也一样</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }<span class="keyword">catch</span>(Exception e) {</span><br><span class="line">        System.out.println(<span class="string">"有异常，请检查"</span>);</span><br><span class="line">    }<span class="keyword">finally</span> {</span><br><span class="line">        System.out.println(<span class="string">"一定会执行"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">一定会执行</span><br><span class="line"></span><br><span class="line">可以看到即使跳出了循环，<span class="keyword">finally</span>语句中的内容依然会执行</span><br></pre></td></tr></tbody></table></figure><h3 id="3-finally与return的关系"><a href="#3-finally与return的关系" class="headerlink" title="3. finally与return的关系"></a>3. finally与return的关系</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>的执行逻辑：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>. 复制一份<span class="keyword">return</span>后的表达式至操作数栈顶，计算表达式的值，将表达式的值保存至操作数栈顶</span><br><span class="line">    <span class="number">2</span>. 检查后续代码有无<span class="keyword">finally</span></span><br><span class="line">    <span class="number">3</span>. 若有，则优先执行<span class="keyword">finally</span>内的代码，再返回操作数栈顶的值</span><br><span class="line">    <span class="number">4</span>. 若没有，则直接返回操作数栈顶的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">观察下面代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"></span><br><span class="line">    System.out.println(say());</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            a = <span class="number">20</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">想一想输出的值是什么？</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2328241580,270776270&amp;fm=26&amp;gp=0.jpg" alt="思考"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">答案为：10</span><br><span class="line"></span><br><span class="line">通过上面的4步，很容易判断，操作数栈顶的保存的值为10，虽然后面通过finally中的语句使a的值变为了20，但return返回的值仍是10；</span><br></pre></td></tr></tbody></table></figure><p>看看网上的一个面试题：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/26/BQDrToY9O5mX8q4.png" alt="mianshi.png"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">想一想答案是什么？</span><br><span class="line"></span><br><span class="line">下面我们通过画图来演示一下</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/26/BXoIRxgl6yrwpKE.png" alt="tupian"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">所以第一行打印Test1()的时候，先打印try语句中的'A',然后将'A'保存至操作数栈，后面打印finally语句中的'B',将Label的值变为'B',Test1()的返回值为'A',Label的值为'B';</span><br><span class="line"></span><br><span class="line">输出的值为： A***;</span><br></pre></td></tr></tbody></table></figure><p><strong>升华一下</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">我们来变一下，倘若在<span class="keyword">finally</span>后面加上<span class="keyword">return</span>语句，结果会不会不一样呢？</span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Label;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">System.out.println(say());</span><br><span class="line">System.out.println(Label);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">System.out.println(<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">return</span> Label = <span class="string">'A'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">finally</span> {</span><br><span class="line">System.out.println(<span class="string">'B'</span>);</span><br><span class="line"><span class="keyword">return</span> Label = <span class="string">'B'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">这下返回的结果会是什么样呢？</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://tse3-mm.cn.bing.net/th/id/OIP.hoS8C8Tvn6ahI_XKFt2NwwHaHV?pid=Api&amp;rs=1" alt="a"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">对没错,输出的就是A***</span><br><span class="line"></span><br><span class="line">解释如下：</span><br><span class="line"></span><br><span class="line">第一个return,是将'A'储存进了操作数栈顶，然后在执行finally语句的时候，又一次的将'B'保存在了操作数栈顶，所以最终返回值跟Label的值都为'B';</span><br></pre></td></tr></tbody></table></figure><p><strong>再升华一下</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">大家是不是对于<span class="keyword">finally</span>与<span class="keyword">return</span>的关系掌握得更具体了呢，再升华一点，如果在<span class="keyword">try</span> 块后面加上<span class="keyword">return</span> <span class="string">'A'</span>;<span class="keyword">try</span> 块内添加<span class="keyword">catch</span>(Expection e)语句，结果会怎么样？</span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Label;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">System.out.println(say());</span><br><span class="line">System.out.println(Label);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">System.out.println(<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">return</span> Label = <span class="string">'A'</span>;</span><br><span class="line">}<span class="keyword">catch</span>(Exception e) {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">finally</span> {</span><br><span class="line">System.out.println(<span class="string">'B'</span>);</span><br><span class="line">Label = <span class="string">'B'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">想一想结果会怎样？</span><br><span class="line"></span><br><span class="line">大脑一片空白··········</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">emmm  问师傅 我也不知道！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此处省略一万字。。。。</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/26/VtdEGlsar4be2WU.jpg" alt="aa.jpeg"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/sinat_22594643/article/details/80509266" target="_blank" rel="noopener">https://blog.csdn.net/sinat_22594643/article/details/80509266</a><br><a href="https://blog.csdn.net/WYpersist/article/details/80710352" target="_blank" rel="noopener">https://blog.csdn.net/WYpersist/article/details/80710352</a><br><a href="https://www.jianshu.com/p/144a4496575a" target="_blank" rel="noopener">https://www.jianshu.com/p/144a4496575a</a></p><p>仅仅代表一些很基础的个人观点，希望大家能积极指出不足，我一定好好修改的，希望我能跟小伙伴们一起进步！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> finally </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap之深入浅出</title>
      <link href="/posts/55999.html"/>
      <url>/posts/55999.html</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-详解"><a href="#HashMap-详解" class="headerlink" title="HashMap 详解"></a>HashMap 详解</h1><h2 id="说一说你理解的HashMap是什么？"><a href="#说一说你理解的HashMap是什么？" class="headerlink" title="说一说你理解的HashMap是什么？"></a>说一说你理解的HashMap是什么？</h2><p>HashMap 是我们日常工作中经常使用到的一个集合类，它存储数据主要的方式是以键值对的形式进行存储，接下来我主要说一说JDK1.8 相较于JDK1.7对于HashMap的优化：在JDK1.7中HashMap采用的数据结构是数组加链表的形式，在1.8之后优化成了数组加链表加红黑树的这样的一个形式，主要目的是为了提高在多碰撞情况下的查找效率，因为链表的查找效率是O(n)，红黑树的查找效率是O(logn)；还有一个主要的区别是在于他们插入方式不同，1.7采用的是头插法，也就是在碰撞后，将节点插入链表的头部，这么做目的我理解的是当时采用HashMap大部分的热点数据都是后续加上的，先前插入的比较老的数据查找的次数可能没有新插入的数据查询次数多，出于对于热点数据的应用，所以采用了头插法这么一个方式，当然这有很严重的弊端，在多线程的情况下，使用头插法有小概率会产生循环链表，导致CPU性能突增，所以在1.8之后HashMap采用了尾插法的方式；除了这两个之外，1.8还优化了Hash的算法，我记得好像是Hashcode ^ Hashcode &gt;&gt;&gt; 16 ; 当然，还有很多细节上的优化，具体的话要参照源码，源码我之前读过，可能现在记得不是太清楚了；接下来我说一说 1.8 中HashMap中实现的一些机制吧；首先按照阿里规约，当我们创建一个HashMap容器的时候，最好传入一个初始化容量为2的次幂的这样一个参数，来尽量减少HashMap的扩容，因为HashMap的扩容是比较耗费系统资源的，不传入参数的话，HashMap他默认的初始化容量是16，当然他还有一个很重要的成员属性：扩容因子，默认是0.75的浮点数，（扩容因子的作用是控制其扩容的频率，并调整Node数组上链表的稀疏度，当扩容因子越靠近1，链表越密，查找效率低，越靠近0，链表越稀疏，数组利用率少；HashMap的设计者经过大量的实验，总结出0.75的扩容因子是最理想的） 问的话再说加载因子，HashMap 为什么要保证传入的参数是2的次幂呢，当传入参数的时候，是计算 数组length -1与上传入key的HashCode值 ，这样做的目的是为了找出key插入的位置，同时相较于取余操作提高了效率，假如不是2的次幂，会导致Hash碰撞的概率增加，容量是2的次幂也减少了Hash碰撞的概率，使数据分布得更加均匀；</p><p>当然传入数据的过程中还有两个重要的机制，扩容和树化：</p><p>HashMap扩容的机制是当size&gt;=容量*加载因子的时候，会数组进行扩容，扩容大小是增加到原来的两倍 &lt;&lt;1；而HashMap 树化的条件是，数组的长度大于64，且链表的长度大于8，这个时候会将长度为8的链表转化成红黑树，来提高查找的效率；我理解的大概是这些；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown使用</title>
      <link href="/posts/3662.html"/>
      <url>/posts/3662.html</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown的使用方法（小白篇）"><a href="#Markdown的使用方法（小白篇）" class="headerlink" title="Markdown的使用方法（小白篇）"></a>Markdown的使用方法（小白篇）</h1><p><embed src="//music.163.com/style/swf/widget.swf?sid=458217431&amp;type=2&amp;auto=0&amp;width=320&amp;height=66" width="340" height="86" allownetworking="all"></p><hr><h2 id="标题类"><a href="#标题类" class="headerlink" title="标题类"></a>标题类</h2><p>#+空格+一级标题 = 一级标题</p><p>##+空格+二级标题 = 二级标题</p><p>###+空格+三级标题 = 三级标题</p><p>####+空格+四级标题 = 四级标题</p><p>……</p><p>共六级标题</p><p>类似这个样式</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/18/PKVDBh2cosW3N9g.png" alt="title"></p><h2 id="区块与引用"><a href="#区块与引用" class="headerlink" title="区块与引用"></a>区块与引用</h2><p><strong>无序区块</strong></p><p>文字前加上 - 或 * 即可变为无序区块，例：</p><ul><li>1</li><li>2</li><li>3</li></ul><p><strong>有序区块</strong></p><p>文字前加上 1.即可变为有序列表，例：</p><ol><li>1</li><li>2</li><li>3</li></ol><p><strong>引用</strong></p><p>在文本前加上 &gt; 即可实现引用功能</p><blockquote><p>例如：Rome was’t built in a day</p></blockquote><p><strong>多层引用</strong></p><p>一个 &gt; 是最外层，两个 &gt;&gt; 是次外层，三个 &gt;&gt;&gt; 是次次外层</p><blockquote><p>最外层</p><blockquote><p>次外层</p><blockquote><p>次次外层</p></blockquote></blockquote></blockquote><p><strong>在区块内引用</strong></p><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p><p>举个例子：</p><ul><li><p>第一项</p><blockquote><p>菜鸟教程</p></blockquote><ol><li><p>如何从菜鸟成功变成一个老鸟…..</p><blockquote><p>学的不仅是技术更是梦想</p></blockquote></li></ol></li><li><p>第二项</p></li></ul><h2 id="插入超链接与代码块"><a href="#插入超链接与代码块" class="headerlink" title="插入超链接与代码块"></a>插入超链接与代码块</h2><p><strong>图片格式</strong></p><p>!”[]”(“图片链接”)”</p><p>例如：</p><p><img src= "/img/loading.gif" data-src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2493015871,2263103202&amp;fm=26&amp;gp=0.jpg" alt="你的名字"></p><p>安利一个网址，可以自动将本地照片输出成各种格式：</p><p><a href="https://sm.ms/" target="_blank" rel="noopener">本地png图片转超链接点我</a></p><p><strong>链接格式</strong></p><p>“[输入网站介绍]”(“超链接”)”</p><p>备注：！ 与 （）都要是英文格式的哦!</p><p><strong>插入代码块</strong></p><ol><li>代码函数插入：利用``将其选中即可<br>举例<code>System.out.println()</code></li><li>代码区块用三个<code>```</code>包裹即可<br>举例:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int a =10;</span><br><span class="line">int b =20;</span><br><span class="line">System.out.println(a+b);//30</span><br></pre></td></tr></tbody></table></figure><h2 id="强调字体与表格"><a href="#强调字体与表格" class="headerlink" title="强调字体与表格"></a>强调字体与表格</h2></li></ol><p><strong>强调字体</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">强调字体可以有如下形式：</span><br><span class="line"></span><br><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">~~删除线~~</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></tbody></table></figure><p><strong>表格</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">语法如下:</span><br><span class="line"></span><br><span class="line">|  表头  | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></tbody></table></figure><p>输出样式：</p><p><img src= "/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg" alt=""></p><p><strong>表格对齐方式</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">语法如下:</span><br><span class="line"></span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></tbody></table></figure><p>输出样式：</p><p><img src= "/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg" alt=""></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/weilf/p/4567334.html" target="_blank" rel="noopener">https://www.cnblogs.com/weilf/p/4567334.html</a><br><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/markdown/md-tutorial.html</a></p><hr><p>如果可以的话。建议使用Typora这款软件进行.md文件的编写，比较方便，附下载链接：<br><a href="https://www.typora.io/#windows" target="_blank" rel="noopener">Typora下载</a></p><p>如果想体验操作的快感还是使用Markdown编辑器编辑吧！</p><p>不喜勿喷。记得三连</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
