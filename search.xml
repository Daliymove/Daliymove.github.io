<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>mysql索引及SQL语句优化</title>
      <link href="/2020/08/08/mysql-suo-yin/"/>
      <url>/2020/08/08/mysql-suo-yin/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql索引"><a href="#Mysql索引" class="headerlink" title="Mysql索引"></a>Mysql索引</h2><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- mysql文件保存位置</span><br><span class="line">show global variables like "%datadir%";</span><br><span class="line"></span><br><span class="line">-- MySQL8.0 以元数据文件、非事务表来存储的文件被删除了，比如：.frm, .par, .trn, .isl, .db.opt等都在MySQL8.0中不存在了用专门的表空间mysql.idb来存储。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 查看表索引</span><br><span class="line">-- show index from orders;</span><br><span class="line">-- show keys from users;</span><br><span class="line">-- desc users;</span><br><span class="line">-- show create table users;</span><br><span class="line"></span><br><span class="line"># 主键索引与普通索引</span><br><span class="line">-- explain select * from orders where cust_id = 10001;</span><br><span class="line">-- explain select * from orders where order_num =20005;</span><br><span class="line"></span><br><span class="line"># 添加唯一索引 失败</span><br><span class="line">-- alter table orderitems add unique u_pid(prod_id);</span><br><span class="line"></span><br><span class="line"># 添加普通索引</span><br><span class="line">-- alter table users add index in_age(age);</span><br><span class="line">-- explain select * from users where age&gt;25;</span><br><span class="line"># 删除普通索引</span><br><span class="line">-- drop index in_age on users;</span><br><span class="line"></span><br><span class="line"># 全文索引</span><br><span class="line">-- explain select * from productnotes where note_text like 'Customer%';</span><br><span class="line"></span><br><span class="line"># 联合索引</span><br><span class="line">-- explain select * from orderitems where order_item = 1;</span><br><span class="line">-- explain select * from orderitems where order_num = 20005;</span><br><span class="line">-- explain select * from orderitems where order_item = 1 and order_num = 20005;</span><br></pre></td></tr></tbody></table></figure><p>按照老师提供的文档进行了1000W 条数据的插入，想看看索引到底会占多少的存储空间，然后花了半小时才加到了44W 行，果断放弃了!</p><hr><p>添加索引前文件大小：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200808112138351.png" alt=""></p><p>查找 age=18 花费时间：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200808123622779.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a1_%E7%88%B1%E5%A5%87%E8%89%BA_%E7%88%B1%E5%A5%87%E8%89%BA.jpg" alt="">添加普通索引后文件大小：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a33.png" alt=""></p><p>查找 age=18 花费时间：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a4.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a2.png" alt=""></p><p>具体原因可能是优化器的优化选择方面出了问题（原因未知）；</p><p>文件内容：共44W行数据；</p><p><strong>注意： drop index 删除索引并不会删除存储空间，我理解的是只是断开了与建立索引的链接，并且，后续假如建立相同名称的索引，是不需要消耗空间的；</strong></p><p>具体如何删除表中索引并释放空间的方法没有查到；</p><h2 id="书写高质量的Mysql-语句"><a href="#书写高质量的Mysql-语句" class="headerlink" title="书写高质量的Mysql 语句"></a>书写高质量的Mysql 语句</h2><p>参考链接：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486461&amp;idx=1&amp;sn=60a22279196d084cc398936fe3b37772&amp;chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&amp;token=1987003517&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">书写高质量SQL的30条建议</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> SQL索引 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络面试题</title>
      <link href="/2020/08/07/ji-suan-ji-wang-luo-ji-chu/"/>
      <url>/2020/08/07/ji-suan-ji-wang-luo-ji-chu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-HTTP-协议"><a href="#1-HTTP-协议" class="headerlink" title="1. HTTP 协议"></a>1. HTTP 协议</h2><p>超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的<strong>应用层协议</strong>。HTTP是万维网的数据通信的基础</p><p>http是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII码形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使得开发和部署是那么的直截了当。——百度百科</p><h3 id="关于域名解析"><a href="#关于域名解析" class="headerlink" title="关于域名解析"></a>关于域名解析</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200811093557830.png" alt=""></p><h3 id="HTTP工作原理"><a href="#HTTP工作原理" class="headerlink" title="HTTP工作原理"></a>HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。HTTP协议采用了<strong>请求/响应模型</strong>。客户端向服务器发送一个请求报文，请求报文包含请求的方法、URL、协议版本、请求头部和请求数据。服务器以一个状态行作为响应，响应的内容包括协议的版本、成功或者错误代码、服务器信息、响应头部和响应数据。</p><p>以下是 HTTP 请求/响应的步骤：</p><ol><li><p>客户端连接到Web服务器<br>浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址，一个HTTP客户端，通常是浏览器，与Web服务器的HTTP端口（默认为80）建立一个TCP套接字连接。例如，<a href="http://www.luffycity.com/" target="_blank" rel="noopener">http://www.luffycity.com</a>。</p></li><li><p>发送HTTP请求<br>通过TCP套接字，客户端向Web服务器发送一个文本的请求报文，一个请求报文由<strong>请求行、请求头部、空行和请求数据</strong>4部分组成。</p></li><li><p>服务器接受请求并返回HTTP响应<br>Web服务器<strong>解析请求，定位请求资源</strong>。服务器将资源复本写到TCP套接字，由客户端读取。一个响应由<strong>状态行、响应头部、空行和响应数据</strong>4部分组成。</p></li><li><p>释放连接TCP连接<br>若connection 模式为close，则服务器主动关闭TCP连接，客户端被动关闭连接，释放TCP连接;若connection 模式为keepalive，则该连接会保持一段时间，在该时间内可以继续接收请求;</p></li><li><p>客户端浏览器解析HTML内容<br>客户端浏览器首先解析状态行，查看表明请求是否成功的状态代码。然后解析每一个响应头，响应头告知以下为若干字节的HTML文档和文档的字符集。客户端浏览器读取响应数据HTML，根据HTML的语法对其进行格式化，并在浏览器窗口中显示。</p></li></ol><p>　　<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a0814.jpg" alt=""></p><p>　　<strong>http协议是基于TCP/IP协议之上的应用层协议。</strong></p><p>　　<strong>基于 请求-响应 的模式</strong></p><p>　　HTTP协议规定,请求从客户端发出,最后服务器端响应该请求并 返回。换句话说,肯定是先从客户端开始建立通信的,服务器端在没有 接收到请求之前不会发送响应，<strong>服务端不能主动说话。</strong></p><p>　　　　<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/b0814.png" alt=""></p><p>　　<strong>无状态</strong></p><p>　　HTTP是一种不保存状态,即无状态(stateless)协议。HTTP协议 自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个 级别,协议对于<strong>发送过的请求或响应都不做持久化处理</strong>。</p><p>　　　　<img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/c0814.png" alt=""></p><p>　　使用HTTP协议,每当有新的请求发送时,就会有对应的新响应产 生。协议本身并不保留之前一切的请求或响应报文的信息。这是为了更快地处理大量事务,确保协议的可伸缩性,而特意把HTTP协议设计成 如此简单的。可是,随着Web的不断发展,因无状态而导致业务处理变得棘手 的情况增多了。比如,用户登录到一家购物网站,即使他跳转到该站的 其他页面后,也需要能继续保持登录状态。针对这个实例,网站为了能 够掌握是谁送出的请求,需要保存用户的状态。HTTP/1.1虽然是无状态协议,但为了实现期望的保持状态功能, 于是<strong>引入了Cookie技术。有了Cookie再用HTTP协议通信,就可以管理状态了</strong>。有关Cookie的详细内容稍后讲解。</p><p>　　<strong>无连接</strong></p><p>　　无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间，并且可以提高并发性能，不能和每个用户建立长久的连接，请求一次相应一次，服务端和客户端就中断了。但是无连接有两种方式，早期的http协议是一个请求一个响应之后，直接就断开了，但是现<strong>在的http协议1.1版本不是直接就断开了，而是等几秒钟，这几秒钟是等什么呢，等着用户有后续的操作，如果用户在这几秒钟之内有新的请求，那么还是通过之前的连接通道来收发消息，如果过了这几秒钟用户没有发送新的请求，那么就会断开连接，这样可以提高效率，减少短时间内建立连接的次数，因为建立连接也是耗时的，默认的好像是3秒中现在</strong>，但是这个时间是可以通过咱们后端的代码来调整的，自己网站根据自己网站用户的行为来分析统计出一个最优的等待时间。</p><blockquote><p><strong>来个总结 http 是一种基于请求和响应的无状态、无连接的协议</strong></p></blockquote><h2 id="2-OSI与TCP-IP各层的结构与功能"><a href="#2-OSI与TCP-IP各层的结构与功能" class="headerlink" title="2. OSI与TCP/IP各层的结构与功能"></a>2. OSI与TCP/IP各层的结构与功能</h2><blockquote><p>学习计算机⽹络时一般我们会将 OSI 和 TCP/IP 的优点进行合并，采用一种只有五层协议的体系结构，如下图所示，这样既简洁⼜能将概念阐述清楚</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200807090901.png" alt=""></p><ul><li>网络通信过程</li></ul><p>在<a href="https://baike.baidu.com/item/网络通信/9636548" target="_blank" rel="noopener">网络通信</a>的过程中，将发出数据的主机称为源主机，接收数据的主机称为目的主机。当源主机发出数据时，数据在源主机中从上层向下层传送。源主机中的应用进程先将数据交给应用层，应用层加上必要的控制信息就成了报文流，向下传给传输层。传输层将收到的数据单元加上本层的控制信息，形成报文段、数据报，再交给网际层。网际层加上本层的控制信息，形成IP数据报，传给网络接口层。网络接口层将网际层交下来的IP数据报组装成帧，并以比特流的形式传给网络硬件（即物理层），数据就离开源主机。</p><ul><li>相关层定义及协议（了解，没怎么弄明白）</li></ul><p><strong>应用层</strong></p><p><strong>应用层作用：定义数据格式并按照对应的格式解读数据。</strong></p><p>应用层的协议很多，比如域名系统DNS，万维网HTTP协议，支持电子邮件的SMTP协议等；</p><p>通常我们把应用层交互的数据单元称为 <strong>报文</strong>；</p><p><strong>传输层</strong></p><p><strong>传输层负责提供两节点之间数据的可靠传送，当两节点的联系确定之后，传输层则负责监督工作</strong></p><p>其主要使用以下两种协议：</p><ol><li><p>传输控制协议 TCP（Transmission Control Protocol）提供面向连接的，可靠的数据传输服务。 </p></li><li><p>用户数据协议 UDP（User Datagram Protocol）提供无连接的，尽最大努力的数据传输服务 （不保证数据传输的可靠性）。</p></li></ol><p><strong>网络层</strong></p><p><strong>网络层主要解决不同子网间的通信</strong>。</p><p>在计算机网络络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送，在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用的是IP协议，因此分组也叫 IP 数据报 ，简称数据报</p><p><strong>数据链路层</strong></p><p>该层的主要功能是：<strong>通过各种控制协议，将有差错的物理信道变为无差错的、能可靠传输数据帧的数据链路</strong></p><p>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）</p><p><strong>物理层</strong></p><p><strong>利用传输介质为数据链路层提供物理连接，实现比特流的透明传输。</strong></p><p>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>具体可以参考：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">OSI七层模型详解</a></p><h3 id="一张大图让你清晰了解OSI-七层模型"><a href="#一张大图让你清晰了解OSI-七层模型" class="headerlink" title="一张大图让你清晰了解OSI 七层模型"></a>一张大图让你清晰了解OSI 七层模型</h3><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/000807.jpg" alt=""></p><h2 id="3-TCP-三次握手和四次挥手-面试常客"><a href="#3-TCP-三次握手和四次挥手-面试常客" class="headerlink" title="3. TCP 三次握手和四次挥手(面试常客)"></a>3. TCP 三次握手和四次挥手(面试常客)</h2><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200811111310633.png" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> http </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql学习总结</title>
      <link href="/2020/08/05/mysql-zong-jie/"/>
      <url>/2020/08/05/mysql-zong-jie/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>数据库就是按照数据结构来组织，存储和管理数据的仓库</p><p>数据库特点：</p><ul><li>对数据进行持久化保存</li><li>方便数据的存储和查询，速度快，安全，方便</li><li>可以处理并发访问</li><li>更加安全的权限管理访问机制</li></ul><p>常见的数据库：</p><p>Mysql 、oricle 、PostgerSQL 、SQLServer(微软)  关系型数据库<br>redis 非关系型数据库（数据存储在内存中，读取速度快，键值对的形式存储，不是二维表的形式）<br>mongoDB 文档型数据库 也是非关系型数据库   配合上面数据库使用 </p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>存储引擎： 对具体数据进行操作，读取表中数据，以及将数据存储进物理内存中；</p><p>客户端： 连接 Mysql<br>服务器： 连接管理、查询缓存、语法解析、查询优化等操作<br>存储引擎：真实的存取数据</p><p>Mysql 支持的存储引擎：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200729164116.png" alt=""></p><blockquote><p>我们一般常用的是 InnoDB 与 MyISAM</p></blockquote><h3 id="InnoDB-与-MyISAM-的区别"><a href="#InnoDB-与-MyISAM-的区别" class="headerlink" title="InnoDB 与 MyISAM 的区别"></a>InnoDB 与 MyISAM 的区别</h3><blockquote><p>MyISAM是MySQL的默认数据库引擎（5.5版之前）,其提供了⼤量的特性，包括全⽂索引、压缩、空间函数等，但MyISAM不⽀持事务和行级锁，而且最⼤的缺陷就是崩溃后无法安全恢复，所以MySQL 5.5版本后默认的存储引擎修改为InnoDB。</p></blockquote><table><thead><tr><th align="center"></th><th align="center">InnoDB</th><th align="center">MyISAM</th></tr></thead><tbody><tr><td align="center">事务与锁</td><td align="center">支持事务和行级锁</td><td align="center">只支持表级锁</td></tr><tr><td align="center">存储结构</td><td align="center">两个（.frm .ibd ）</td><td align="center">三个（.frm .MYI .MYD）</td></tr><tr><td align="center">表主键</td><td align="center">没有会自动创建6字节主键</td><td align="center">允许没有任何索引和主键</td></tr><tr><td align="center">表行数</td><td align="center">未生成最大行数（count效率低）</td><td align="center">生成最大行数（count效率高）</td></tr><tr><td align="center">外键</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">CURD操作</td><td align="center">trancate table（用于删除大量行）</td><td align="center">适用于大量select 操作</td></tr><tr><td align="center">应用场景</td><td align="center">大型高并发应用</td><td align="center">小型应用</td></tr></tbody></table><ul><li>表级锁： MySQL中锁定<strong>粒度最大</strong>的⼀种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最⼤，触发锁冲突的概率最高，并发度最低， MyISAM和 InnoDB引擎都支持表级锁。 </li><li>行级锁： MySQL中锁定<strong>粒度最小</strong>的⼀种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li></ul><h2 id="mysql-事务"><a href="#mysql-事务" class="headerlink" title="mysql 事务"></a>mysql 事务</h2><p>事务：一系列增删改查等操作所组成的一个逻辑执行单元</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200805170325.png" alt=""></p><h3 id="事务的语法"><a href="#事务的语法" class="headerlink" title="事务的语法"></a>事务的语法</h3><p>事务开启： start transaction;/ begin;</p><p>提交：commit; 使得当前的修改确认</p><p>回滚：rollback; 使得当前的修改被放弃</p><h3 id="事务的ACID特性"><a href="#事务的ACID特性" class="headerlink" title="事务的ACID特性"></a>事务的ACID特性</h3><ul><li><strong>原子性</strong></li></ul><p>事务是最小的执行单位，事务开启后，操作要么全部成功，要么全部失败；</p><blockquote><p>事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执⾏过程中出错， 会回滚到事务开始前的状态，所有的操作就像没有发⽣⼀样。也就是说事务是⼀个不可分割的整体，就像化学中学过的原⼦，是物质构成的基本单位。</p></blockquote><ul><li><strong>一致性</strong></li></ul><p>执行事务前后，数据保持一致，多个事务对同一数据的读取结果相同；（理解成数据的总和相同）A+ 则B-</p><ul><li><strong>隔离性</strong></li></ul><p>并发访问数据库时，⼀个用户的事务不被其他事务所⼲扰，各并发事务 之间数据库是独⽴的；</p><ul><li><strong>持久性</strong></li></ul><p>⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响； （写入磁盘，除非硬盘损坏）</p><h3 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h3><p><strong>丢失修改：</strong>指一个事务读取一个数据时，另一个事务也对这个数据进行了读取，如果两个事务都对此数据进行了修改，那么前者的数据修改将会丢失；</p><p><strong>脏读：</strong>读到了未提交的数据； 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的 数据是脏数据。</p><p><strong>不可重复读：</strong>同⼀条命令返回不同的结果集；.事务 A 多次读取同⼀数据，事务 B 在事务A 多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同⼀数据时，结果不⼀致；</p><p><strong>幻读：</strong>重复查询的过程中，数据就发⽣了量的变化（insert， delete）</p><ul><li>诡异的更新事件：<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/1-15.jpg" alt=""></li></ul><p><strong>不可重复读和幻读区别：</strong> 不可重复读的重点是修改，比如多次读取⼀条记录发现其中某些列的值被修改，幻读的重点在于新增或删除，⽐如多次读取⼀条记录发现记录增多或减少了；</p><p><strong>顺序读：</strong> 隔离的最高级别，事务依次逐个进行，不允许并发执行；</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>SQL 标准定义了四个隔离级别：</p><ul><li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200805185614.png" alt=""></p><p>MySQL InnoDB 存储引擎的默认⽀持的隔离级别是 REPEATABLE-READ（可重读）；<br>mysql 5.7 可通过 <code>select @@tx_isolation;</code> 来查看；<br>mysql 8.0 以上可通过<code>select @@transaction_isolation;</code> 来查看；</p><h3 id="不同的隔离级别的锁的情况"><a href="#不同的隔离级别的锁的情况" class="headerlink" title="不同的隔离级别的锁的情况"></a>不同的隔离级别的锁的情况</h3><ol><li>读未提交（RU）: 有行级的锁，没有间隙锁。它与RC的区别是能够查询到未提交的数据。</li><li>读已提交（RC）：有行级的锁，没有间隙锁，读不到没有提交的数据。</li><li>可重复读（RR）：有行级的锁，也有间隙锁，每次读取的数据都是⼀样的，并且没有幻读的情况，存在诡异更新的情况。</li><li>序列化（S）：有行级锁，也有间隙锁，读表的时候，就已经上锁了</li></ol><h3 id="隐式提交"><a href="#隐式提交" class="headerlink" title="隐式提交"></a>隐式提交</h3><blockquote><p>事务中输入DDL(Data Define Language) 定义语句时，如(建库,建表,修改表,索引操作,存储过程,视图<strong>等修改表结构的操作</strong>)，都会将修改的结果进行隐式提交；</p></blockquote><h3 id="多版本控制MVCC"><a href="#多版本控制MVCC" class="headerlink" title="多版本控制MVCC"></a>多版本控制MVCC</h3><p>MVCC : 指的是一种提高并发的技术。最早的数据库系统，只有读读之间可以并发，读写，写读，写写都要阻塞。引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p><a href="https://blog.csdn.net/qq_34337272/article/details/80611486" target="_blank" rel="noopener">Mysql锁机制简单了解</a></p><h2 id="大表优化"><a href="#大表优化" class="headerlink" title="大表优化"></a>大表优化</h2><p>当MySQL单表记录数过⼤时，数据库的CRUD性能会明显下降，⼀些常⻅的优化措施如下：</p><ul><li>限定数据的范围</li></ul><p>添加限制条件，尽量少使用 * 的查找，除非表数据较少；</p><ul><li>读/写分离</li></ul><p>经典的数据库拆分⽅案，主库负责写，从库负责读；</p><ul><li><p>垂直分区</p></li><li><p>数据库分片</p></li></ul><p>MySQL大表优化⽅案：<a href="https://segmentfault.com/a/1190000006158186" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006158186</a></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="mysql-存储过程"><a href="#mysql-存储过程" class="headerlink" title="mysql 存储过程"></a>mysql 存储过程</h3><p> mysql存储：将一段SQL 语句打包成一个方法存储下来，处理速度更快，因为是预编译好的方法体；</p><p><strong>创建过程</strong></p><p><code>\d //</code>修改MySQL默认的语句结尾符 ; 改为 // （因为多条语句中会穿插分号；） </p><p><code>create procedure</code> 创建语句 </p><p>BEGIN和END语句⽤来限定存储过程体</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- 定义存储过程</span><br><span class="line">\d //</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">set @i=10;</span><br><span class="line">while @i&lt;90 do</span><br><span class="line">insert into users values(null,concat('user:',@i),@i,0);</span><br><span class="line">set @i=@i+1;</span><br><span class="line">end while;</span><br><span class="line">end;</span><br><span class="line">//</span><br><span class="line">\d ;</span><br></pre></td></tr></tbody></table></figure><p>查看存储过程：<code>show create procedure p1\G</code></p><p>删除存储过程：<code>drop procedure p1</code></p><p><strong>总结</strong></p><ul><li><p>业务逻辑不要封装在数据库里面,应该由应用程序（ JAVA、Python、PHP）处理。 </p></li><li><p>让数据库只做它擅长和必须做的，减少数据库资源和性能的消耗。 </p></li><li><p>维护困难，大量业务逻辑封装在存储过程中，造成业务逻辑很难剥离出来；动A影响B。 </p></li><li><p>人员也难招聘，因为既懂存储过程，又懂业务的⼈少，使用困难。</p><p><strong>在电信、银行业、金融饭店以及国企都普遍使用存储过程来熟悉业务逻辑，但在互联网中相对较少。</strong></p></li></ul><h3 id="mysql触发器"><a href="#mysql触发器" class="headerlink" title="mysql触发器"></a>mysql触发器</h3><blockquote><ul><li><p>触发器是MySQL响应写操作(增、删、改)而自动执行的一条或一组定义在BEGIN和END之间的 MySQL语句</p></li><li><p>执行触发器类似于JavaScript中的事件</p></li></ul></blockquote><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt</span><br><span class="line"># 说明：</span><br><span class="line"># trigger_name：触发器名称</span><br><span class="line"># trigger_time:触发时间，可取值：BEFORE或AFTER</span><br><span class="line"># trigger_event：触发事件，可取值：INSERT、UPDATE或DELETE。</span><br><span class="line"># tb1_name：指定在哪个表上</span><br><span class="line"># trigger_stmt：触发处理SQL语句。</span><br><span class="line"></span><br><span class="line">-- 查看所有的 触发器</span><br><span class="line">show triggers\G</span><br><span class="line">-- 删除触发器</span><br><span class="line">drop trigger trigger_name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 举例：创建⼀个删除的触发器,在users表中删除数据之前,往del_users表中添加⼀个数据</span><br><span class="line"></span><br><span class="line">-- 1,复制当前的⼀个表结构</span><br><span class="line">create table del_users like users;</span><br><span class="line"></span><br><span class="line">-- 2,创建 删除触发器 注意在创建删除触发器时,只能在删除之前才能获取到old(之前的)数据</span><br><span class="line">\d //</span><br><span class="line">create trigger deluser before delete on users for each row</span><br><span class="line">begin</span><br><span class="line">insert into del_users values(old.id,old.name,old.age,old.account);</span><br><span class="line">end;</span><br><span class="line">//</span><br><span class="line">\d ;</span><br></pre></td></tr></tbody></table></figure><p><strong>tips：</strong></p><ul><li><strong>在INSERT触发器代码内，可引用一个名为NEW的虚拟表，访问被插入的行</strong></li><li><strong>在DELETE触发器代码内，可以引用一个名为OLD的虚拟表，访问被删除的行</strong></li><li><strong>在UPDATE触发器代码中，可以引用NEW/ OLD 来访问被删除或被插入的行</strong></li></ul><p><strong>注意：</strong> <strong>OLD中的值全都是只读的，不能更新；在AFTER DELETE的触发器中无法获取OLD虚拟表</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- 练习：</span><br><span class="line">-- 1.创建⼀个表, users_count ⾥⾯有⼀个 num的字段 初始值为0或者是你当前users表中的count</span><br><span class="line">-- 2,给users表创建⼀个触发器</span><br><span class="line">-- 当给users表中执⾏insert添加数据之后,就让users_count⾥⾯num+1,</span><br><span class="line">-- 当users表中的数据删除时,就让users_count⾥⾯num-1,</span><br><span class="line">-- 想要统计users表中的数据总数时,直接查看 users_count</span><br><span class="line"></span><br><span class="line">\d //</span><br><span class="line">create trigger addcount after insert on users for each row</span><br><span class="line">begin</span><br><span class="line">update user_count set num = num+1;</span><br><span class="line">end;</span><br><span class="line">create trigger delcount before delete on users for each row</span><br><span class="line">begin</span><br><span class="line">update user_count set num = num-1;</span><br><span class="line">end;</span><br><span class="line">//</span><br><span class="line">\d ;</span><br></pre></td></tr></tbody></table></figure><h3 id="mysql-视图"><a href="#mysql-视图" class="headerlink" title="mysql 视图"></a>mysql 视图</h3><p><strong>什么是视图？</strong> </p><blockquote><ul><li>可以理解成用sql查询语句创建的一个表，用于查看符合查询语句条件的数据；</li><li>视图本身不包含数据，返回的数据是通过其他表查询而来</li><li>对视图进行增删修改等操作，实际是操作查询的原数据表</li><li></li></ul><p><strong>总结：</strong>视图是对SQL 查询语句的封装，不包含任何数据，具有表的结构体，可以增删改查（操作查询的那个表）</p></blockquote><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- 创建过程</span><br><span class="line">create view v_table as SQL select...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show tables; -- 可以查看到所有的表和视图</span><br><span class="line">show table status where comment='view'\G -- 只查看当前库中的所有视图</span><br><span class="line"></span><br><span class="line">drop view v_table; -- 删除视图</span><br></pre></td></tr></tbody></table></figure><blockquote><p> 总结一下：mysql存储相当于是定义一个方法体，mysql触发器是在（增、删、修改）事件发生前/后执行某某操作，mysql视图是封装一段动态的查询语句；</p></blockquote><h2 id="索引与优化"><a href="#索引与优化" class="headerlink" title="索引与优化"></a>索引与优化</h2><h3 id="索引的概述与分类"><a href="#索引的概述与分类" class="headerlink" title="索引的概述与分类"></a>索引的概述与分类</h3><p>什么是索引？</p><ul><li><p>类似于图书的目录，提高数据检索效率，降低数据库的IO成本 </p></li><li><p>也可以理解成一种快速查找排好序的数据结构</p></li></ul><p>索引分类（按查找效率）：</p><ul><li>主键索引 ：根据主键建立索引，不允许重复，不为空；</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a1.png" alt=""></p><ul><li>唯一索引  ：用来建立索引的列的值必须是唯一的，允许为空值</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806154340.png" alt=""></p><ul><li>普通索引：用表中的普通列构建的索引，没有限制</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806154501.png" alt=""></p><ul><li>全文索引：大文本对象的列来构建索引（分池）</li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806154808.png" alt=""></p><ul><li><p>组合索引：用多个列组合构建的索引，多个列中不允许有空值</p><p>组合索引的最左前缀原则，如上图所示，必须从email开始查找，不能直接从phone开始查；</p></li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/a0806.jpg" alt=""></p><h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>MySQL索引的数据结构：</p><ul><li><p>哈希索引（用于memory存储引擎,速度快，散列分布，不支持范围查找与排序）</p></li><li><p>B+TREE索引，大部分场景都使用此数据结构进行索引</p></li></ul><p>正常情况下，在mysql中如果不指定索引的类型，那么⼀般是指B+Tree索引（或者B+Tree索引）。</p><h3 id="B-树与B-树比较"><a href="#B-树与B-树比较" class="headerlink" title="B 树与B+树比较"></a>B 树与B+树比较</h3><p>下图一个三阶的B树，每一个节点都带有数据，倘若需要范围查找，比如查找1-5中的数据，此时需要遍历9次</p><p>数字： 1 2 3 4 5</p><p>步数： 3 4 5 7 9</p><p>所以使用B树会有以下缺点：</p><ol><li>查找效率不均一 </li><li>范围查找需要中序遍历（返回上层查找）</li><li>每⼀个叶子结点上都带有数据（地址不连续）</li></ol><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806181409.png" alt=""></p><p>再来看看B+树</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806183054.png" alt=""></p><p>B+ 树相对于 B树的优势：</p><ol><li>磁盘的读写代价更低：B树是索引与数据一起存储，读深层数据IO次数多，B+ 树索引部分只存索引，相同的块空间存储的索引更多</li><li>随机IO次数更少：随机IO指读取地址不连续的数据，相较而言B树的随机IO明显多余B+树，B+树则是顺序IO较多</li><li>查询速度更稳定：B+树查询的所有数据都要到叶子节点；</li></ol><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><p>用主键建立的索引为主索引，其余为辅助索引（数据和索引分离），主键索引只有一个，辅助索引可以有很多个；</p><ul><li><p>聚簇索引：能通过索引找到要查找的数据</p></li><li><p>非聚簇索引：通过索引只能找到索引值和key，如果查找其他数据需要回表（去主键索引中查找数据）</p></li></ul><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/2020-08.jpg" alt=""></p><p>myISAM也使用了B+树的数据结构来存储数据，只是在其叶子节点中只存储了索引和行号，即需要查找数据都要根据行号去对应的文件中查找，这种行为我们称之为 ‘回行’ ；</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806212553.png" alt=""></p><p><strong>总结</strong></p><p>InnoDB 中的主键索引是聚簇索引，其余的辅助索引为非聚簇索引；</p><p>MyISAM中的主键索引与辅助索引都是非聚簇索引；</p><h2 id="慢查询与SQL优化"><a href="#慢查询与SQL优化" class="headerlink" title="慢查询与SQL优化"></a>慢查询与SQL优化</h2><h3 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h3><p>即慢查询日志，即用来记录响应时间超过查询阈值的语句；一般除非调优，不需要开启，会影响性能；</p><p>慢查询⽇志可用于查找需要很长时间才能执行的查询，因此是优化的候选者。</p><p>慢查询语法：</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">-- 查看慢查询配置</span><br><span class="line">show variables like '%slow%';  </span><br><span class="line"></span><br><span class="line">-- 查看慢查询时间定义</span><br><span class="line">show variables like 'long_query_time';</span><br><span class="line"></span><br><span class="line">-- 设置慢查询的时间定义</span><br><span class="line">set long_query_time=2;</span><br><span class="line"></span><br><span class="line">-- 开启慢日志</span><br><span class="line">set global slow_query_log ='ON';</span><br></pre></td></tr></tbody></table></figure><p>通过慢查询日志以及 explain 来对查询进行解析</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806215907.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806220108.png" alt=""></p><p>建立无用的索引会浪费磁盘空间，虽然可以显著提高查找效率；1000W条数据量大概的存储空间为800M，增加一个主键索引变成了1.2G；过多的索引也会影响写入性能；相对应的维护成本也会提高；</p><h3 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h3><p><strong>适当建立索引</strong></p><ol><li>创建并使用自增数字建立主键索引</li><li>经常使用的where字段才建立索引</li><li>添加索引尽可能的保持一致性</li><li>可考虑联合索引进行索引覆盖</li></ol><p><strong>合理使用索引</strong></p><ol><li>不要在列上使用函数或进行计算：如 select * from news where year(public_time) =2017 或 select * from news where id/100 = 1;</li><li>防止两侧数据不一致导致隐式转换</li></ol><p><strong>注意：当查询条件左右两侧类型不匹配的时候会发生隐式转换，隐式转换带来的影响就是可能导致索引失效而进行全表扫描。</strong></p><ol start="3"><li>like 语句的索引失效问题</li></ol><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806223133.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200806223319.png" alt=""></p><h3 id="SQL语句优化"><a href="#SQL语句优化" class="headerlink" title="SQL语句优化"></a>SQL语句优化</h3><ol><li>避免嵌套语句（子查询）</li><li>避免多表查询（复杂查询简单化）</li></ol><h2 id="mysql-相关文章推荐"><a href="#mysql-相关文章推荐" class="headerlink" title="mysql 相关文章推荐"></a>mysql 相关文章推荐</h2><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485097&amp;idx=1&amp;sn=84c89da477b1338bdf3e9fcd65514ac1&amp;chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&amp;token=79317275&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">一条SQL语句在MySQL中如何执行的</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485117&amp;idx=1&amp;sn=92361755b7c3de488b415ec4c5f46d73&amp;chksm=cea24976f9d5c060babe50c3747616cce63df5d50947903a262704988143c2eeb4069ae45420&amp;token=79317275&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">MySQL高性能优化规范建议</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485185&amp;idx=1&amp;sn=66ef08b4ab6af5757792223a83fc0d45&amp;chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&amp;token=79317275&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">腾讯⾯试：⼀条SQL语句执⾏得很慢的原因有哪些？—不看后悔系列</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247486461&amp;idx=1&amp;sn=60a22279196d084cc398936fe3b37772&amp;chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&amp;token=1987003517&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">书写高质量SQL的30条建议</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> SQL语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法的学习之路</title>
      <link href="/2020/07/28/suan-fa-de-xue-xi-zhi-lu/"/>
      <url>/2020/07/28/suan-fa-de-xue-xi-zhi-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="算法学习之路"><a href="#算法学习之路" class="headerlink" title="算法学习之路"></a>算法学习之路</h1><h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><p>一上来就是欧几里得算法，其实也就是求最大公约数，代码如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> p,<span class="keyword">int</span> q)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(q == <span class="number">0</span>) <span class="keyword">return</span> p;</span><br><span class="line">    <span class="keyword">int</span> r = p%q;</span><br><span class="line">    <span class="keyword">return</span> gcd(q,r);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>三行代码就求出来了， 是不是很优雅的操作，后面来介绍算法的时间复杂度与空间复杂度</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java虚拟机之初出茅庐</title>
      <link href="/2020/07/18/java-xu-ni-ji-zhi-chu-chu-mao-lu/"/>
      <url>/2020/07/18/java-xu-ni-ji-zhi-chu-chu-mao-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java虚拟机"><a href="#Java虚拟机" class="headerlink" title="Java虚拟机"></a>Java虚拟机</h1><hr><h2 id="来一些干历史"><a href="#来一些干历史" class="headerlink" title="来一些干历史"></a>来一些干历史</h2><h3 id="世界上第一款商用Java虚拟机"><a href="#世界上第一款商用Java虚拟机" class="headerlink" title="世界上第一款商用Java虚拟机"></a>世界上第一款商用Java虚拟机</h3><blockquote><p>是什么呢？ 它就是我们如今虚拟机的始祖，Sun Classic虚拟机</p><p>这款虚拟机发布于JDK1.0版本，离我们已经相当遥远了，它只能通过纯解释器方式来执行Java代码，如果此时要使用即时编译器，那么这个虚拟机的解释器就只能进行外挂，而外挂的结果就是编译器完全接管了虚拟机的执行系统，解释器不能进行正常工作；</p><p>可见古老的科技还是比较落后的，没有特变强大的适应力；</p></blockquote><h3 id="如今的主流虚拟机：Hotspot-VM"><a href="#如今的主流虚拟机：Hotspot-VM" class="headerlink" title="如今的主流虚拟机：Hotspot VM"></a>如今的主流虚拟机：Hotspot VM</h3><blockquote><p>没错，这台虚拟机就是我们如今现在正在使用的Java虚拟机，也是目前使用范围最广的虚拟机，他是Sun/OracleJDK 中的默认虚拟机，它最强大的功能就是像它名字所说的“热”技术，也就是热点代码探测技术，热点探测技术可以通过执行计数器找出最具有编译价值的代码，然后通知及时编译器以方法为单位进行编译；</p><p>那它主要的结构是什么呢？</p><p>它的即时编译系统主要有两部分，第一部分是主要负责编译耗时短，输出代码优化程度比较低的客户端编译器，简称C1，另一部分是编译耗时时间长，但代码优化质量比较高的服务端编译器，简称C2；他们通常会在分层编译的机制下与解释器相互配合来共同构成Hotspot虚拟机的执行子系统（抱歉，不是太了解什么是执行子系统，在这里就不要多提问了！）</p><p>自JDK10起，Hotspot 编译器中又多加了一个新“兄弟”：Graal编译器，它的长远目标是用于替代C2的，尽管如今的C2还能用，但是由于历史长久的原因，它的身材已经过于庞大了，维护起来相当困难，已经连当初创作它的Cliiff Click博士本人都不愿意去维护这个庞大的家伙；所以，Graal 编译器应运而生，目前Graal 编译器的性能已经基本上与C2持平了，个人觉得取代只是迟早的事情；</p></blockquote><h3 id="黑科技之Graal-VM"><a href="#黑科技之Graal-VM" class="headerlink" title="黑科技之Graal VM"></a>黑科技之Graal VM</h3><blockquote><p>2018年4月，Oracle Labs公开了一项黑科技，Graal VM，它是在HotSpot 虚拟机的基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的运行平台来使用；在此不再过多赘述了，有兴趣的可以了解一下，据称是未来可以替代Hotspot的候选项；</p></blockquote><p>在此总结一下：Java为什么能成为世界第一的计算机编程语言，一方面出于它结构严谨，面向对象的思想，另一方面是多平台的优势，即编译一次，随处运行，而多平台归功于Java虚拟机的强大，虚拟机帮助它实现了热点代码检测以及运行时编译及优化；此外，还有它的开源性以及强大的第三方类库，帮助着用户解决各种各样的难题········</p><h2 id="Java虚拟机运行时数据区域"><a href="#Java虚拟机运行时数据区域" class="headerlink" title="Java虚拟机运行时数据区域"></a>Java虚拟机运行时数据区域</h2><p>我们之前学过，虚拟机的运行时内存划分为 栈，堆，方法区、PC寄存器、本地方法栈五大类；在这里我按照虚拟机相关的书籍大概总结了一下，如图：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200718110626591.png" alt=""></p><p>我们先来明确一个概念：什么是<strong>线程私有</strong>内存；</p><blockquote><p>线程私有内存，通俗来讲就是各线程之间互不影响，独自存储和使用的内存空间，称之为线程私有内存；</p></blockquote><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote><p>程序计数器（Program Counter Register）也叫PC寄存器，它在虚拟机中的主要作用是记录线程执行的字节码的行号指示器；</p><p>在编译过程中，字节码解释器怎么获取下一行应该执行什么内容呢？它通过改变程序计数器的值，来获取下一行需要执行的字节码指令；可以把它看成是程序控制的一个指示器，循环，跳转，异常处理，线程恢复，都依赖于计数器的指示下进行；</p><p>另外，除了引导程序流，它还是多线程轮流切换的一个flag；A 线程跳转到 B 线程后，怎么回到A 呢，这个时候靠程序计数器的引导下回来；所以，程序计数器是线程私有内存，每一个线程只能拥有一个程序计数器；</p><p>此外，当线程执行的是Java方法时，程序计数器几率的是虚拟机字节码指令的地址，如果执行的是本地方法时，计数器记录的是空；</p></blockquote><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><blockquote><p>虚拟机栈，也就是我们平常所说的 “栈”，只不过我们一般只关注它的局部变量部分；虚拟机栈描述的是Java方法执行的线程内存模型，即每个方法被执行的时候，虚拟机都会同步创建一个<strong>栈桢</strong>来存储局部变量表，操作数栈、动态连接、方法出口等信息。当一个方法被调用的，对应着一个栈桢在虚拟机栈中入栈，一个方法执行完，对应从虚拟机中出栈；一个方法对应着一个栈桢；</p><p>虚拟机栈空间也是线程私有的，它与线程的生命周期相同，同生共死；</p><p>局部变量表存储着各种基本数据类型（int/float/char/double…..)以及对象引用（reference，指向对象起始地址的引用指针）和 returnAddress （指向一条字节码指令的地址）；这些数据类型在局部变量表的存储形式以局部变量槽（Slot）的形式体现，其中long、double 类型的数据会占两个变量槽，其余类型的数据占一个，具体如图所示</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/image-20200718115902122.png" alt=""></p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><blockquote><p>本地方法栈与虚拟机栈的作用类似，主要区别就是本地方法栈对应的是本地方法(Native Method)，本地方法指其它编程语言的方法，类如（C、C++等），在读取.dll文件内的方法时，Java调用非Java代码的接口，就会开启本地方法栈；在此不多做描述；</p></blockquote><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><blockquote><p>堆（Heap）大家应该比较熟悉，是整个虚拟机所管理内从中最大的一块，也是被所有线程所共享的一块内存区域；此内存区块存在的唯一目的就是存放对象实例，没错，就是<strong>new 对象</strong>；基本可以认为，所有的实例对象都存放于堆中；同时，Java堆也只能存放实例对象；</p><p>Java堆内存是垃圾回收器重点关注区域，所以有一些资料也称其为 GC堆；按照以往的垃圾回收器机制来划分，堆可以划分为“新生代、老年代、永久代、Eden、Survivor·······”；但站在目前的角度来说，应该根据虚拟机所用的堆内存垃圾回收器的具体机制来划分；</p><p>堆中内存的分配方式：这个涉及到 虚拟机的类加载机制，我还没研究透，但总体来说有两种；</p><p>第一种是基于堆内存空间规整的分配方式，这个条件下，堆内存的分配方式为“指针碰撞”；</p><p>第二种是堆内存空间不规整的情况下划分，这种情况没有办法进行简单的指针碰撞，需要通过一个列表来记录，哪些内存是可用的，找到一块足够大，能装的下对象内存的区域后，再划分给对象，这种分配方式叫“空闲列表”；</p></blockquote><h3 id="方法区（没想好怎么写）"><a href="#方法区（没想好怎么写）" class="headerlink" title="方法区（没想好怎么写）"></a>方法区（没想好怎么写）</h3><blockquote><p>方法区与堆 一样，是各个线程共享的内存区域，用于储存已经被虚拟机加载的类型信息、常量、静态变量、即时编译器后的代码缓存等数据；它有个有意思的别名，叫做 <strong>非堆</strong>。</p><p><img src= "/img/loading.gif" data-src="https://img-blog.csdn.net/20171115215708642?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2FuZ2JpYW8wMDc=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt=""></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 虚拟机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程之九阳神功秘籍</title>
      <link href="/2020/07/11/duo-xian-cheng-zhi-lu/"/>
      <url>/2020/07/11/duo-xian-cheng-zhi-lu/</url>
      
        <content type="html"><![CDATA[<h1 id="多线程之旅"><a href="#多线程之旅" class="headerlink" title="多线程之旅"></a>多线程之旅</h1><hr><h2 id="什么是多线程？"><a href="#什么是多线程？" class="headerlink" title="什么是多线程？"></a>什么是多线程？</h2><p>我们先来看看，什么是线程：</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710152151.png" alt="进程与线程"></p><p><strong>问题1：不运行的程序，是什么？</strong></p><blockquote><p>程序可以理解成一个静态的指令集合，当系统运行程序时， 程序中的指令就被激活了，转变成进程开始执行任务。</p></blockquote><p><strong>问题2：进程之间会相互影响吗？</strong></p><blockquote><ol><li>进程是系统中独立存在的实体，每一个进程都拥有自己私有的地址空间。在没有经过进程本身的允许的情况下，一个用户进程是不可以直接访问其他进程的地址空间的；</li><li>多个进程可以在单个处理器上并发执行，并且多进程之间不会互相影响。</li></ol></blockquote><p><strong>问题3：线程之间会互相影响吗？</strong></p><blockquote><p>线程可以理解成进程的执行单元，一个线程必须有一个父进程，当进程被初始化，主线程就创建了，它们共享着父进程的内存资源。线程可以拥有自己的堆栈，自己的程序计数器和自己的局部变量，但不拥有系统资源；他们可以通过调用父线程的资源来相互影响，但是要做到不要相互妨碍；</p></blockquote><blockquote><p>总结起来就是一句话，一个程序的运行，至少依托着一个进程的支持，一个进程的运行，至少需要一个线程；</p></blockquote><p><strong>多线程的优势(相较于多进程)</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">1. 进程之间不能共享内存，线程之间能轻易实现内存的共享；</span><br><span class="line"></span><br><span class="line">2. 系统创建进程需要为该进程重新分配系统资源，而创建线程的代价相比之下就小得多，因此使用多线程来实现任务并发就比多进程的效率高；</span><br><span class="line"></span><br><span class="line">3. Java语言内置了多线程功能的支持，而不是单纯地作为底层操作系统的调度方式，从而简化了Java的多线程编程。</span><br></pre></td></tr></tbody></table></figure><h2 id="线程的创建与启动"><a href="#线程的创建与启动" class="headerlink" title="线程的创建与启动"></a>线程的创建与启动</h2><blockquote><p>三种方法：1. 继承Thread类创建；2. 实现Runnable接口创建；3. 使用Callable和Future创建</p></blockquote><h3 id="第一种继承创建"><a href="#第一种继承创建" class="headerlink" title="第一种继承创建"></a>第一种继承创建</h3><p>见如下代码：</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"多线程不好玩"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"多线程真好玩"</span>);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>运行结果中能看到交替运行:<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710162128.png" alt="运行结果"></p></blockquote><blockquote><p>当然，这么写有点麻烦，因为Mythread子类只用了一次，可以创建匿名内部类的形式简化上述代码:</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(){</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++){</span><br><span class="line">                    System.out.println(<span class="string">"多线程好玩:"</span>+i);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++){</span><br><span class="line">            System.out.println(<span class="string">"多线程真好玩:"</span>+i);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第二种Runnable接口创建（最常用）"><a href="#第二种Runnable接口创建（最常用）" class="headerlink" title="第二种Runnable接口创建（最常用）"></a>第二种Runnable接口创建（最常用）</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"多线程真好玩"</span>);</span><br><span class="line">            }</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"多线程不好玩"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>由于这个Runnable 接口只有run这一个方法需要实现，所以可以利用<strong>Lambda</strong>表达式来进一步简化：</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;{</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"多线程真好玩"</span>+i);</span><br><span class="line">        }).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"多线程不好玩"</span>+i);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="第三种Callalbe创建（带有返回值的接口线程创建）"><a href="#第三种Callalbe创建（带有返回值的接口线程创建）" class="headerlink" title="第三种Callalbe创建（带有返回值的接口线程创建）"></a>第三种Callalbe创建（带有返回值的接口线程创建）</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>{</span><br><span class="line">        Callable&lt;Integer&gt; c = <span class="keyword">new</span> MyCallable&lt;&gt;();</span><br><span class="line">        FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(c);</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        System.out.println(<span class="string">"子线程的返回值为："</span>+task.get());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">            System.out.println(i);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span>&lt;<span class="title">Interger</span>&gt; <span class="keyword">implements</span> <span class="title">Callable</span> </span>{</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">                System.out.println(i);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>注意：如果子线程与主线程之间存在 task.get() 获取子线程的返回值，主线程会等待返回值得到，也就是子线程执行完，再开始执行主线程；<br>如果想停止子线程的运行，通过task.cancel()来停止</p></blockquote><h3 id="三种创建方法的比较"><a href="#三种创建方法的比较" class="headerlink" title="三种创建方法的比较"></a>三种创建方法的比较</h3><blockquote><p>Thread继承与Runnable创建比较<br><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710172644.png" alt="比较"><br>Runnable 与 Callable 比较：<br>Runnable不带返回值，代码实现简单，对主线程影响较小;<br>而Callable带返回值，除了实现call方法外，还要用FutureTask 类来实现返回值的调用，并且调取get()方法会引起主线程阻塞；</p></blockquote><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><blockquote><p>按照老师的课程，线程的执行过程中，有一下6种状态：New(新建状态)，Runnable(运行状态)，Blocker(阻塞状态)，Waiting/TimedWaiting(有限等待、无限等待状态)，Teminated(终止状态)</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710174520.png" alt="线程的6种状态"></p><blockquote><p>查阅了相关书籍后，我觉得按照这个图来形容来划分比较合理：</p></blockquote><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200711095406.png" alt=""></p><blockquote><p>为什么start()后要划分成就绪跟运行状态？<br>由于线程启动后，不会一直“霸占”着CPU来执行，CPU会在多线程之间来回切换，所以线程也会在运行，就绪之间往复交替；</p></blockquote><h2 id="控制线程"><a href="#控制线程" class="headerlink" title="控制线程"></a>控制线程</h2><blockquote><p><strong>设置守护线程：</strong><br>(线程的引用)t.setDaemon(true)<br>守护线程的概念，守护线程也可以叫后台线程，其特征为：当所有的前台线程死亡后，后台线程自动结束，（）内输入 true 为设置成守护线程，不输入或者输入false,为不设置；<br>JVM 的垃圾回收就是典型的后台线程;</p></blockquote><blockquote><p><strong>让线程按下暂停键</strong><br>Thread.sleep()<br>在代码中插入<code>Thread.sleep()</code>后会使程序暂停一段时间，并进入阻塞状态；相比较而言，yield()方法，这个方法只会让线程重新调度一下，并不会暂停；</p></blockquote><blockquote><p><strong>改变程序的优先级</strong><br>Thread.currenttThread().setPriority(5)<br>赋予线程优先级，优先级高的更容易被执行；<br>括号内的数值范围是（1-10）,分别对应10种优先级，也可以调用三个静态常量MAX_PRIORITY/NORM_PRIORITY/MIN_PRIORITY（10/5/1）；</p></blockquote><h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>想象这样一个画面：<br>A , B 同时去银行取钱，然后银行余额都显示1000元，A取500，B取1000，如果 A B两人扣款时间也一样，那银行余额是不是就变成了-500；</p><p>这样就是线程同步而引发出来的线程不安全行为；</p><p><img src= "/img/loading.gif" data-src="https://cdn.jsdelivr.net/gh/daliymove/tuchuang/img/20200710211748.png" alt=""></p><p>如何去解决线程不安全：</p><blockquote><p><strong>方法1 ：同步代码块</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="comment">//代码如下：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>{<span class="comment">//线程安全性解读一</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">        <span class="comment">//总票数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span> ;</span><br><span class="line">        <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">synchronized</span> (o) {<span class="comment">//在执行方法前插入同步代码块sychronized</span></span><br><span class="line">                    <span class="keyword">if</span>(count&gt;<span class="number">0</span>) {</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"准备卖票，总票数为："</span> + count);</span><br><span class="line">                        <span class="keyword">try</span> {</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        }</span><br><span class="line">                        count--;</span><br><span class="line">                        System.out.println(<span class="string">"卖票成功，余票为："</span> + count);</span><br><span class="line">                    }<span class="keyword">else</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>理解如下：</p><p>当Thread-0/Thread-1/Thread-2 到达if 循环前，最先到达的那个线程会被套上 sychronized 给的标记 o，当标记 o 激活时，假定最先到达的是Thread-0，Thread-1/Thread-2 会在原地等待，等待标记消失后再向下执行，而当Thread-0执行完成if中的语句后，标记会被清除，Thread-0会随着循环再一次来到if前，而标记清除后，Thread-1/Thread-2 接收到标记消失命令，再开始往下执行；这个时候谁会执行是不一定的，取决于谁能争抢到时间片；</p></blockquote><blockquote><p><strong>方法2 ：同步方法</strong></p><p>将if后面的代码打包成一个方法，然后用synchronized进行修饰（准确说是进行装饰），代码如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>{<span class="comment">//线程安全性解读</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Ticket();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">        <span class="comment">//总票数</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span> ;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                <span class="keyword">this</span>.sale();</span><br><span class="line">                <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sale</span><span class="params">()</span></span>{<span class="comment">//用synchronized修饰sale()方法，依然放在if前</span></span><br><span class="line">            <span class="keyword">if</span>(count&gt;<span class="number">0</span>) {</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"准备卖票，总票数为："</span> + count);</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                }</span><br><span class="line">                count--;</span><br><span class="line">                System.out.println(<span class="string">"卖票成功，余票为："</span> + count);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p><strong>方法3 ：添加显示锁</strong></p><p>上述的两种方式相当于是隐式锁的概念，从Java 5 开始，Java官方添加了一种更强大的线程同步机制——同步锁，由Lock对象充当；</p><p>同步锁一般比较常用的是Lock对象的实现类ReentrantLock（可重入锁），代码如下</p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>{<span class="comment">//线程安全性解读</span></span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">           Runnable r = <span class="keyword">new</span> Ticket();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">           <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">       }</span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>{</span><br><span class="line">           <span class="comment">//总票数</span></span><br><span class="line">           <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">10</span> ;</span><br><span class="line">           <span class="keyword">private</span> Lock l = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">               <span class="keyword">while</span> (<span class="keyword">true</span>) {</span><br><span class="line">                   l.lock();</span><br><span class="line">                   <span class="keyword">try</span> {</span><br><span class="line">                       <span class="keyword">if</span> (count &gt; <span class="number">0</span>) {</span><br><span class="line">                           System.out.println(Thread.currentThread().getName() + <span class="string">"准备卖票，总票数为："</span> + count);</span><br><span class="line">                           Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                           count--;</span><br><span class="line">                           System.out.println(<span class="string">"卖票成功，余票为："</span> + count);</span><br><span class="line">                       } <span class="keyword">else</span></span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                   }<span class="keyword">catch</span>(InterruptedException e){</span><br><span class="line">                       e.printStackTrace();</span><br><span class="line">                   }<span class="keyword">finally</span>{</span><br><span class="line">                       l.unlock();</span><br><span class="line">                   }</span><br><span class="line">               }</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure></blockquote><blockquote><p>ReentrantLock() 括号内可传入boolean 参数，传入true后，锁就变成了公平锁，会让线程排队执行，以上述为例，会依次Thread -0（假设0线程第一个执行）、Thread-1(假设第二个执行)、Thread-2(第三个执行)，会依次 0/1/2、0/1/2的顺序（当然也可以102,201的顺序，取决于谁先抢到时间片，但第一次循环后，顺序就固定下来了）执行，直至线程结束； </p></blockquote><blockquote><p><strong>死锁</strong></p></blockquote><p>在线程同步中，添加同步监视器过多，可能会导致死锁的现象；</p><p>可以这样来理解：在A 运行的代码中加入B的锁，等待B解锁后才能向下执行；又在B运行的代码中加入A 的锁，等待 A 解锁后才向下执行，假如 A 等待 B 的时候，B又在等待 A ，这样死锁就产生了；</p><p>一旦死锁产生，整个程序不会出错，也没有任何提示，整个处于阻塞的状态，无法继续。</p><h2 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h2><blockquote><p><strong>生产者和消费者问题：</strong></p></blockquote><p>A 是生产者，负责生产食物和数量，B 是消费者，负责接收食物和数量，想象一个场景，假如 A 生产两种食物，循环递给B，B负责消费，消费完成后 ，通知A 进行生产 ，依次按顺序循环100次，怎样进行如上的代码实现呢；</p><p>方法一：</p><p>Object 类有三个有助于线程通信的方法，wait() 使当前线程等待，notify() 随机唤醒一个线程，notifyAll()，唤醒所有线程；</p><p>利用这三个方法，再加上标签flag = ture /false ，可以很好的实现如上代码需求；具体代码就不展示了，有点占篇幅；</p><p>方法二：</p><p>使用BlockingQueue（阻塞队列）</p><p>put() 把元素放入队列，如果队列已满，则阻塞该线程</p><p>take() 从队列头取走元素，如果队列已空，则阻塞线程；</p><p>这个不是太会；后面再研究</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><blockquote><p><strong>为什么需要线程池？</strong></p></blockquote><ol><li>系统创建一个新线程的耗费是很大的，而运行一个线程耗费要小很多，运用线程池的概念，可以很好的提升系统性能；</li><li>线程池可以很好的控制系统中并发线程的数量，即在创建初直接指定并发执行的线程数；</li><li>线程池能提供定时执行、定期执行、单线程、并发数控制等功能</li></ol><blockquote><p><strong>四种线程池的创建</strong></p></blockquote><p>第一种，缓存线程池：</p><p><code>newCachedThreadPool()</code>，创建一个具有缓存功能的线程池，可灵活回收空闲线程；</p><p>第二种，定长线程池：</p><p><code>newFixedThreadPool(初始线程数)</code>，初始线程数一旦被固定，就只能使固定数量的线程并发运行；</p><p>第三种，单线程线程池</p><p><code>newSingleThreadExecutor()</code> ，创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务</p><p>第四种，周期执行线程池</p><p><code>newScheduledThreadPool()</code>，创建一个定长线程池，支持定时及周期性任务执</p><h2 id="多线程面试题"><a href="#多线程面试题" class="headerlink" title="多线程面试题"></a>多线程面试题</h2><p>参考链接：<a href="https://blog.csdn.net/cmyperson/article/details/79610870" target="_blank" rel="noopener">50个多线程面试题汇总</a></p><p><strong>什么是线程？</strong></p><p>线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。</p><p>比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒</p><p><strong>什么是线程安全和线程不安全？</strong></p><p>线程安全: 就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问，直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染</p><p>线程不安全：就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据</p><p><strong>什么是自旋锁？</strong></p><p>当线程A想要获取一把自旋锁而该锁又被其它线程锁持有时，线程A会在一个循环中自旋以检测锁是不是已经可用了</p><p><strong>什么是乐观锁和悲观锁？</strong></p><p>悲观锁</p><p>Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。</p><p>乐观锁</p><p>乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做</p><p>==============================</p><p>还有很多题目，详见参考链接，就不一一赘述了；</p><p>全剧终</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Finally之未解之谜</title>
      <link href="/2020/07/08/finally-guan-jian-zi-zhi-mian-shi-xiang-guan-hui-zong/"/>
      <url>/2020/07/08/finally-guan-jian-zi-zhi-mian-shi-xiang-guan-hui-zong/</url>
      
        <content type="html"><![CDATA[<h1 id="Finally-关键字"><a href="#Finally-关键字" class="headerlink" title="Finally 关键字"></a>Finally 关键字</h1><hr><h2 id="Finally-是什么？"><a href="#Finally-是什么？" class="headerlink" title="Finally 是什么？"></a>Finally 是什么？</h2><p>有一些代码，可能会希望try块中的异常无论是否抛出，都需要执行某一些语句，这个时候，我们就用到了finally;</p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">try块语法：</span><br><span class="line">try{</span><br><span class="line"></span><br><span class="line">}catch(异常类 形参){</span><br><span class="line"></span><br><span class="line">}finally{</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">try块 catch和finally可任选一个，一般两个都写，不可以两个都不写；</span><br></pre></td></tr></tbody></table></figure><h2 id="Finally常见问题"><a href="#Finally常见问题" class="headerlink" title="Finally常见问题"></a>Finally常见问题</h2><h3 id="1-try语句中有异常，finally-语句块会执行吗？"><a href="#1-try语句中有异常，finally-语句块会执行吗？" class="headerlink" title="1. try语句中有异常，finally 语句块会执行吗？"></a>1. try语句中有异常，finally 语句块会执行吗？</h3><p>这个答案是肯定的。finally语句的优先级等级很高，只要不涉及一些关键字眼，如<strong>JVM异常关闭</strong>,<strong>系统异常崩溃</strong>等，finally中的语句总是会执行的，不管是否有异常抛出。</p><h3 id="2-finally-与-continue-break之间的关系"><a href="#2-finally-与-continue-break之间的关系" class="headerlink" title="2. finally 与 continue,break之间的关系"></a>2. finally 与 continue,break之间的关系</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">continue</span>与<span class="keyword">break</span> 代表着跳出本次循环、结束本次循环，<span class="keyword">finally</span>遇上这两个代码会怎么样呢？</span><br><span class="line"></span><br><span class="line">请看以下代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) {</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">3</span>) {</span><br><span class="line">                <span class="keyword">break</span>;<span class="comment">//continue也一样</span></span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }<span class="keyword">catch</span>(Exception e) {</span><br><span class="line">        System.out.println(<span class="string">"有异常，请检查"</span>);</span><br><span class="line">    }<span class="keyword">finally</span> {</span><br><span class="line">        System.out.println(<span class="string">"一定会执行"</span>);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">一定会执行</span><br><span class="line"></span><br><span class="line">可以看到即使跳出了循环，<span class="keyword">finally</span>语句中的内容依然会执行</span><br></pre></td></tr></tbody></table></figure><h3 id="3-finally与return的关系"><a href="#3-finally与return的关系" class="headerlink" title="3. finally与return的关系"></a>3. finally与return的关系</h3><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>的执行逻辑：</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>. 复制一份<span class="keyword">return</span>后的表达式至操作数栈顶，计算表达式的值，将表达式的值保存至操作数栈顶</span><br><span class="line">    <span class="number">2</span>. 检查后续代码有无<span class="keyword">finally</span></span><br><span class="line">    <span class="number">3</span>. 若有，则优先执行<span class="keyword">finally</span>内的代码，再返回操作数栈顶的值</span><br><span class="line">    <span class="number">4</span>. 若没有，则直接返回操作数栈顶的值</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">观察下面代码：</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinallyLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line"></span><br><span class="line">    System.out.println(say());</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> a =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            a = <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        }<span class="keyword">finally</span> {</span><br><span class="line">            a = <span class="number">20</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">想一想输出的值是什么？</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2328241580,270776270&amp;fm=26&amp;gp=0.jpg" alt="思考"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">答案为：10</span><br><span class="line"></span><br><span class="line">通过上面的4步，很容易判断，操作数栈顶的保存的值为10，虽然后面通过finally中的语句使a的值变为了20，但return返回的值仍是10；</span><br></pre></td></tr></tbody></table></figure><p>看看网上的一个面试题：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/26/BQDrToY9O5mX8q4.png" alt="mianshi.png"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">想一想答案是什么？</span><br><span class="line"></span><br><span class="line">下面我们通过画图来演示一下</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/26/BXoIRxgl6yrwpKE.png" alt="tupian"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">所以第一行打印Test1()的时候，先打印try语句中的'A',然后将'A'保存至操作数栈，后面打印finally语句中的'B',将Label的值变为'B',Test1()的返回值为'A',Label的值为'B';</span><br><span class="line"></span><br><span class="line">输出的值为： A***;</span><br></pre></td></tr></tbody></table></figure><p><strong>升华一下</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">我们来变一下，倘若在<span class="keyword">finally</span>后面加上<span class="keyword">return</span>语句，结果会不会不一样呢？</span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Label;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">System.out.println(say());</span><br><span class="line">System.out.println(Label);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">System.out.println(<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">return</span> Label = <span class="string">'A'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">finally</span> {</span><br><span class="line">System.out.println(<span class="string">'B'</span>);</span><br><span class="line"><span class="keyword">return</span> Label = <span class="string">'B'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">这下返回的结果会是什么样呢？</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://tse3-mm.cn.bing.net/th/id/OIP.hoS8C8Tvn6ahI_XKFt2NwwHaHV?pid=Api&amp;rs=1" alt="a"></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">对没错,输出的就是A***</span><br><span class="line"></span><br><span class="line">解释如下：</span><br><span class="line"></span><br><span class="line">第一个return,是将'A'储存进了操作数栈顶，然后在执行finally语句的时候，又一次的将'B'保存在了操作数栈顶，所以最终返回值跟Label的值都为'B';</span><br></pre></td></tr></tbody></table></figure><p><strong>再升华一下</strong></p><figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">大家是不是对于<span class="keyword">finally</span>与<span class="keyword">return</span>的关系掌握得更具体了呢，再升华一点，如果在<span class="keyword">try</span> 块后面加上<span class="keyword">return</span> <span class="string">'A'</span>;<span class="keyword">try</span> 块内添加<span class="keyword">catch</span>(Expection e)语句，结果会怎么样？</span><br><span class="line"></span><br><span class="line">代码如下：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnLearn</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> Label;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">System.out.println(say());</span><br><span class="line">System.out.println(Label);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span> <span class="title">say</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">System.out.println(<span class="string">'A'</span>);</span><br><span class="line"><span class="keyword">return</span> Label = <span class="string">'A'</span>;</span><br><span class="line">}<span class="keyword">catch</span>(Exception e) {</span><br><span class="line">}</span><br><span class="line"><span class="keyword">finally</span> {</span><br><span class="line">System.out.println(<span class="string">'B'</span>);</span><br><span class="line">Label = <span class="string">'B'</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="string">'C'</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">想一想结果会怎样？</span><br><span class="line"></span><br><span class="line">大脑一片空白··········</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">emmm  问师傅 我也不知道！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此处省略一万字。。。。</span><br></pre></td></tr></tbody></table></figure><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/26/VtdEGlsar4be2WU.jpg" alt="aa.jpeg"></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/sinat_22594643/article/details/80509266" target="_blank" rel="noopener">https://blog.csdn.net/sinat_22594643/article/details/80509266</a><br><a href="https://blog.csdn.net/WYpersist/article/details/80710352" target="_blank" rel="noopener">https://blog.csdn.net/WYpersist/article/details/80710352</a><br><a href="https://www.jianshu.com/p/144a4496575a" target="_blank" rel="noopener">https://www.jianshu.com/p/144a4496575a</a></p><p>仅仅代表一些很基础的个人观点，希望大家能积极指出不足，我一定好好修改的，希望我能跟小伙伴们一起进步！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> finally </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap之深入浅出</title>
      <link href="/2020/07/08/hashmap-xiang-jie/"/>
      <url>/2020/07/08/hashmap-xiang-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="HashMap-详解"><a href="#HashMap-详解" class="headerlink" title="HashMap 详解"></a>HashMap 详解</h1><p>大叫好，争取明天能开个头</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown使用</title>
      <link href="/2020/06/30/wo-de-di-yi-pian-bo-ke-bi-ji/"/>
      <url>/2020/06/30/wo-de-di-yi-pian-bo-ke-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="Markdown的使用方法（小白篇）"><a href="#Markdown的使用方法（小白篇）" class="headerlink" title="Markdown的使用方法（小白篇）"></a>Markdown的使用方法（小白篇）</h1><p><embed src="//music.163.com/style/swf/widget.swf?sid=458217431&amp;type=2&amp;auto=0&amp;width=320&amp;height=66" width="340" height="86" allownetworking="all"></p><hr><h2 id="标题类"><a href="#标题类" class="headerlink" title="标题类"></a>标题类</h2><p>#+空格+一级标题 = 一级标题</p><p>##+空格+二级标题 = 二级标题</p><p>###+空格+三级标题 = 三级标题</p><p>####+空格+四级标题 = 四级标题</p><p>……</p><p>共六级标题</p><p>类似这个样式</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/06/18/PKVDBh2cosW3N9g.png" alt="title"></p><h2 id="区块与引用"><a href="#区块与引用" class="headerlink" title="区块与引用"></a>区块与引用</h2><p><strong>无序区块</strong></p><p>文字前加上 - 或 * 即可变为无序区块，例：</p><ul><li>1</li><li>2</li><li>3</li></ul><p><strong>有序区块</strong></p><p>文字前加上 1.即可变为有序列表，例：</p><ol><li>1</li><li>2</li><li>3</li></ol><p><strong>引用</strong></p><p>在文本前加上 &gt; 即可实现引用功能</p><blockquote><p>例如：Rome was’t built in a day</p></blockquote><p><strong>多层引用</strong></p><p>一个 &gt; 是最外层，两个 &gt;&gt; 是次外层，三个 &gt;&gt;&gt; 是次次外层</p><blockquote><p>最外层</p><blockquote><p>次外层</p><blockquote><p>次次外层</p></blockquote></blockquote></blockquote><p><strong>在区块内引用</strong></p><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进</p><p>举个例子：</p><ul><li><p>第一项</p><blockquote><p>菜鸟教程</p></blockquote><ol><li><p>如何从菜鸟成功变成一个老鸟…..</p><blockquote><p>学的不仅是技术更是梦想</p></blockquote></li></ol></li><li><p>第二项</p></li></ul><h2 id="插入超链接与代码块"><a href="#插入超链接与代码块" class="headerlink" title="插入超链接与代码块"></a>插入超链接与代码块</h2><p><strong>图片格式</strong></p><p>!”[]”(“图片链接”)”</p><p>例如：</p><p><img src= "/img/loading.gif" data-src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2493015871,2263103202&amp;fm=26&amp;gp=0.jpg" alt="你的名字"></p><p>安利一个网址，可以自动将本地照片输出成各种格式：</p><p><a href="https://sm.ms/" target="_blank" rel="noopener">本地png图片转超链接点我</a></p><p><strong>链接格式</strong></p><p>“[输入网站介绍]”(“超链接”)”</p><p>备注：！ 与 （）都要是英文格式的哦!</p><p><strong>插入代码块</strong></p><ol><li>代码函数插入：利用``将其选中即可<br>举例<code>System.out.println()</code></li><li>代码区块用三个<code>```</code>包裹即可<br>举例:<figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">int a =10;</span><br><span class="line">int b =20;</span><br><span class="line">System.out.println(a+b);//30</span><br></pre></td></tr></tbody></table></figure><h2 id="强调字体与表格"><a href="#强调字体与表格" class="headerlink" title="强调字体与表格"></a>强调字体与表格</h2></li></ol><p><strong>强调字体</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">强调字体可以有如下形式：</span><br><span class="line"></span><br><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">~~删除线~~</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></tbody></table></figure><p><strong>表格</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">语法如下:</span><br><span class="line"></span><br><span class="line">|  表头  | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></tbody></table></figure><p>输出样式：</p><p><img src= "/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2019/03/23EACC50-38E0-4284-B99A-6BC22E284BAC.jpg" alt=""></p><p><strong>表格对齐方式</strong></p><figure class="highlight plain"><table><tbody><tr><td class="code"><pre><span class="line">语法如下:</span><br><span class="line"></span><br><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></tbody></table></figure><p>输出样式：</p><p><img src= "/img/loading.gif" data-src="https://www.runoob.com/wp-content/uploads/2019/03/87DE9D5C-44FB-4693-8735-194D3779EC3E.jpg" alt=""></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/weilf/p/4567334.html" target="_blank" rel="noopener">https://www.cnblogs.com/weilf/p/4567334.html</a><br><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/markdown/md-tutorial.html</a></p><hr><p>如果可以的话。建议使用Typora这款软件进行.md文件的编写，比较方便，附下载链接：<br><a href="https://www.typora.io/#windows" target="_blank" rel="noopener">Typora下载</a></p><p>如果想体验操作的快感还是使用Markdown编辑器编辑吧！</p><p>不喜勿喷。记得三连</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
